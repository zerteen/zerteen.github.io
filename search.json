[{"url":"/article/Untitled/","content":""},{"title":"A Deep Face Identification Network Enhanced by Facial Attributes Prediction","url":"/article/A%20Deep%20Face%20Identification%20Network%20Enhanced%20by%20Facial%20Attributes%20Prediction/","content":"A Deep Face Identification Network Enhanced by Facial Attributes Prediction\n\npoints：\n\n新的网络结构来predict facial attribute的同时进行 face identification。\n已有的multi-task方法都是共享CNN的特征空间，本文提出用的方法是融合两个task子网络的特征。两个网络交替地进行训练能够相互促进。\n\n​\t整个结构的策略是用两个网络分别预测attribute和identification，在进行identification时，attribute的结果将被取出来用于作为auxiliary modality来帮助identification的进行。\n\n\n\n两个网络级联，前一个网络（net@1）是vgg 19的结构\n后面的网络（net@2）上面的分支（branch@1）用于做attribute prediction，下面的分支融合net@1的输出和branch@1的特征后，用softmax做identification。\n这里特征的融合操作使用到的是Kronecker product\n\n\nKronecker product\nIf A is an m × n matrix and B is a p × q matrix, then the Kronecker product A ⊗ B is the mp × nq block matrix:\n$$\n\\mathbf { A } \\otimes \\mathbf { B } = \\left[ \\begin{array} { c c c } { a _ { 11 } \\mathbf { B } } &amp; { \\cdots } &amp; { a _ { 1 n } \\mathbf { B } } \\ { \\vdots } &amp; { \\ddots } &amp; { \\vdots } \\ { a _ { m 1 } \\mathbf { B } } &amp; { \\cdots } &amp; { a _ { m n } \\mathbf { B } } \\end{array} \\right]\n$$\n\n​\t论文中是对两个向量进行这样的操作，操作如下：\n$$\n\\mathbf { u } \\otimes \\mathbf { v } = \\left[ \\begin{array} { c } { u _ { 1 } } \\ { u _ { 2 } } \\ { \\vdots } \\ { u _ { n } } \\end{array} \\right] \\otimes \\left[ \\begin{array} { c } { v _ { 1 } } \\ { v _ { 2 } } \\ { \\vdots } \\ { v _ { m } } \\end{array} \\right] = \\left[ \\begin{array} { c } { u _ { 1 } v _ { 1 } } \\ { u _ { 1 } v _ { 2 } } \\ { \\vdots } \\ { u _ { 1 } v _ { m } } \\ { u _ { 2 } v _ { 1 } } \\ { \\vdots } \\ { u _ { n } v _ { m } } \\end{array} \\right]\n$$\nLoss：\n$$\n\\begin{array} { l } { \\mathcal { L } _ { 1 } \\left( W _ { 1 } , W _ { 2,1 } , X \\right) = - \\sum _ { j = 1 } ^ { T } \\sum _ { i = 1 } ^ { N } L _ { j i } \\log \\left( f ^ { \\prime } \\left( f \\left( L _ { j i } \\left| x _ { i } , W _ { 1 } \\right. \\right. \\right. \\right. }  { W _ { 2,1 } ) ) ) + \\left( 1 - L _ { j i } \\right) \\log \\left( f ^ { \\prime } \\left( f \\left( 1 - L _ { j i } | x _ { i } , W _ { 1 } , W _ { 2,1 } \\right) \\right) \\right) } \\end{array}\n$$\n$$\n\\begin{array} { l } { \\mathcal { L } _ { 2 } \\left( W _ { 1 } , W _ { 2,1 } , W _ { 2,2 } , X \\right) = - \\sum _ { i = 1 } ^ { N } \\sum _ { k = 1 } ^ { C } L _ { i k } ^ { \\prime } \\log \\left( g ^ { \\prime } \\left( g \\left( L _ { i k } ^ { \\prime } \\left| x _ { i } \\right. \\right. \\right. \\right. } { W _ { 1 } , W _ { 2,2 } , f \\left( x _ { i } , W _ { 1 } , W _ { 2,1 } \\right) ) ) ) } \\end{array}\n$$\n​\t用到的数据集是CeleA 和Mega Face, 其中，CeleA带有attribute，Mega Face不带attribute，因此，作者先用CeleA训练网络，然后在Mega Face的实验中，对其进行微调。（对attribute没有label的话，应该就调不了了吧）\n​\t论文中提到对attribute的预处理。对于同一个人来说，这个人的attribute应该保持一致，但是同一个人的图像中，存在一些attribute的数值是变化的，比如这个人是否戴眼镜（glasses），是否存在山羊胡子（mustaches），对于这些不确定的attribute，作者将他们去掉了，最终只留下了一下的attribute\n\nnarrow eyes\tbig nose\t pointy nose\t\tchubby\t\tdouble chin\t\thigh cheekbones\tmale\tbald\tbig lips\t\toval face .\n\n实验结果：\n\n\n","tags":["face"]},{"title":"A Unified Approach for Conventional Zero-Shot, Generalized Zero-Shot, and Few-Shot Learning","url":"/article/A%20Unified%20Approach%20for%20Conventional%20Zero-Shot,%20Generalized%20Zero-Shot,%20and%20Few-Shot%20Learning/","content":"A Unified Approach for Conventional Zero-Shot, Generalized Zero-Shot, and Few-Shot Learning\n\n论文总结了通用的监督学习存在的问题：\n\n大量的依赖训练数据的监督标签。当数据量巨大的时候，并不能保证每一个类的标注都是充足的和有效的。\n在模型训练完成之后，可能会存在新的类别出现，而当前的模型并没有经过这些新出现类别的训练。\n现实中，新出现的类别是可能通过已经存在的类别推导出来的，而监督学习没有考虑这一点。\n\nZSH的目的就是利用语义信息（Semantic information），将新出现的类别和已存在的类别联系起来。\n总结了ZSL的两种方法：\n\n\nattribute/word vector prediction\n\nGiven an image, they attempt to approximate label embedding and then classify an unseen class image based on the similarity of predicted vector with unseen attribute/word vector.\n给定一张图像，先从图像中提取出一个label embedding，然后计算提取出的label embedding和unseen class attribute的相似度，进行分类。\n\n\n\ncompatibility function\n\nlearn a compatibility function between image and label embeddings, which returns a compatibility score. An unseen instance is then assigned to the class that gives the maximum score.\n学习的是一个函数，返回每一张图像和label embedding的相似度，根据相似度进行分类。这里只有图像和label embedding。\n\n\n\n主要的贡献：\n\n提出了Class Adapting Principal Directions(CAPD)，来解决图像特征和语义特征之间的联系。\n定义了semantic space，提出用seen class来推导unseen class。\n提出将同一个类别的sample聚类，使得对unseen class的推导更robust。\n\n主要的思路：\n先为为每一个seen class 学习一个矩阵w。对每一个image，通过w，使其在所有seen class中都产生一个向量p，然后对每一个unseen class，学习一个从seen class到unseen class的推到。通过这个推到，能够从seen class的每一个p得到unseen class的每一个p，然后对unseen class的每一个p与之对于的e进行点积操作，得到具体数值，最大的数值对应的class就是unseen 分类得到的标签。\n\n符号定义：\n\nlabel：$\\mathbf{y} = \\mathbf{y ^ { s }} \\cup \\mathbf{y ^ { u }}$  其中，$\\mathbf { y } ^ { \\mathcal { S } } = { 1 , \\ldots , \\mathrm { S } }$为seen class的label，$\\mathbf { y } ^ { \\mathcal { U } } = { S , \\ldots , \\mathrm { S+U } }$为 unseen class的label。\nsemantic class embedding: $\\mathbf { E } ^ { \\mathcal { S } } = \\lbrace \\mathbf { e } _ { s } : s \\in \\mathbf { y } ^ { \\mathcal { S } } \\rbrace $, $\\mathbf { E } ^ { \\mathcal { U } } = \\lbrace \\mathbf { e } _ { u } : u \\in \\mathbf { y } ^ { \\mathcal { U } } \\rbrace $, $\\mathbf { e } _ { s } , \\mathbf { e } _ { u } \\in \\mathbb { R } ^ { d }$\nImages: $\\mathbf { X } _ { s } = \\left[ \\mathbf { x } _ { s } ^ { 1 } , \\ldots , \\mathbf { x } _ { s } ^ { n _ { s } } \\right]$, $\\mathbf { X } _ { u } = \\left[ \\mathbf { x } _ { u } ^ { 1 } , \\ldots , \\mathbf { x } _ { u } ^ { n _ { u } } \\right]$ 其中，$n_s$是seen class中data的总数，同理$n_u$\nzsl的目标是为了给每一个unseen images 指定其类别\ngzsl的目标是为了给任意一个image指定其类别，该image可以来自seen class， 也可以来自unseen class\nfsl的目标是同gzsl，只不过在训练数据中加入了少量的unseen class\n\n\nclass adapting principle direction(CAPD)\nCAPD对seen class和unseen class的处理方式是不同的。\nCAPD on seen class\n$$\n\\mathbf { p } _ { s } = \\mathbf { W } _ { s } ^ { T } \\mathbf { x } _ { s }\n$$\n对seen class，需要学习一个mapping function [$\\mathbf{W_s}$]，将image映射到semantic space中的principle direction [$\\mathbf{p_s}$]\n对$\\mathbf{W_s}$的学习使用到如下的目标函数：\n$$\n\\min _ { \\mathbf { W } _ { s } } \\frac { 1 } { \\kappa } \\sum _ { c = 1 } ^ { S } \\sum _ { m = 1 } ^ { n _ { c } } \\log \\left( 1 + \\exp \\lbrace L \\left( \\mathbf { x } _ { c } ^ { m } ; \\mathbf { W } _ { s } \\right) \\rbrace  \\right) + \\frac { \\lambda _ { s } } { 2 } \\left| \\mathbf { W } _ { s } \\right| _ { 2 } ^ { 2 }\n$$\n$$\n\\begin{equation}\n\\left( \\mathbf { x } _ { c } ^ { m } ; \\mathbf { W } _ { s } \\right) =\n\\begin {cases}\n\\left\\langle \\mathbf { p } _ { s } , \\mathbf { e } _ { c } \\right\\rangle - \\left\\langle \\mathbf { p } _ { s }  , \\mathbf { e } _ { s } \\right\\rangle , &amp; { c \\neq s } \\\n\\left\\langle \\mathbf { p } _ { s } , \\frac { 1 } { \\mathrm { S } - 1 } \\sum _ { t \\neq s } \\mathbf { e } _ { t } \\right\\rangle - \\left\\langle \\mathbf { p } _ { s } , \\mathbf { e } _ { s } \\right\\rangle , &amp; { c = s }\n\\end{cases}\n\\end{equation}\n$$\n\n以上loss的第一项表示，当前的的image属于第c个类别，在s类别的矩阵下生成的p在他对应的label的embedding投影小，在s label的enbedding投影大。\n第二项表示，当前的image属于第s个类别时，生成的p和在其他label的embedding的均值方向的投影小，在对应的label的embedding投影大。【论文中提出，这一项同时保证了p在对应的e上的投影要大于其他e的均值上的投影】\nCAPD on unseen class\n对unseen class，论文提出为每一个image使用双线性映射来估计他的p。\n$$\n\\mathbf { p } _ { u } = \\sum _ { s = 1 } ^ { S } \\theta _ { s , u } \\mathbf { p } _ { s } = \\mathbf { P } ^ { \\mathcal { S } } \\theta _ { u }\n$$\n也就是说，每一个unseen class是从seen中加权得到的。那这里的theta就是一个相似度metric，如何得到θ，论文提到。\n$$\n\\max _ { \\mathbf { M } } \\min _ { ( i , j ) \\in \\overline { A } } d _ { \\mathbf { M } } ^ { 2 } \\left( \\mathbf { p } _ { i } , \\mathbf { p } _ { j } \\right)\\ \\text { s.t. } \\sum _ { ( i , j ) \\in \\mathbf { A } } d _ { \\mathbf { M } } ^ { 2 } \\left( \\mathbf { p } _ { i } , \\mathbf { p } _ { j } \\right) \\leq 1\n\\\nd _ { \\mathbf { M } } = \\sqrt { \\left( \\mathbf { p } _ { i } - \\mathbf { p } _ { j } \\right) ^ { T } \\mathbf { M } \\left( \\mathbf { p } _ { i } - \\mathbf { p } _ { j } \\right) }\n$$\n确保每训练数据中，每一个同类 (i, j) ∈ A，之间的度量小于1，每一个不同类 (i, j) ∈ A^ 之间的最小距离最大化。\n在学习得到M之后，可以估计出unseen class的e\n$$\n\\hat { \\mathbf { e } } _ { u } = \\sum _ { s = 1 } ^ { \\mathrm { S } } \\alpha _ { s , u } \\mathbf { e } _ { s } = \\mathbf { E } ^ { \\mathcal { S } } \\alpha _ { u }\n$$\n上面的α可以通过下面的方式得到：\n$$\n\\min _ { \\alpha _ { u } } \\left( \\hat { \\mathbf { e } } _ { u } - \\mathbf { e } _ { u } \\right) ^ { T } \\mathbf { M } \\left( \\hat { \\mathbf { e } } _ { u } - \\mathbf { e } _ { u } \\right) + \\frac { \\lambda _ { u } } { 2 } \\left| \\alpha _ { u } \\right| _ { 2 } ^ { 2 }\n$$\nreduced set description of unseen classes\n论文提出，从seen class推理到unseen class不需要要所欲的类别参与，从S个类别降到N个类别：\n$$\n\\hat { \\mathbf { e } } _ { u } = \\sum _ { i = 1 } ^ { N } \\beta _ { i , u } \\mathbf { e } _ { i }\n$$\n这里的N是用e进行最邻近搜索得到的。\n同时，论文还提出来使用kernel density estimation来获得距离的概率the number of seen classes with the highest probability score is assigned as the value of N\nto be continued.\n","tags":["face"]},{"title":"ATTRIBUTE HASHING FOR ZERO-SHOT IMAGE RETRIEVAL","url":"/article/ATTRIBUTE%20HASHING%20FOR%20ZERO-SHOT%20IMAGE%20RETRIEVAL/","content":"ATTRIBUTE HASHING FOR ZERO-SHOT IMAGE RETRIEVAL\n这一片应该是 zsh （Zero-Shot Hashing via Transferring Supervised Knowledge）提出者的后续工作。在zsh中，对于semantic space 和hash space之间，使用了一个矩阵转换来降低 semantic gap的问题。但是对于高级的感知空间和低级的图像特征之间的semantic gap。\n\nZSH tends to transfer supervised knowledge among homogeneous categories, e.g., “cat” and “dog”, which neglects the precious resources among heterogeneous categories, e.g., “airplane” and “bird” sharing supervised knowledge through the common attribute “wing”\n\n作者尝试对属性进行建模，设计出一个多层的结构，属性在其中担任一个中间信号层的一个角色。\ncontribution：\n\nAH降低bianry code和label之间的sematic gap的同时，解决对unseen category的训练数据不足的问题。\nbinary code、属性、label、visual feature被融入到一个统一的层次结构，使得语义信息能够顺利的进行转换。\n保留binary code的离散性（discrete nature）和内在的局部结构信息（intrinsic local structural information）。没有传统的relaxation方法中的误差积累。\n\n\n","tags":["hashing"]},{"title":"Adversarial Transfer Learning","url":"/article/Adversarial%20Transfer%20Learning/","content":"Adversarial Transfer Learning\n​\t在一般的监督学习中，人们会假设训练集和测试集的样本是同分布的，但实际中是有可能存在分布上的差异的。当这里的差异有不同但是存在一定的联系的时候。迁移学习 能够将训练集的分布迁移到测试集的分布，使得最终的性能得到提升。\n\nWhen these distributions differ but are related, transfer learning can be used to transfer what is learned on the training distribution to the testing distribution, which often results in improved performance on the testing data in comparison with inaccurately assuming that the training data and testing data were drawn from the same distribution.\n\n​\tDomain Adaption（域适配）属于transfer learning的一个子领域，指的是存在source domain和target domain两个域，在这两个域上的task是一样的，space空间也是一样的，但是两个域之间存在分布上的差别。\n\nA popular case of transfer learning is domain adaptation, where the feature space and task remain fixed between a source domain and a separate target domain while the marginal probability distributions differ\n\n​\t例如，在分类问题中，可以在source domain中学习，然后应用到target domain中。有一个应用就是，在target没有标签，利用这种方式构造数据。\n","tags":["face"]},{"title":"DDH 论文解读","url":"/article/DDH-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/","content":"","tags":["face"]},{"title":"Deep Ordinal Hashing","url":"/article/Deep%20Ordinal%20Hashing/","content":"Deep Ordinal Hashing\n主要采用的是ranking to hashing的方式。\n大部分的deep hashing的方式是直接使用全连接层的输出并将其映射到hash code空间。但是全局的信息会带来空间信息损失 的问题，导致学习到的hash code不是最优的。所以文章提出来使用注意力机制，来抽取局部空间特征。\n考虑到在hash code进行量化的时候，通常使用的sign() 和threshold() 函数对噪音数值敏感，所以提出来使用基于排序的函数\n\n强调了局部空间的特征。\n利用排序结构对局部特征和全局特征进行排序，从而得到一个秩相关的表示。\n\n网络主要分为三部分：\n\n通过FCN和CNN学习局部空间和全局语意信息。\n通过一个子网络来对局部和全局的语意信息进行encoding，构架排序模型。\n使用一个有序表示学习来产生紧凑的hash code。\n\n\nCNN部分\nCNN部分主要采用AlexNet，在conv1-conv5, fc6-fc7, fc-c的基础之上再添加了一层全连接层fc-8. 这部分主要用来学习全局的语意特征。\nFCN部分\n同样基于AlexNet，将fc-6， fc-7替换成了两个卷积层conv6， conv7，再在之后添加了一fc-c。其中conv7后面连接了一个Global Average Pooling层 pool7\n"},{"title":"Face Recogonition Survey","url":"/article/Face-Recogonition-Survey/","content":"传统的人脸识别方法\n\nHistorical Eigenface Approach\nLinear Subspace\nManifold\nSparse Representation\nGabor\nLBP\n\n基于深度学习的人脸识别方法\n\nDeepFace\nDeepID\n\n相关综述\n[222], [18], [3], [78], [136], [123]\n数据集\nLFW [74]\nIJB-A/B/C [87], [174]\nMegaface [83]\nMS-Celeb-1M [59]\nCASIA-Webface   0.5M 10K\n\nFace Detection: 定位在那个地方\nFace Verification: 1-1, 判断两张图片是否属于同一个人\n属于Metric Learning，需要找到一个使得不同类的的表示更分散的度量（metric）\n\nJB模型：将一个人脸特征$x$看成$x=\\mu + \\varepsilon$ (identy + intra-persion variation)\n\n$$\nr(x_1, x_2) = \\log \\frac{P(x_1, x_2|H_1)}{P(x_1, x_2|H_E)}\n$$\n\t相似度的度量为：两个特征属脸于同一个类概率比上两个特征脸属于不同类的概率\nFace Identification: 1-N，判断给定的图片是那一个人\nclosed-set identification\n\nopen-set identification\n\n人脸的姿态，光线强弱，表情，姿势，遮挡影响了网络的性能。\n主要集中在对姿势的研究：\n\n1-N 增广，由单张图片生成多张不同姿势的图片，使网络能够得到泛化\nN-1 正规化，将图片中的不同姿势归一化成一个姿势\n\n\n网络结构：\n\nAlexNet\nVGGNet\nGoogleNet\nResNet\nSENet\n\n\nloss：\n\n\n欧氏距离，相比内类变化，更看重类间变\nPaire-wise loss\n\n\n$$\nLoss = y_{ij} \\max(0, ||f(x_i) - f(x_j)||2 - \\epsilon^+) + (1-y{ij})\\max(0, \\epsilon^- - ||f(x_i)-f(x_j))||_2)\n$$\n其中的参数$\\epsilon$ 难以学习到\n\n**Triplet Loss**\n\n$$\n||f(x_i^a)-f(x_i^p)||_2^2 + \\alpha &lt; -||f(x_i^a)-f(x_i^n)||_2^2\n$$\n\tCenter Loss\n为每一个类学习得到他的中心点，惩罚 特征到对应的中心点的距离\n\n$$\nL_c = \\frac{1}{2} \\sum^m_{i=1} || x_i - c_{y_i}||_2^2\n$$\n\n\n余弦距离， 根据学习到的特征之间的角度进行比较,使学习到的特征在角度空间上尽可能的分散\n\n\nSoftmax loss，\n\n\n\nFace Matching\n网络得到的特征进行距离计算，或者将得到的特征进行处理，metric learning，sparse-representation-based classifie\n\n网络架构：\n\n使用多个网络来处理不同尺寸的图片输入\n使用多个网络来处理不同的人体姿势（角度）\n多任务网络，主要进行任务分类的处理，其次进行对姿势，光照强度，表情等其他影响因素的处理。底层的特征共享，上层的网络将被分开来实现不同的功能。\n\n场景：\n\n\nCross-factor ：年纪因素，姿势因素，\n\n\nHeterogeneous：异源人脸识别，图像对视屏，近红外线到图片\n\n\nMultiple Media:  可能一个人的图片在训练集中非常少\n\n\nindustry： 出了精度之外，还有一个重要其他的影响因素也十分重要。3D建模，防伪等因素\n\n\n","tags":["Face Recognition"]},{"title":"How to understand EM intuitively?","url":"/Machine-Learning/How-to-understand-EM-intuitively/","content":"如何通俗的理解EM算法，看到了一篇很优秀的文章，在这里记录一下：https://www.jianshu.com/p/1121509ac1dc\n","categories":["Machine Learning"]},{"title":"NLP review ch01","url":"/NLP/NLP-review-ch01/","content":"ch01 intro\n自然语言处理：自然语言处理是研究如何利用计算机技术对语言文本（句子、篇章或话语等）进行处理和加工的一门学科，研究内容包括对词法、句法、语义和语用等信息的识别、分类、提取、转换和生成等各种处理方法和实现技术。\n屈折语：用词的形态变化表示语法关系，如英语、法语等。\n黏着语：词内有专门表示语法意义的附加成分，词根或词干与附加成分的结合不紧密，如日语、韩语、土耳其语等。\n孤立语：形态变化少，语法关系靠词序和虚词表示，如汉语\n分类：\n机器翻译、信息检索、自动文摘、问答系统、信息过滤、信息抽取、文档分类、情感分类、语音识别\n\n问题：\n\n形态学问题 --&gt; 关于词素的构成问题\n句法问题 --&gt; 句子构成成分之间的相互关系和聚成句子的序列的规则\n语义问题 --&gt; 从语句中词的意义推导出整个语句的意义\n语用学问题 --&gt; 上下文对语句理解的影响\n语音学问题 --&gt; 语音特性等等\n\n难点：\n\n歧义： 词法、词性、结构、语义、语音\n未知语言线性：新词、新含义、新用法\n\n研究方法：\n\n理性主义： 基于规则的分析方法建立符号处理系统\n\n规则库、辞典标注、推导算法\n知识库+推理系统 --&gt; NLP\n\n\n经验主义：基于大规模真实预料建立计算方法\n\n真实数据的收集、标注、统计模型\n语料库+统计模型 --&gt; NLP\n\n\n数据驱动的方法：双语料模型学习、翻译、解码\n基于统计的方法：构建语言模型、翻译模型\n\n语言模型概率p©\n翻译模型概率P(E|C)\n快速的搜索候选译文C，使得p©p(E|C)最大\n\n\n\n","categories":["NLP"]},{"title":"One-shot Face Recognition by Promoting Underrepresented Classes","url":"/article/One-shot-Face-Recognition-by-Promoting-Underrepresented-Classes/","content":"One-shot Face Recognition by Promoting Underrepresented Classes\n\n主要工作：\n\n\n将数据集分为了 base set 和 novel set，base set中大概有2w个人，1m张图片。 novel set中的每个人的图像只有一张\n\n\n先通过base set进行人脸特征的建模，使得模型具有好的泛化性能。这里提到的这个模型不是one shot learning所针对的问题，osl是在图像都能提取到一个特征之后，对图像进行分类的时候进行的操作。\n\n\n通过使用base set训练的到的模型，对LFW中的人脸图像提取人脸特征，用于分类时也能得到很好的性能。这里LFW中的人并没有在base set中出现过\n\n\n主要的想法在于，不管是novel set中的人还是base set中的人，他们在特征空间所占据的volume应该是大致一样的。所以定义了一个正则向， Underrepresented-class Promotion loss.\n\n\n\nRepresentation learning\n目的：在网络训练完之后，利用这个网络对图像提取特征。\n数据：这部分使用 base dataset进行分类。base dataset中一共包含2w个人，每个人大约50-100张图像。在这些图像中，每个人都随机取出了5张图像用作test，剩下的图像都用作训练。\n网络结构： 标准的residual network 34\n输出：网络最后一个池化层的特征被抽取出来用做人脸的representation\nNotes: 论文提到了这个模型提取的特征具有很好的泛华能力，base dataset中不包含LFW中的人，用这个网络在LFW上进行特征的提取\nOne-shot learning with UP\n数据： 2.1W个类别，训练数据包括base set和novel set。在训练过程中 novel set中的每一人只有一张图片参与训练，剩余的20张图像参与测试。\n网络：同Representation learning一样，使用上一步的参数进行初始化，然后finetune.\nloss: 交叉熵损失\n$$\np _ { k } \\left( x _ { n } \\right) = \\frac { \\exp \\left( \\mathbf { w } _ { k } ^ { T } \\boldsymbol { \\phi } \\left( x _ { n } \\right) \\right) } { \\sum _ { i } \\exp \\left( \\mathbf { w } _ { k } ^ { T } \\boldsymbol { \\phi } \\left( x _ { n } \\right) \\right) }\n$$\n$$\n\\mathcal { L } = - \\sum _ { n } t _ { k , n } \\log p _ { k } \\left( x _ { n } \\right)\n$$\n但是在这种loss下的表现并不好。\n​\t同时，在实验的过程中发现，对novel中的类别的weight vector的 norm 比base中的类别的norm小很多。\n\n​\t上图中，标出了每一个类别的weight vector的2范式，0-2w为base dataset中的类别，可以发现novel set中的类别的norm明显小于前面的类别。\n​\t同时，考虑到类别 $k$ 和类别 $j$ 这两个类别，他们的决策界为：\n$$\n\\frac { p _ { j } ( x ) } { p _ { k } ( x ) } = \\frac { \\exp \\left( \\mathbf { w } _ { j } ^ { T } \\phi ( x ) \\right) } { \\exp \\left( \\mathbf { w } _ { k } ^ { T } \\phi ( x ) \\right) } = \\exp \\left[ \\left( \\mathbf { w } _ { j } - \\mathbf { w } _ { k } \\right) ^ { T } \\phi ( x ) \\right]\n$$\n​\t可视化一下结果，可以看到当其中一个的$W$ 变小时，决策界会在特征空间中偏向于这个类别。\n\n​\t于是作者提出一个约束项来使得所有类别的wegiht vector的二范数差不多：\n$$\n\\mathcal { L } _ { u p } = \\sum _ { n } - t _ { k , n } \\log p _ { k } \\left( x _ { n } \\right) + \\frac { 1 } { \\left| C _ { n } \\right| } \\sum _ { k \\in C _ { n } } | | \\mathbf { w } _ { k } \\left| _ { 2 } ^ { 2 } - \\alpha \\right| _ { 2 } ^ { 2 }\n$$\n$$\n\\alpha = \\frac { 1 } { \\left| C _ { b } \\right| } \\sum _ { k \\in C _ { b } } \\left| \\mathbf { w } _ { k } \\right| _ { 2 } ^ { 2 }\n$$\n其中，$C_b$ 和 $C_n$ 分别是base中的类别和novel中的类别。这里相当于是把novel中类别的w趋近于base中的w.\n\n​\n​\t作者还提出一些其他的可选的约束项，例如：\n$$\n\\mathcal { L } _ { l 2 } = \\sum _ { n } - t _ { k , n } \\log p _ { k } \\left( x _ { n } \\right) + \\sum _ { k } \\left| \\mathbf { w } _ { k } \\right| _ { 2 } ^ { 2 }\n$$\n​\t以及：\n$$\n\\mathcal { L } _ { e q } = \\sum _ { n } - t _ { k , n } \\log p _ { k } \\left( x _ { n } \\right) + \\sum _ { k \\in \\left{ C _ { n } \\cup C _ { b } \\right} }|\\left| \\mathbf { w } _ { k } \\right| _ { 2 } ^ { 2 } - \\beta \\left| _ { 2 } ^ { 2 }\\right.\n$$\n$$\n\\beta = \\frac { 1 } { \\left| \\left{ C _ { n } \\cup C _ { b } \\right} \\right| } \\sum _ { k \\in \\left{ C _ { n } \\cup C _ { b } \\right} } \\left| \\mathbf { w } _ { k } \\right| _ { 2 } ^ { 2 }\n$$\n​\t主要的区别在于，作者提出的方式只对novel中的类别产生约束，使之趋近于base中的类别。\n​\n​\t下面的图中，很好的表示了这项工作的内容：\n\n（a）指的是一个比较平均的情况下，每个类的类别数目是大致一样的。\n（b）指的是one-shot的情况下，有些类别的训练数据可能只有很少的一两个。在这种情况下，一般的决策界（c）不能很好的起到对少类别的分类。此时，在加上论文提出的正则项之后，分类效果为（d），得到了一定的改善。\n","tags":["face"]},{"title":"Scalable Face Image Retrieval with Identity-Based Quantization and Multi-Reference Re-ranking","url":"/article/Scalable%20Face%20Image%20Retrieval%20with%20Identity-Based%20Quantization%20and%20Multi-Reference%20Re-ranking/","content":"Scalable Face Image Retrieval with Identity-Based Quantization and Multi-Reference Re-ranking\n2010年CVPR的论文，作者是Zhong Wu，Tsinghua&amp;MSAR\n\nMotivation\n\n底层的视觉特征对人脸图像没有很好的鉴别力\n\ndiscriminative power =&gt; to differentiate different persons\nto tolerate the variations of the same person\n\n\n人脸中的一些属性被忽略\n\nOverall View\n\n总的流程是先进行索引，然后进行细粒度的re-rank 。（coarse to fine 的模式）\n在索引建立的阶段，设计了一个component-based local feature，feature根据identity-bsed quantization schema量化成visual words，根据这些visual words进行倒排索引的建立。同时，global的feature因设成了哈希码保存在40bytes中。\n在re-rank阶段，根据40bytes的hamming distance进行排序\n\nComponent-Based Local Features\n\n​\t首先定义了五个region，每个region用一个$5 \\times 7$ 的grid进行划分。 对每一个gride取一个正方形的patch，然后对其进行T3hS2特征的提取，特征量化成visual words，然后进行倒排索引。\n这么划分的好处：\n​\t1 相比于全脸进行gride，这样更能够在表情变化和姿势变化中提炼出robust的人脸特征。\n​\t2 不同region的gride之间有重合，这样能减少region定位时的一些误差。\n​\t对gride进行了编号，当两个feature进行比较的时候，只有同一个编号里的feature都match了，才确定是match的。\n​\t接下来，就要对每一个gride的feature聚类来产生visual word了。但是，在人脸场景下，类内的差别又是后会大于类间的差异。在一个人姿势，表情差异变化较大的时候，直接使用k-means聚类的效果往往不太好，这样的话，量化误差会降低检索准确度。因此，论文提出来一个 identity-based quantization scheme。\n\n\n​\t使用的方式是监督学习，假设训练集中有P个人，每个人有T张不同的人脸图像。那么，&lt;persion_id, position_id&gt; 组成了一个二元组，形成一个visual word。这样，每一个visual word可以的含义就是：example-based representation containing multiple examples.\n这里可以这样理解：\n\n从类间角度出发，假设训练样本中的不同类型的人脸都被包含进去，那么每一人都具有一定的代表性。\n从类内角度出发，而对每一个人的图像如果足够多的话，每一个人的图像包含了这个人不同的表情，光照，姿态造成的差异。\n\n当以一个查询来的时候，提取这$5\\times7\\times5 = 175$个descriptor，然后对每一个discriptor独立地进行最邻近搜索。\n$$\nI D \\left( q ^ { j } \\right) = \\arg \\min _ { i } \\lbrace \\min _ { p } \\lbrace d \\left( q ^ { j } , p _ { i } ^ { j } \\right) , p _ { i } ^ { j } \\in S _ { i } ^ { j } \\rbrace \\rbrace\n$$\n其中，$\\mathcal { S } _ { i } ^ { j }$ 表示训练集中第i个人的第j个region，那么他就代表了一个visual word &lt;persion_id=i, position_id=j&gt; 。可以理解为，当有一个查询来的时候，对每一个identity在对应的第j个区域进行查询，找到距离最小的那个identity，作为这个查询第j部分的量化结果。然而，这里采取的是soft quantization，意思是，这里每一个region的feature量化之后，都取前R个最小的量化结果（R个identity）。\n\nGlobal Multi-Reference Re-Rank\n\n先对人脸进行对齐，然后是用DoG过滤掉阴影的变化，然后用一个encoder，对每一个像素点生成一个离散的数值，对每个图像进行gide，cell，得到这些离散值的频率直方图，然后进行PCA，得到一个400维的特征向量。\n如何进行离散操作呢？论文提出，在特征空间中寻找N个投影方向，对训练集中的数据对这个N个方向进行投影，然后对每个方向上投影数值的均值作为阈值。然后对于一个新来的特征，对着N个方向进行投影，如果投影值超过阈值，就为1，不超过就为0.\n然后，这里的Multi-Reference指的是\n$$\nD = d ( Q , I ) + \\alpha \\cdot \\frac { 1 } { | \\mathbf { R } | } \\sum _ { i } d \\left( R _ { i } , I \\right)\n$$\nQ指的是查询图像，$\\mathbf { R } = \\lbrace R _ { i } \\rbrace ​$ 指当前的reference set，$d ( \\cdot , \\cdot )​$ 是汉明距离，$I​$ 指的是从结果中抽取到的图片，迭代的选取图片加入到reference set，知道D大于某个阈值或者reference set中的数量达到一个阈值。\n这样做主要是为了保证，返回的图片中，除了要保证和查询结果相似之外，还要保证返回的结果间也是相似的。\n","tags":["face"]},{"title":"leetcode 427 建立四叉树","url":"/article/%20/","content":"我们想要使用一棵四叉树来储存一个 N x N 的布尔值网络。网络中每一格的值只会是真或假。树的根结点代表整个网络。对于每个结点, 它将被分等成四个孩子结点直到这个区域内的值都是相同的.每个结点还有另外两个布尔变量: isLeaf 和 val。isLeaf 当这个节点是一个叶子结点时为真。val 变量储存叶子结点所代表的区域的值。你的任务是使用一个四叉树表示给定的网络。\n下面的例子将有助于你理解这个问题：\n给定下面这个8 x 8 网络，我们将这样建立一个对应的四叉树：\n\n由上文的定义，它能被这样分割：\n\n对应的四叉树应该像下面这样，每个结点由一对(isLeaf, val)所代表.\n对于非叶子结点，val 可以是任意的，所以使用 * 代替。\n\n提示：\nN 将小于 1000 且确保是 2 的整次幂。\n如果你想了解更多关于四叉树的知识，你可以参考这个 wiki 页面。\n\n&quot;&quot;&quot;# Definition for a QuadTree node.class Node(object):    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):        self.val = val        self.isLeaf = isLeaf        self.topLeft = topLeft        self.topRight = topRight        self.bottomLeft = bottomLeft        self.bottomRight = bottomRight&quot;&quot;&quot;class Solution(object):    def construct(self, grid):        &quot;&quot;&quot;        :type grid: List[List[int]]        :rtype: Node        &quot;&quot;&quot;        def build(grid, x, y, width):            if width &lt;= 0:                return None            for i in range(x, x+width):                for j in range(y, y+width):                    if grid[i][j] != grid[x][y]:                        return Node(False,                                     False,                                     build(grid, x, y, width//2),                                    build(grid, x, y+(width//2), width//2),                                    build(grid, x+(width//2), y, width//2),                                    build(grid, x+(width//2), y+(width//2), width//2)                                   )            return Node(grid[x][y], True, None, None, None, None)        return build(grid, 0, 0, len(grid))        \n","tags":["leetcode","树","递归"]},{"title":"Normalization 总结","url":"/article/Normalization-%E6%80%BB%E7%BB%93/","content":"这些年来，提出了几个normalization的方法，这里做一个总结。主要包括以下几个：\n\nBatch Normalization\nLayer Normalization\nInstance Normalization\nGroup Normalization\n\n\n先提出一个问题：\n\n\ninternal covariate shift\n指的是，神经网络的层层叠加，每一层的输入依靠上一层的输出。当层数过高时，底层的微小的变化会导致高层输入的差异很大，使得高层的输入分布会发生非常剧烈的变化，这使得高层需要不断适应这种数据输入分布的变化。\n\n\n简单的处理方式就是，对每一层的数据进行一个转换，使得他们能够在一个区间之间。\n$$\nh = f\\left (g \\cdot\\frac{x-\\mu}{\\sigma} + b \\right )\n$$\n\n\n$\\mu$是平移参数（shift parameter)\n\n\n$\\sigma$是缩放参数（scale parameter）\n\n\n通过这两个参数进行 shift 和 scale 变换。使得数据分布满足均值为0，方差为1。 但是如果只有这样的话，模型的表达能力有限，非线性拟合能力就会下降，这样一来，作者引入了两个新的参数$g，b$来提高模型的线性拟合能力。这两个参数是模型学习得到的。\n\n\n$g$ 进行再缩放（re-scale parameter）\n\n\n$b$进行再平移(re-shift parameter)\n\n\n最终得到的数据符合均值为 $b$ 、方差为 $g^2$ 的分布。\n\n如何理解&quot;模型的表达能力有限，非线性拟合能力下降&quot;？\n对于一些激活函数，例如 sigmoid函数，它的激活可以分为饱和区和非饱和区，如果仅有第一步的缩放，那么数据都会在sigmoid的非饱和区间，这时候，只有模型只有线性表达能力，这样一来就降低了模型的表达能力。如果再进行一次缩放平移，数据就会映射到饱和区域，这样一来，就又有了非线性表达能力。\n\n虽然论文说BN解决了ICS，但是有人提出来说，没有证据表明BN解决了它。反而，有人提出，BN解决的是梯度弥散问题(消失或者爆炸)，他做到了优化空间变得平滑。\n\nBN存在的问题：\n\nbatchsize减小的话，效果不好\n对于像素级的图像生成，效果不好\nRNN使用不便\n训练时和推理时统计量不一致\n\n\n\nBatchNorm：batch方向做归一化，算$N\\times H \\times W$的均值\nLayerNorm：channel方向做归一化，算$C\\times H\\times W$的均值\nBN在RNN中用起来很不方便，而Layer Normalization这种在同隐层内计算统计量的模式就比较符合RNN这种动态网络，目前在RNN中貌似也只有LayerNorm相对有效，但Layer Normalization目前看好像也只适合应用在RNN场景下，在CNN等环境下效果是不如BatchNorm或者GroupNorm等模型的。\nInstanceNorm：一个channel内做归一化，算$H\\times W$的均值\n对于RNN或者MLP，如果在同一个隐层类似CNN这样缩小范围，那么就只剩下单独一个神经元，输出也是单值而非CNN的二维平面，这意味着没有形成集合S，所以RNN和MLP是无法进行Instance Normalization操作的，这个很好理解。\nGroupNorm：将channel方向分group，然后每个group内做归一化，算$ (C//G) \\times H \\times W$ 的均值\n通道分组是CNN常用的模型优化技巧，所以自然而然会想到对CNN中某一层卷积层的输出或者输入通道进行分组，在分组范围内进行统计。这就是Group Normalization的核心思想，是Facebook何凯明研究组2017年提出的改进模型。理论上MLP和RNN也可以引入这种模式，但是还没有看到相关研究，不过从道理上考虑，MLP和RNN这么做的话，分组内包含神经元太少，估计缺乏统计有效性，猜测效果不会太好。\n","tags":["Deep Learning"]},{"title":"ArcFace: Additive Angular Margin Loss for Deep Face Recognition","url":"/article/archface/","content":"\nIntro\n常用的人脸特征向量生成的方法都存在一定的问题：\n1. 基于分类的方法 \n - 网络中用于分类的全连接层W随着参与训练的identity的增加而增加，使得网络参数量大。\n - 在open-set的情景下，学习到的人脸特征区分力不够。\n2. 基于三元组的方法\n - 对于大规模的数据集，三元组的组合呈现出爆炸式的增长。\n - `hard sample`的挖掘很难。\n\n作者提出了Addictive Angular Margin Loss(ArchFace)来提高人脸特征的区分力(discriminative power)。\n\n步骤包括如下几点：\n\n\n对人脸特征和最后的全连接层的参数做归一化操作，在进行点积操作。这里等同于他们的cosine距离。\n\n\n通过$\\arccos(\\cdot)$来计算特征$x_i$和$W_j$ 的之间的角度$\\theta_{yi}$。这里$W_j$可以看做是第$j$个类的类心。\n\n\n对$\\theta$加上一个marge m后，计算$\\cos(\\theta + m)$。\n\n\n对每一个逻辑单元进行上述相同的计算。随后，用一个scale s对求得的添加了margin的cosine值进行缩放。\n\n\n接下来的操作和普通的softmax一样。\n\n\nProposed Approach\n原始的softmax如下：\n$$\nL_{1}=-\\frac{1}{N} \\sum_{i=1}^{N} \\log \\frac{e^{W_{y_{i}}^{T} x_{i}+b_{y_{i}}}}{\\sum_{j=1}^{n} e^{W_{j}^{T} x_{i}+b_{j}}}\n$$\n偏置项置零，$W、x$进行$l_2$归一化处理，增加scale变量s， 有：\n$$\nL_{2}=-\\frac{1}{N} \\sum_{i=1}^{N} \\log \\frac{e^{s \\cos \\theta_{y_{i}}}}\n{e^{s \\cos \\theta_{y_{i}}}+\\sum_{j=1, j \\neq y_{i}}^{n} e^{s \\cos \\theta_{j}}}\n$$\n添加一个margin m来增加类内的compactness和类间的discrepancy：\n$$\nL_{3}=-\\frac{1}{N} \\sum_{i=1}^{N} \\log \\frac{e^{s\\left(\\cos \\left(\\theta_{y_{i}}+m\\right)\\right)}}{e^{s\\left(\\cos \\left(\\theta_{y_{i}}+m\\right)\\right)}+\\sum_{j=1, j \\neq y_{i}}^{n} e^{s \\cos \\theta_{j}}}\n$$\n通过对二维特征的对比，可以明显的看到差别：\n\nComparison\n在已有的工作中，有几个相似的工作都是通过对softmax添加margin来进行的。这里对比了一下几个：\n\nSphereFace [cvpr2017]\n$$\nL_{ang} = \\frac{1}{N} \\sum _{i} - \\log{ \\frac{||e^{x_i}|| \\cos{(m \\theta _{yi, i})}}\n{e^{||x_i|| \\cos{(m \\theta _{yi, i})}} + \\sum _{j \\ne y _i} e^{||x_i \\cos{(\\theta _{j, i})}||}}}\n$$\n\nSphereFace在角度空间进行的margin。\n\nCosFace [cvpr2018]\n\n$$\n\\begin{equation}\nL_{l m c}=\\frac{1}{N} \\sum_{i}-\\log \\frac{e^{s\\left(\\cos \\left(\\theta_{y_{i}, i}\\right)-m\\right)}}{e^{s\\left(\\cos \\left(\\theta_{y_{i}, i}\\right)-m\\right)}+\\sum_{j \\neq y_{i}} e^{s \\cos \\left(\\theta_{j, i}\\right)}}\n\\end{equation}\n$$\n​\tCosFace在cosine空间进行的margin。\n作者将这三种loss归纳在一个式子中：\n$$\n\\begin{equation}\nL_{4}=-\\frac{1}{N} \\sum_{i=1}^{N} \\log \\frac{e^{s\\left(\\cos \\left(m_{1} \\theta_{y}+m_{2}\\right)-m_{3}\\right)}}{e^{s\\left(\\cos \\left(m_{1} \\theta_{y}+m_{2}\\right)-m_{3}\\right)}+\\sum_{j=1, j \\neq y_{i}}^{n} e^{s \\cos \\theta_{j}}}\n\\end{equation}\n$$\n\n同时，作者还提出了集中变种方案，从不同的角度来诠释&quot;减小类内差异和增大类间差异&quot;：\n\n\nIntra-Loss\n$$\nL_{5}=L_{2}+\\frac{1}{\\pi N} \\sum_{i=1}^{N} \\theta_{y_{i}}\n$$\n\n\nInter-Loss\n$$\n\\begin{equation}\nL_{6}=L_{2}-\\frac{1}{\\pi N(n-1)} \\sum_{i=1}^{N} \\sum_{j=1, j \\neq y_{i}}^{n} \\arccos \\left(W_{y_{i}}^{T} W_{j}\\right)\n\\end{equation}\n$$\n\n\nTriplet-Loss\n$$\n\\begin{equation}\n\\arccos \\left(x_{i}^{p o s} x_{i}\\right)+m \\leq \\arccos \\left(x_{i}^{n e g} x_{i}\\right)\n\\end{equation}\n$$\n\n\nExperiments\n对比了大量的数据集：\n\n一些实验设置如下：\n\n$112\\times112$ 对齐后的人脸\nbackbone为 ResNet50和ResNet100\n卷积之后的结构为&quot;BN-Dropout-FC-BN&quot;\n512D face feature\ns=64\nm=0.5\nBatchsize = 512\n在Celeab中，lr=0.1，lr/10@20k @28k epoch， 总共迭代32K次\n在MS1MV2中，lr/10 @100k, @160k\nmomentum = 0.9， weight-decay = 5e-4\n测试和训练集中没有重合的identity\n\n实验对比非常详尽，这里不做过多的介绍，可以参考原文。\nParallel Acceleration\n论文提到了，当identity数量很大时（millions of identites），W可能会超过GPU的显存大小，这时候，可以运用并行加速策略。[A distributed training solution for face recognition]\n对特征x和全连接层参数w都有进行并行计算。作者在8块1080ti(11GB)上，使用ResNet50， batchsize 为8*64，特征维度为512，float 32的情况下，每秒钟能够跑800个sample。\n\n\n获得特征x\n对于每一个batch中的特征，是分别从8块GPU中聚合得到的，获得 feature matrix\n\n\n\n计算softmax score\n$score = xW$\n将feature matrix复制到每一块GPU中，并行的sub score，(512个feature * 1M/8 identities)\n\n\n\n获得dW\n$dW = x^T dscore $\n在每一块GPU中，对feature matrix进行转置，并行的乘每一个sub score的梯度。得到W的梯度\n\n\n\n获得dx\n$dx = dscoreW^T$\n在每一块GPU中，对sub matrix进行转置，乘以每一个subscore的梯度，将8块GPU产生的梯度加起来，得到x的梯度\n\n\n\n","tags":["face recognition"]},{"title":"Unsupervised Deep Hashing With Adaptive Feature Learning for Image Retrieval","url":"/article/Unsupervised%20Deep%20Hashing%20With%20Adaptive%20Feature%20Learning%20for%20Image%20Retrieval/","content":"Unsupervised Deep Hashing With Adaptive Feature Learning for Image Retrieval\nNotations:\n$I= \\lbrace I_{1}, I_{2}, \\ldots, I_{n} \\rbrace $ : 所有的图像集合\n$\\mathbf{X}=\\left[\\mathbf{x}{1}, \\mathbf{x}{2}, \\ldots, \\mathbf{x}{n}\\right] \\in \\mathbf{R}^{d \\times n}$ : 全局特征，每一列表示一个图像。\n使用$k$ 个哈希函数 $h= \\lbrace h{1}, h_{2}, \\cdots, h_{k} \\rbrace $ 来产生k-bit的哈希码 $\\mathbf{B}=\\left[\\mathbf{b}{1}, \\mathbf{b}{2}, \\cdots, \\mathbf{b}{n}\\right] \\in {+1,-1}^{k \\times n}$\n$F(\\cdot)$ 为前向传播： $\\mathbf{b}{i}=h\\left(I_{i}\\right)=\\operatorname{sgn}\\left(F\\left(I_{i} ; \\mathbf{W}\\right)\\right)$\n产生伪标签\n对sample使用k-means聚类，生成k个类别（pseudo-class）， 每个类别就对应为自标签信息。\n相似度矩阵$\\mathbf{S} \\in{1,0}^{n \\times n}$ ，如果$\\bf{x_i}, \\bf{x_j} $ 属于同一个类，$S_{i,j} =1 $。\n在很多图像数据中，单一的标签不能够很好的表达出多样的图像属性。这将导致类内的差异大，来自两个不同类的样本可能距离很近。\n对于任意一个样本，如果它到它的类心的距离大于一个设定的阈值，那么他就被视为边界样本（Edge Sample）边界矩阵$\\mathbf{E}$, 当$\\bf{x_i} $或者$\\bf{x_j}$是边界点时，$E_{ij} = 1$  否则为0。\n属于不同类的两个样本之间的汉明距离应该尽可能的大，这样的话，考虑最大化他的似然函数。\n先定义他的条件概率：\n$$\np\\left(S_{i j} | \\mathbf{b}{i}, \\mathbf{b}{j}\\right)= \\lbrace \\begin{array}{ll}{\\sigma\\left(\\Theta_{i j}\\right)} &amp; {S_{i j}=1} \\ {1-\\sigma\\left(\\Theta_{i j}\\right)} &amp; {S_{i j}=0}\\end{array}\\right.\n$$\n其中，$\\sigma(\\cdot)$ 为sigmoid函数，$\\Theta_{i j}=\\frac{1}{2} \\mathbf{b}{i}^{\\mathrm{T}} \\mathbf{b}{j}$ 可以表达之间的距离。\n论文将所有的edge sample都做抛弃处理，这样一来，似然函数就表现为：\n$$\n-\\sum_{S_{i j}=0 \\atop E_{i j}=0} \\log p\\left(S_{i j} | \\mathbf{b}{i}, \\mathbf{b}{j}\\right)=-\\sum_{S_{i j}=0 \\atop E_{i j}=0}\\left(S_{i j} \\Theta_{i j}-\\log \\left(1+e^{\\Theta_{i j}}\\right)\\right)\n$$\n属于同一个类的两个样本之间的汉明距离应该尽可能的小，这样的话，\n$$\n\\operatorname{Sim}{i j}=\\tanh \\left(\\alpha\\left(\\mathbf{x}{i}^{\\mathrm{T}} \\mathbf{x}{j}-\\beta\\right)\\right)\n\\\n\\min \\left|\\operatorname{Sim}-\\frac{1}{k} \\mathbf{B}^{\\mathrm{T}} \\mathbf{B}\\right|{F}^{2}\n$$\n这里 $Sim_{ij}$ 表示通过样本$\\bf{x_i}$和$\\bf{x_j}$的距离在汉明空间的投影。由于X经过了归一化操作，因此，$\\bf{x_i}^T\\bf{x_j}$ 表示的是这两个样本之间的余弦距离，这里到特征空间和汉明空间的差异，使用过了$\\alpha, \\beta​$ 进行了调节，并且使用了tanh，使用tanh是考虑到，即使是两个非常相似的图像，他们之间特征的汉明距离也不一定接近于1，tanh能够使得当一个数超过一定阈值时非常的接近1.\n所以，总体的目标函数为：\n$$\n\\begin{aligned} \\min {\\mathbf{B}} &amp;-\\gamma{0} \\sum_{S_{i j}=0 \\ E_{ij}=0}\\left(-\\log \\left(1+e^{\\Theta_{i j}}\\right)\\right) \\ &amp;+\\gamma_{1} \\sum_{S_{i j}=1}\\left|\\tanh \\left(\\alpha\\left(\\mathbf{x}{i}^{\\mathrm{T}} \\mathbf{x}{j}-\\beta\\right)\\right)-\\frac{1}{k} \\mathbf{b}{i}^{\\mathrm{T}} \\mathbf{b}{j}\\right|_{2}^{2} \\end{aligned}\n$$\n可适应的特征学习\n上述的$\\bf{x}$指的是handcraft feature。handcraft feature通常都是局部信息，接下来作者试图通过局部信息来生成全局信息。\n这里主要考虑到两点：\n\n对于任何两个相似的sample，他们学习到的全局特征之间的距离要小于原始图像特征的距离一个阈值\n对于两个不相似的sample，他们之间的cosine distance要小于一个阈值\n学习到的全局特征要更适合用来学习哈希码\n\n综合以上三点，作者定义了如下的损失函数：\n$$\nL=\\gamma_{2} \\sum_{S_{i j}=1}|\\max ( |f\\left(I_{i}\\right)^{\\mathrm{T}} f\\left(I_{j}\\right)-\\mathbf{x}{\\mathrm{i}}^{\\mathrm{T}} \\mathbf{x}{\\mathrm{j}}-\\epsilon_{1}, 0)|{2}^{2}\n\\\n+\\gamma{3} \\sum_{S_{i j}=0 \\atop E_{i j}=0}\\left|\\max \\left(f\\left(I_{i}\\right)^{\\mathrm{T}} f\\left(I_{j}\\right)-\\epsilon_{2}, 0\\right)\\right|_{2}^{2}\n$$\n其中，$f(I)$指学到的global feature\n优化\n总的目标函数：\n$$\n\\min {B}-\\gamma{0} \\sum_{S_{i j}=0 \\atop E_{i j}=0}\\left(-\\log \\left(1+e^{\\Theta_{i j}}\\right)\\right)+L\n+\\gamma_{1} \\sum_{S_{ij}=1}\\left|\\tanh \\left(\\alpha\\left(f\\left(I_{i}\\right)^{\\mathrm{T}} f\\left(I_{j}\\right)-\\beta\\right)\\right)-\\frac{1}{k} \\mathbf{b}{\\mathbf{i}}^{\\mathrm{T}} \\mathbf{b}{\\mathbf{j}}\\right|{2}^{2}\n\\\n\\text { s.t. } &amp; \\quad \\mathbf{B} \\in{+1,-1}^{k \\times n}\n$$\n考虑到B难以直接优化，作者就引入了U来优化，这样：\n$$\n\\begin{align}\n\\min {\\mathbf{B}, \\alpha, \\beta} &amp; - \\gamma{0}  \\sum{S_{i j}=0 \\atop E_{i j}=0}\\left(-\\log \\left(1+e^{\\Psi_{i j}}\\right)\\right) \\\n&amp;+\\eta\\sum_{i=1}^{n}\\left|\\mathbf{b}{i}-\\mathbf{u}{i}\\right|{2}^{2}\\\n&amp; + \\gamma{1} \\sum_{S_{i j}=1}\\left|\\tanh \\left(\\alpha\\left(f\\left(I_{i}\\right)^{\\mathrm{T}} f\\left(I_{j}\\right)-\\beta\\right)\\right)-\\frac{1}{k} \\mathbf{u}{i}^{\\mathrm{T}} \\mathbf{u}{j}\\right|{2}^{2}\\\n&amp; +\\gamma{2} \\sum_{S_{i j}=1}|\\max ( |f\\left(I_{i}\\right)^{\\mathrm{T}} f\\left(I_{j}\\right)-\\mathbf{x}{i}^{\\mathrm{T}} \\mathbf{x}{j}-\\epsilon_{1}, 0)|{2}^{2}\\\n&amp; +\\gamma{3} \\sum_{S_{i j}=0 \\atop E_{i j}=0}\\left|\\max \\left(f\\left(I_{i}\\right)^{\\mathrm{T}} f\\left(I_{j}\\right)-\\epsilon_{2}, 0\\right)\\right|{2}^{2}\n\\\n\\text { s.t. } &amp;\\quad \\mathbf{U} \\in \\mathbf{R}^{k \\times n}, \\mathbf{U}=F(I ; \\mathbf{W})\n\\end{align}\n$$\n其中， $\\mathbf{\\Psi}{i j}=\\frac{1}{2} \\mathbf{u}{i}^{\\mathrm{T}} \\mathbf{u}{j}$ ，相当于是吧之前的所有的B都用U来替代了，然后U是网络的输出。\n总体来说考虑的是几点：\n\n相似图像之间，网络输出的类哈希码\n\n\n","tags":["hashing"]},{"title":"Transformer","url":"/NLP/Transformer/","content":"Attention Is All Your Need\n\nWhat is Transformer？\nTransformer中抛弃了传统的CNN和RNN，由且仅由self-Attenion和Feed Forward Neural Network组成。\nWhy Transformer？\n一些序列的模型（RNN， LSTM，GRU等），他们的计算都是一个线性的计算，即，第$t$时刻的的计算依赖于$t-1$时刻。限制了并行能力。同时，存在一些长期依赖的信息丢失问题。\nTransformer并不是一个序列模型，因此能够并行计算。同时序列中任意两个位置的距离被缩小成了一个常量。\nWhat is the construction of Transformer?\nTransformer的basic block是一个Encoder-Decoder结构：\n\n论文中，整个模型是由6个这样的basic block组成：\n\nEncoder和Decoder的结构又是怎样的？\nEncoder由两部分组成：\n\n\nSelf-Attention\n可以得到一个加权的特征向量$Z$:\n$$\nZ = \\operatorname{Attention}(Q, K, V)=\\operatorname{softmax}\\left(\\frac{Q K^{T}}{\\sqrt{d_{k}}}\\right) V\n$$\n\n\nFeed Forward Neural Network\n两层的全联接层：\n$$\n\\operatorname{FFN}(Z)=\\max \\left(0, Z W_{1}+b_{1}\\right) W_{2}+b_{2}\n$$\n\n\nDecoder包含三部分：\n\n\nSelf-Attention\n这个self-Attention可以理解为&quot;当前的翻译和已经翻译的内容之间的关系&quot;\n\n\nEncoder-Decoder Attention\n可以理解为当前翻译和编码的特征向量的关系\n\n\nFeed Forward Neural Network\n\n\n\nTransformer的输入是什么？\n通过word2vector将输入的语聊转换为特征向量。论文中是512维的向量$d_{\\text {model}}=512$。\nSelf-Attention是什么？\nSelf-Attention的核心是维输入向量的每一个单词，学习一个权重。\n举个🌰：\nThe animal didn&#x27;t cross the street because it was too tired\n中，it到底代表的是什么呢？\n通过Self-Attention，我们就能够通过it和其他单词间的权重，来进行判断。\n在Self-Attention中，每一个输入的词向量$x \\in \\mathbf{R}^{512}$，能够得到三个不同的向量：$q$、$k$ 和 $v \\in \\mathbf{R}^{64}$。这三个向量的获得，是通过三个不同的矩阵：$W^{Q}$、$W^{K}$ 和 $W^{V} \\in \\mathbf{R}^{512 \\times 64}$ 获得的。$q$ 代表着 Query，$k$ 代表着 key，$v$ 代表着 value。\n整个Self-Attention的计算如下：\n\n\n将输入的词向量$x$和矩阵$W^{Q}$、$W^{K}$ 和 $W^{V}$ 相乘，得到对应的$q$、$k$ 和 $v$。\n\n\n计算$s = qk$ （query和key的乘）\n\n\n对$s$进行归一化：$s = s/ \\sqrt{d_k}$, 这里的$d_k$ 指的是$k$ 的维度，这里$d_k$ 就是64，那么$s = s/8$\n\n\n对归一化之后的$s$进行softmax激活。\n\n\n随后，将4得到的数值乘以向量$v$，得到加权的输入向量的得分。\n\n\n$z = \\sum{v}$\n\n\n\n除此之外，self-attention还包含有residual short connection，来是的网络的优化更稳定。\nMulti-Head Attention\n就是将Self-Attention进行堆叠，每一个输入向量$x$会被输入到$h$个不同的self-attention模块中。将得到的加权向量concate后，进行一个全联接操作降维。\n\n位置编码\n\n输入的词向量，并没有保留他的位置信息。对于位置的编码，一般有两种做法，一种是根据数据学习，另外一种是自己设计一种规则来编码。\n这里，作者设计了一种位置编码：\n$$\n\\begin{array}{c}\nP E(\\text {pos}, 2 i)=\\sin \\left(\\frac{p o s}{10000^{\\frac{2 i}{d_{\\text {madd} l}}}}\\right) \\ \\\nP E(\\text {pos}, 2 i+1)=\\cos \\left(\\frac{p o s}{10000^{\\frac{2 i}{d_{\\text {modd} l}}}}\\right)\n\\end{array}\n$$\n作者这么设计的原因是考虑到在NLP任务重，除了单词的绝对位置，单词的相对位置也非常重要。\n","categories":["NLP"]},{"title":"Deepface: Closing the gap to human-level performance in face verification","url":"/article/face%20recognition/","content":"#Deepface: Closing the gap to human-level performance in face verification\nNaive-deep face recognition: Touching the limit of lfw benchmark or not?\nThe do’s and don’ts for cnn-based face verification\nL2-constrained softmax loss for discriminative face verification,\nAdditive margin softmax for face verification\n总的来说，face recognition主要需要解决的问题是如何在有限的subject数据中，学习到具有泛化能力的feature template。\n常用的损失设计中包含softmax，pairwise，triplet损失，其中：\nsoftmax被很多研究者认为，不能很好地泛化到unseen subject。这是因为，softmax损失虽然能够学习到增大类间差异的特征，但是不一定会降低内类差异。\npairwise：100，101\npairwise+classification：124 125 126\ntriplet： 102\ntriplet通常会比较慢，解决的方法包括，将一些hard sample抽取出来 102\n同时，还有人提出，先使用softmax训练，在使用triplet来对bottleneck feature进行调整：11，129，130\ntriplet的变体还包括使用点积而不是欧氏距离。\n还有人提出概率式三元组损失131，132\n还有中心损失(centre loss)，中心损失的目标是最小化瓶颈特征与它们对应类别的中心之间的距离。通过使用 softmax 损失和中心损失进行联合训练\n范围损失（range loss）134这是为改善使用不平衡数据集的训练而提出的。范围损失有两个组件。类内的损失组件是最小化同一类样本之间的 k-最大距离，而类间的损失组件是最大化每个训练批中最近的两个类中心之间的距离\n一种已被证明可以增加瓶颈特征的判别能力的方法是特征归一化 [115,118]。比如，[115] 提出归一化特征以具有单位 L2 范数，[118] 提出归一化特征以具有零均值和单位方差。一个成功的方法已经在 softmax 损失中每类之间的决策边界中引入了一个余量 [135]。\n","tags":["face"]},{"title":"[Hexo] Theme HuWeihuang","url":"/article/hexo-theme-huweihuang/","content":"\nThis HuWeihuang theme created by HuWeihuang modified from the original Porter YuHsuan\n\nLive Demo\nHu Weihuang Blog : www.huweihuang.com\n\nInstall Hexo\nInstall Node.js  and Git\n#For Macbrew install nodebrew install git\nInstall hexo\nnpm install hexo-cli -g#For more:https://hexo.io/zh-cn/index.html\nTheme Usage\nInit\n\ngit clone https://github.com/huweihuang/hexo-theme-huweihuang.git ./hexo-huweihuangcd hexo-huweihuangnpm install\nModify\n\nModify _config.yml file with your own info.\nEspecially the section:\nDeployment\nReplace to your own repo!\ndeploy:  type: git  repo: https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;  branch: &lt;your-branch&gt;\nSidebar settings\nCopy your avatar image to &lt;root&gt;/img/ and modify the _config.yml:\nsidebar: true    # whether or not using Sidebar.sidebar-about-description: &quot;&lt;your description&gt;&quot;sidebar-avatar: img/&lt;your avatar path&gt;\nand activate your personal widget you like\nwidgets:         # here are widget you can use, you can comment out- featured-tags- short-about- recent-posts- friends-blog- archive- category\nif you want to add sidebar widget, please add at layout/_widget.\nSignature Setup\nCopy your signature image to &lt;root&gt;/img/signature and modify the _config.yml:\nsignature: true   # show signaturesignature-img: img/signature/&lt;your-signature-ID&gt;\nGo to top icon Setup\nMy icon is using iron man, you can change to your own icon at css/image.\nPost tag\nYou can decide to show post tags or not.\nhome_posts_tag: true\n\nMarkdown render\nMy markdown render engine plugin is hexo-renderer-markdown-it.\n# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown:  render:    html: true    xhtmlOut: false    breaks: true    linkify: true    typographer: true    quotes: &#x27;“”‘’&#x27;\nand if you want to change the header anchor ‘ℬ’, you can go to layout/post.ejs to change it.\nasync(&quot;https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js&quot;,function()&#123;        anchors.options = &#123;          visible: &#x27;hover&#x27;,          placement: &#x27;left&#x27;,          icon: ℬ // this is the header anchor &quot;unicode&quot; icon        &#125;;\nHexo Basics\n\nSome hexo command:\nhexo new post &quot;&lt;post name&gt;&quot; # you can change post to another layout if you wanthexo clean &amp;&amp; hexo generate # generate the static filehexo server # run hexo in local environmenthexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\nHave fun ^_^\n\n\n\n\nPlease Star this Project if you like it! Follow would also be appreciated!\nPeace!\n","tags":["Hexo"]},{"title":"同学的面试题","url":"/%E9%9D%A2%E8%AF%95/frinds-interveiw/","content":"今天两个滚哥和鸟哥同一天面试，回来后总结了两个人的面试题。在这里记录一下：\n今日头条·大数据研发\n\n\n\n一面\n\n有序数组A=[1,3,4,6,7,9,11,15,16,17]经过一次旋转变换为A’[9,11,15,16,17,1,3,4,6,7],旋转位置未知，给定数组A和一个数x，在A’中查找x\nJava中的抽象类和接口的定议\n二叉树如何转换成平衡二叉树\nHash表冲突处理的方法 链表，顺移\n内存栈空间和堆空间的区别函数参数，局部变是，malloc\n缓存更新LRU算法需要如何实现(数据结构) 链表队列\n项目相关\n\n\n\n二面\n\n\n给定有序数组A=[1,3,4,6,7,9,11,15,16,17]和一个数m,寻找A中元素之和等于m的两个元素，返回下标 注意边界条件\n\n\nJava语言finalize()方法，final关键字，finally关键字区别\n\n\n机器学习算法\n​\n\n\n\n\n京东金融·自然语言处理算法\n\n\n编写爬虫的时候，为什么要使用Scrapy框架，有什么好处？\n使用Scrapy框架的爬虫流程是这样的，一般的爬虫流程是怎样的？\n分词、词性标注、依存句法分析的算法原理是怎样的？\n简述一下HMM\n简述一下LDA\n介绍一下传统的分类机器学习算法\n感知机学习过程中参数的更新公式是怎样的？\n实现的最长的C语言程序有多少长？\nSpark中的Map-Reduce的具体过程是怎样的？\n\n","categories":["面试"]},{"title":"image读取&转换","url":"/notes/image%E2%88%82%C2%A1%C2%BB%C2%B0%E2%97%8A%C2%A2%E2%80%9C%E2%80%9A%C2%A0%C2%AC%C5%93%C3%93/","content":"1. picke 读取数据\n许多数据集是使用pickle进行序列化后进行保存的。因此，在还原为图片的时候，使用pickel进行还原：\n import pickelwith open(file, &quot;rb&quot;) as fo:    data = pickel.load(fo, encoding=&quot;bytes&quot;)\n这里需要注意的是，python3中有encoding参数，而python2中并没有。\n在图像领域，一般通过pickle保存读取之后的数据为numpy.narray对象，size为[N, L]。N为总共的图片数量，L为每张图片的像素个数。L = C * W * L\n对于读取到的data，需要将其reshape成 W*L*C, 假设图片为 3 * 32 * 32 的大小\ndata = data.reshape(len(data), 3, 32, 32)\n2.1 numpy 画出图像\n如果是想要通过matplotlib.pylot中的 plt.imshow()对图像进行展示的话，需要将 C * W * H 转换为 W * H * C\ndata = data.transpose((0, 2, 3, 1))plt.imshow(data[0])\n同样需要注意的一点，imshow在进行图片的显示时，会自动根据数据的类型进行操作，如果numpy中为int的话，显示的范围是0-255， 如果是float的话，范围是0-1，如果data中的数据实际范围是0-255， 但是数据类型是float的话，需要将float转换为int:\ndata.astype(int)\n2.2 通过pytorch进行数据处理\n使用pytorch处理自定义的数据，需要从写torch.utils.data中的Dataset, 并使用DataLoader进行load。自定义Dataset时，需要重写__getItem__,__len__\nclass theDataset(Dataset):    def __init__(self, transform, train ):        super(Dataset, self).__init__()        self.transform = transform        self.train = train        if self.train:            self.train_x, self.train_y = get_data(True)# 通过get_data得到的数据size为 N*L            self.train_x = self.train_x.reshape((len( self.train_x), 3, 32, 32 )) # reshape成 N*C*W*H            self.train_y = self.train_y.reshape(len(self.train_y), 1)            self.train_x = self.train_x.transpose((0, 2, 3, 1))# 这里需要进一步转换为 N* W*H*C, 因为之后调用transform的时候，ToTensor会将N*W*H*C自动转换为N*C*W*H,如果这里不转换，之后的维度将会出问题        else:            self.test_x, self.test_y = get_data(False)            self.test_x = self.test_x.reshape((self.test_x.size(0), 3, 32, 32))            self.test_x = self.test_x.transpose((0, 2, 3, 1))    def __getitem__(self, index):        if self.train:            imgs, labels = self.train_x[index], self.train_y[index]        else:            imgs, labels = self.test_x[index], self.test_y[index]        if self.transform is not None:            imgs = self.transform(imgs)# 这里会将原来 N*W*H*C转换为N*C*W*H            labels = torch.from_numpy(labels).long()        return imgs, labels    def __len__(self):        if self.train:            return len(self.train_x)        else:            return len(self.test_x)\n需要注意的是，ToTensor会进行维度的变换，所以在reshape之后，需要transpose进行维度的变换。\n","categories":["notes"]},{"title":"Java notes (continuos updating)","url":"/java/java-notes/","content":"java notes\n\n\nJava丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。\n\n\nJava语言不使用指针，而是引用。并提供了自动的废料收集。\n\n\nJava语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。\n\n\n在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。\n\n\nJava的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。\n\n\nJava编译器是用Java实现的，Java的运行环境是用ANSI C实现的。\n\n\nJava平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。\n\n\n线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。\n\n\n代码风格\n\n类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。\n方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。\n源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。\n主方法入口：所有的Java 程序由**public static void main(String []args)**方法开始执行。\n\n\n\n所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始\n\n\n合法标识符举例：age、$salary、_value、__1_value\n\n\n非法标识符举例：123abc、-salary\n\n\n数组是储存在堆上的对象，可以保存多个同类型变量。\n\n\nJava 对象和类\n\n类是对象的模板，对象是类的实例。\n局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。局部变量是在栈上分配的。局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。访问修饰符不能用于局部变量；\n成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；堆中存储。\n类变量、静态变量：类变量也声明在类中，方法体之外，但必须声明为static类型。无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。静态变量在程序开始时创建，在程序结束时销毁。大多数静态变量声明为public类型。\n**构造方法：**构造方法的名称必须与类同名，一个类可以有多个构造方法。\n声明：声明一个对象，包括对象名称和对象类型。\n实例化：使用关键字new来创建一个对象。\n初始化：使用new创建对象时，会调用构造方法初始化对象。\n如果一个类定义在某个包中，那么package语句应该在源文件的首行。\n如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。\n\n\n\nJava包\n\n包主要用来对类和接口进行分类。\n\n\n\n数据类型\n\n\n内置数据类型\n\n**byte：**byte 数据类型是8位、有符号的，以二进制补码表示的整数\n\n最小值是 -128（-2^7）；\n最大值是 127（2^7-1）；\n默认值是 0；\nbyte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n例子：byte a = 100，byte b = -50。\n\n\nshort：\n\nshort 数据类型是 16 位、有符号的以二进制补码表示的整数\n最小值是 -32768（-2^15）；Short.MIN_VALUE\n最大值是 32767（2^15 - 1）；\nShort 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n默认值是 0；\n例子：short s = 1000，short r = -20000\n\n\nint：\n\nint 数据类型是32位、有符号的以二进制补码表示的整数；\n最小值是 -2,147,483,648（-2^31）；Integer.MIN_VALUE\n最大值是 2,147,483,647（2^31 - 1）；\n一般地整型变量默认为 int 类型；\n默认值是 0 ；\n例子：int a = 100000, int b = -200000。\n\n\nLong\n\nlong 数据类型是 64 位、有符号的以二进制补码表示的整数；\n最小值是 -9,223,372,036,854,775,808（-2^63）；\n最大值是 9,223,372,036,854,775,807（2^63 -1）；\n这种类型主要使用在需要比较大整数的系统上；\n默认值是 0L；\n例子： long a = 100000L，Long b = -200000L。\n&quot;L&quot;理论上不分大小写，但是若写成&quot;l&quot;容易与数字&quot;1&quot;混淆，不容易分辩。所以最好大写。\n\n\nfloat\n\nfloat 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\nfloat 在储存大型浮点数组的时候可节省内存空间；\n默认值是 0.0f；\n浮点数不能用来表示精确的值，如货币；\n例子：float f1 = 234.5f。\n\n\ndouble\n\ndouble 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；\n浮点数的默认类型为double类型；\ndouble类型同样不能表示精确的值，如货币；\n默认值是 0.0d；\n例子：double d1 = 123.4。\n\n\nboolean\n\nboolean数据类型表示一位的信息；\n只有两个取值：true 和 false；\n这种类型只作为一种标志来记录 true/false 情况；\n默认值是 false；\n例子：boolean one = true。\n\n\nchar\n\nchar类型是一个单一的 16 位 Unicode 字符；\n最小值是 \\u0000（即为0）；Character.MIN_SIZE\n最大值是 \\uffff（即为65,535）；\nchar 数据类型可以储存任何字符；\n例子：char letter = ‘A’;。\n\n\n\n\n\n引用变量\n\n指向对象的变量是引用变量\n对象、数组都是引用数据类型\n所有引用类型的默认值都是null\n一个引用变量可以用来引用任何与之兼容的类型。\nDog myDog = new Dog(“hey”);\n\n\n\n常量\n\n\nfinal修饰\n\n\n通常使用大写字母表示常量\n\n\nfinal double PI = 3.1415;\n\n\nint decimal = 100;\nint octal = 0144;\nint hexa =  0x64;\n* 自动类型转换  * ```java    byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double\n\n\n\n\n浮点数到整数的转换是通过舍弃小数得到 (int) -45.6f == -45\n\n\n\n\n\n\n访问控制修饰符\n\n\ndefault (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\n\n\nprivate : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\n\n\npublic : 对所有类可见。使用对象：类、接口、变量、方法\n\n\nprotected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。\n\n\n\n修饰符\n当前类\n同一包内\n子孙类\n其他包\n\n\n\n\npublic\nY\nY\nY\nY\n\n\nprotected\nY\nY\nY\nN\n\n\ndefault\nY\nY\nN\nN\n\n\nprivate\nY\nN\nN\nN\n\n\n\n\n\n父类中声明为 public 的方法在子类中也必须为 public。\n\n\n父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。\n\n\n父类中声明为 private 的方法，不能够被继承。\n\n\nfinal 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。类中的 final 方法可以被子类继承，但是不能被子类修改。\n\n\nabstract 修饰符，用来创建抽象类和抽象方法，抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类。抽象方法不能被声明成 final 和 static。\npublic abstract class SuperClass&#123;    abstract void m(); //抽象方法&#125; class SubClass extends SuperClass&#123;     //实现抽象方法      void m()&#123;          .........      &#125;&#125;\n​\n\n\nsynchronized 和 volatile 修饰符，主要用于线程的编程。synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。\n\n\ntransient：\n\n序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。\n\n\n\nvolatile：\n\nvolatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。\n\npublic class MyRunnalbe implements Runnable &#123;    private volatile boolean active;    public void run()&#123;        while(active)&#123;            // do something        &#125;    &#125;    public void stop()&#123;        active = false;    &#125;&#125;// 这样的话，当两个线程一个调用run()方法时，一个调用stop时// 在没有被volatile修饰的情况下，第一个run不会终止// 但是在加上volatile修饰后，有一个调用stop，其他线程都会停止\n\n\ntransient\n当对象被序列化时（写入字节序列到目标文件）时，transient阻止实例中那些用此关键字声明的变量持久化；当对象被反序列化时（从源文件读取字节序列进行重构），这样的实例变量值不会被持久化和恢复。\nimport java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;//定义一个需要序列化的类class People implements Serializable&#123;    String name; //姓名    transient Integer age; //年龄    public People(String name,int age)&#123;        this.name = name;        this.age = age;    &#125;    public String toString()&#123;        return &quot;姓名 = &quot;+name+&quot; ,年龄 = &quot;+age;    &#125;&#125;public class TransientPeople &#123;    public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;        People a = new People(&quot;李雷&quot;,30);        System.out.println(a); //打印对象的值        ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(&quot;d://people.txt&quot;));        os.writeObject(a);//写入文件(序列化)        os.close();        ObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;d://people.txt&quot;));        a = (People)is.readObject();//将文件数据转换为对象（反序列化）        System.out.println(a); // 年龄 数据未定义        is.close();    &#125;&#125;\n运行结果如下：\n姓名 = 李雷 ,年龄 = 30姓名 = 李雷 ,年龄 = null\nvolatile\nvolatile可以用在任何变量前面，但不能用于final变量前面，因为final型的变量是禁止修改的。\n使用的场景之一，单例模式中采用DCL双锁检测（double checked locking）机制，在多线程访问的情况下，可使用volatitle修改，保证多线程下的可见性。缺点是性能有损失，因此单线程情况下不必用此修饰符。\nclass Singleton&#123;    private volatile static Singleton instance = null;    private Singleton() &#123;    &#125;    public static Singleton getInstance() &#123;        if(instance==null) &#123;            synchronized (Singleton.class) &#123;                if(instance==null)                    instance = new Singleton();            &#125;        &#125;        return instance;    &#125;&#125;\n\n","categories":["java"]},{"title":"leecode 264 Ugly Number II","url":"/article/leecode-solution-264-Ugly-Number-II/","content":"Write a program to find the n-th ugly number.\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.\nNote that 1 is typically treated as an ugly number, and n does not exceed 1690.\n\nclass Solution &#123;    public int nthUglyNumber(int n) &#123;        int dp[] = new int[n];        dp[0] = 1;                int index2 = 0;        int index3 = 0;        int index5 = 0;                int fact2 = 2;        int fact3 = 3;        int fact5 = 5;                for(int i=1; i&lt;n; i++)&#123;                        dp[i] = Math.min(Math.min(fact2, fact3), fact5);            if(dp[i] == fact2)&#123;                index2 ++;                fact2 = dp[index2] * 2;            &#125;            if(dp[i] == fact3)&#123;                index3 ++;                fact3 = dp[index3] * 3;            &#125;            if(dp[i] == fact5)&#123;                index5 ++;                fact5 = dp[index5] * 5;            &#125;        &#125;        return dp[n-1];    &#125;&#125;\n\n为每一个factor设定一个记录\n由于只能被2 3 5 整除，每次取每个factor对应的index所对应的位置相乘\n\n","tags":["leetcode"]},{"title":"leetcode","url":"/leetcode/leetcode-#-679-24-%E7%82%B9%E6%B8%B8%E6%88%8F/","content":"\n你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。\n\nclass Solution(object):    def judgePoint24(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: bool        &quot;&quot;&quot;        if not nums or len(nums) !=  4:            return False        return self.dfs(nums)        def dfs(self, nums):        if not nums:            return False        if len(nums) == 1:            if abs(nums[0]-24) &lt; 1e-7:                return True            return False        for i, m in enumerate(nums):            for j, n in enumerate(nums):                if i != j:                    t = copy.copy(nums)                    t.remove(m)                    t.remove(n)                    if self.dfs(t+[m+n]) or self.dfs(t + [m-n]) or self.dfs(t + [m*n]) or self.dfs(t + [m/(n+1e-10)]):                        return True        return False\n","categories":["leetcode"],"tags":["leetcode"]},{"url":"/article/jar%E2%88%9E%C2%B8%E2%88%91%E2%89%88%C3%B7%E2%88%9A%E2%80%98%E2%81%84hadoop%E2%88%86%CE%A9%C3%83%C2%AE%E2%89%A5%CB%86%C5%93%C3%B7%20Caused%20by%20java.util.zip.ZipException%20error%20in%20opening%20zip%20file/","content":"jar包放置在hadoop平台出现 Caused by: java.util.zip.ZipException: error in opening zip file\nat java.util.zip.ZipFile.open(Native Method)\nat java.util.zip.ZipFile.(ZipFile.java:127)\nat java.util.jar.JarFile.(JarFile.java:135)\nat java.util.jar.JarFile.(JarFile.java:72)\nat org.apache.hadoop.util.RunJar.main(RunJar.java:122)\n\n收集了网上的的个答案，可以综合为一下情况：\n1. 在命令行输入时的jar包的相对位置\n2. built环境和执行环境的JDK版本不同\n3. 在Export导出项目时要去掉被选中的.CLASSPATH\n4. 检查执行环境和本地环境中.jar文件大小是否一致，有可能是传输过程中的错误导致.jar文件破损。\n\n\nnohup hadoop jar recover.jar com.didi.basedata.util.dataquality.statistics.DataRecoveryJob 2018040400 2018040411 hive &gt;&gt; log_recover 2&gt;&amp;1 &amp;\n"},{"title":"leetcode 100 相同的树","url":"/article/leetcode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/","content":"给定两个二叉树，编写一个函数来检验它们是否相同。\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n示例 1:\n输入:\n1         1   / \\       / \\  2   3     2   3\n    [1,2,3],   [1,2,3]\n\n输出: true\n示例 2:\n输入:      \t\t\t\t\t 1         1          /           \\         2             2\n    [1,2],     [1,null,2]\n\n输出: false\n示例 3:\n输入:\n1         1  / \\       / \\ 2   1     1   2\n    [1,2,1],   [1,1,2]\n\n输出: false\n\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def isSameTree(self, p, q):        &quot;&quot;&quot;        :type p: TreeNode        :type q: TreeNode        :rtype: bool        &quot;&quot;&quot;        if not p and not q:            return True        if p and q and p.val == q.val:            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)        return False\n","tags":["leetcode","tree"]},{"title":"leetcode 102 二叉树的层次遍历","url":"/article/leetcode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/","content":"给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。\n例如:\n给定二叉树: [3,9,20,null,null,15,7],\n\t\t3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回其层次遍历结果：\n[  [3],  [9,20],  [15,7]]\n\nclass Solution(object):    def levelOrder(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[List[int]]        &quot;&quot;&quot;        if not root:            return []        ans = []        queue = []        queue.append(root)        level = 0        while queue:            n = len(queue)            for i in range(n):                t = queue.pop(0)                if level == len(ans):                    ans.append([])                ans[level].append(t.val)                if t.left:                    queue.append(t.left)                if t.right:                    queue.append(t.right)            level += 1        return ans\n","tags":["leetcode","tree"]},{"title":"leetcode 103 二叉树的锯齿形层次遍历","url":"/article/leetcode-103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/","content":"给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n例如：\n给定二叉树 [3,9,20,null,null,15,7],\n\t\t3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回锯齿形层次遍历如下：\n[  [3],  [20,9],  [15,7]]\n\n\n每一次将cur节点按从左到右的顺序加入到templist\n在添加到ans时，根据level的奇偶来决定是顺序的添加到ans[level]中还是逆序的添加到ans[level]中。\n\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def zigzagLevelOrder(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[List[int]]        &quot;&quot;&quot;        ans = []        if not root:            return ans        queue = []        level = 0        queue.append(root)        while queue:            temp = []            n = len(queue)            for i in range(n):                t = queue.pop(0)                if len(ans) == level:                    ans.append([])                if level&amp;1:                    ans[level].insert(0, t.val)                else:                    ans[level].append(t.val)                if t.left:                    temp.append(t.left)                if t.right:                    temp.append(t.right)            queue += temp            level += 1        return ans            \n","tags":["leetcode","tree"]},{"title":"leetcode 10 正则表达式匹配","url":"/article/leetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","content":"给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。\n‘.’ 匹配任意单个字符\n’*’ 匹配零个或多个前面的那一个元素\n所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。\n说明:\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。\n示例 1:\n输入:\ns = &quot;aa&quot;\np = &quot;a&quot;\n输出: false\n解释: “a” 无法匹配 “aa” 整个字符串。\n示例 2:\n输入:\ns = &quot;aa&quot;\np = &quot;a*&quot;\n输出: true\n解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。\n示例 3:\n输入:\ns = &quot;ab&quot;\np = “.&quot;\n输出: true\n解释: &quot;.” 表示可匹配零个或多个（’*’）任意字符（’.’）。\n示例 4:\n输入:\ns = &quot;aab&quot;\np = &quot;cab&quot;\n输出: true\n解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。\n示例 5:\n输入:\ns = &quot;mississippi&quot;\np = &quot;misisp*.&quot;\n输出: false\n\n这道题和 leetcode 44 通配符 II 很像，但是不同点在于，’*'在本题中匹配的是人一个前面的字符，而44中，\\* 匹配的是任意长度的字符，可以是空。\n利用动态规划和最小编辑距离的思路很像，知识需要多考虑几步。\nclass Solution(object):    def isMatch(self, s, p):        &quot;&quot;&quot;        :type s: str        :type p: str        :rtype: bool        &quot;&quot;&quot;        dp = [[False for i in range(len(s)+1)] for j in range(len(p)+1)]        dp[0][0] = True        for i in range(1, len(p)+1):            # p[i-1]是当前的p中的字符，如果当前字符为 * ，由于 *号前面需要有一个正常的字符            # 所以，需要判断i-2的位置，是否为真，如果为真的话，说明当前的dp[i][0]可以为真            if p[i-1] == &#x27;*&#x27; and dp[i-2][0]:                dp[i][0] = True        for i in range(1, len(p)+1):            for j in range(1, len(s)+1):                # 这里很简单，没有问题                if p[i-1] == &#x27;.&#x27; or p[i-1] == s[j-1]:                    dp[i][j] = dp[i-1][j-1]                # 处理当前p中的字符为*的情况。                # 当前p中为*可以考虑一下集中情况：                # 1. 当前的*匹配0个字符，也就是说，当有任意一个字符c后面接上*，例如c*，c*对应为 &quot;&quot;                # 2. c*对应一个c                # 3. c*对应多个c                elif p[i-1] == &#x27;*&#x27;:                  \t# 当*前面的字符可以匹配当前s中的字符s[j]，那么当前的状态可以有三种：                    # 1. c*对应空，及dp[i-2][j]                    # 2. c*对应&quot;c&quot;,及 dp[i-1][j-1]                    # 3. c*对应多个&#x27;c&#x27;, 及 dp[i][j-1]                    if p[i-2] == s[j-1] or p[i-2] == &#x27;.&#x27;:                        dp[i][j] = dp[i-2][j] or dp[i-1][j-1] or dp[i][j-1]                    # 如果说p[i-2],也就是*的前面一个字符不等于当前需要匹配的s中的字符s[j-1],那么                    # 只能是c*匹配 &quot;&quot;                    else:                        dp[i][j] = dp[i-2][j]        return dp[-1][-1]        ","tags":["leetcode","字符串"]},{"title":"leetcode 101 对称的二叉树","url":"/article/leetcode-101-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"给定一个二叉树，检查它是否是镜像对称的。\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n1\n\n/ \n2   2\n/ \\ / \n3  4 4  3\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n1\n\n/ \n2   2\n\\   \n3    3\n\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def isSymmetric(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        def check(a, b):            if not a and not b:                return True            if not a or not b:                return False            if a.val != b.val:                return False            return check(a.left, b.right) and check(a.right, b.left)        return check(root, root)\n\n","tags":["leetcode","树"]},{"title":"leetcode 105 从前序与中序遍历序列构造二叉树","url":"/article/leetcode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"根据一棵树的前序遍历与中序遍历构造二叉树。\n注意:\n你可以假设树中没有重复的元素。\n例如，给出\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n\t\t3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n","tags":["leetcode","tree"]},{"title":"leetcode 104 二叉树的最大深度","url":"/article/leetcode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","content":"给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\t\t3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。\n\n\n\n递归\nclass Solution(object):    def maxDepth(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        if not root:            return 0        left = self.maxDepth(root.left)        right = self.maxDepth(root.right)        return max(left, right)+1\n\n\n广度优先\nclass Solution(object):    def maxDepth(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        if not root:            return 0        queue = []        queue.append(root)        level = 0        while queue:            n = len(queue)            for i in range(n):                q = queue.pop(0)                if q.left:                    queue.append(q.left)                if q.right:                    queue.append(q.right)            level += 1        return level\n\n\n","tags":["leetcode","tree"]},{"title":"leetcode 106 从中序与后序遍历序列构造二叉树","url":"/article/leetcode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"根据一棵树的中序遍历与后序遍历构造二叉树。\n注意:\n你可以假设树中没有重复的元素。\n例如，给出\n中序遍历 inorder = [9,3,15,20,7]\n后序遍历 postorder = [9,15,7,20,3]\n返回如下的二叉树：\n\t\t3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\nclass Solution(object):    def buildTree(self, inorder, postorder):        &quot;&quot;&quot;        :type inorder: List[int]        :type postorder: List[int]        :rtype: TreeNode        &quot;&quot;&quot;        if not postorder:            return None        if len(postorder) == 1:            return TreeNode(postorder[0])                t = postorder.pop()        t_idx = inorder.index(t)        inorderLeft = inorder[:t_idx]        inorderRight = inorder[t_idx+1:]        postorderLeft = postorder[:len(inorderLeft)]        postorderRight = postorder[len(inorderLeft):]                root = TreeNode(t)        root.left = self.buildTree(inorderLeft, postorderLeft)        root.right = self.buildTree(inorderRight, postorderRight)        return root\n","tags":["leetcode","tree"]},{"title":"leetcode 107 二叉树的层次遍历 II","url":"/article/leetcode-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II/","content":"给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n例如：\n给定二叉树 [3,9,20,null,null,15,7],\n\t\t3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回其自底向上的层次遍历为：\n[\n[15,7],\n[9,20],\n[3]\n]\n\n","tags":["leetcode","tree"]},{"title":"leetcode 110 平衡二叉树","url":"/article/leetcode-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"给定一个二叉树，判断它是否是高度平衡的二叉树。\n本题中，一棵高度平衡二叉树定义为：\n一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。\n示例 1:\n给定二叉树 [3,9,20,null,null,15,7]\n\t\t3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回 true 。\n示例 2:\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n\n返回 false 。\n\n\n\n递归的寻找当前节点的左子树和右子树的高度，如果高度差为不满足平衡关系，返回-1\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def isBalanced(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        def getDepth(root):            if not root:                return 0            if not root.left and not root.right:                return 1            left = getDepth(root.left)            right = getDepth(root.right)            if left==-1 or right == -1:                return -1            elif abs(left-right) &gt; 1:                return -1            else:                return max(left, right) + 1        return getDepth(root) != -1            \n\n","tags":["leetcode","tree"]},{"title":"leetcode 111 二叉树的最小深度","url":"/article/leetcode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/","content":"给定一个二叉树，找出其最小深度。\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n说明: 叶子节点是指没有子节点的节点。\n示例:\n给定二叉树 [3,9,20,null,null,15,7],\n3\n\n/ \n9  20\n/  \n15   7\n返回它的最小深度  2.\n\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def minDepth(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        def getDepth(root, level):            if not root:                return            if not root.left and not root.right:                depth.append(level+1)             getDepth(root.left, level+1)            getDepth(root.right, level+1)                    depth = []        getDepth(root, 0)        return 0 if not depth else min(depth)    \n\nclass Solution:    def minDepth(self, root: TreeNode) -&gt; int:        if not root:            return 0        left = self.minDepth(root.left)        right = self.minDepth(root.right)        if not left:            return right + 1        if not right:            return left + 1        return min(left, right) + 1\n\nfrom collections import dequeclass Solution:    def minDepth(self, root: TreeNode) -&gt; int:        if not root:            return 0        q, depth = deque(), 1        q.append((root, depth))        while q:            node, depth = q.popleft()            if not node:                continue            if not node.left and not node.right:                break            q.append((node.left, depth+1))            q.append((node.right, depth+1))        return depth\n","tags":["leetcode","tree"]},{"title":"leetcode 112 路径总和","url":"/article/leetcode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","content":"给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n说明: 叶子节点是指没有子节点的节点。\n示例:\n给定如下二叉树，以及目标和 sum = 22，\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\n\n返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。\n\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def hasPathSum(self, root, sum):        &quot;&quot;&quot;        :type root: TreeNode        :type sum: int        :rtype: bool        &quot;&quot;&quot;        if not root:            return False        if root.val == sum and not root.left and not root.right:            return True        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)\n","tags":["leetcode","tree"]},{"title":"leetcode 113 路径总和 II","url":"/article/leetcode-113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II/","content":"给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n说明: 叶子节点是指没有子节点的节点。\n示例:\n给定如下二叉树，以及目标和 sum = 22，\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\    / \\\n    7    2  5   1\n\n返回:\n[   [5,4,11,2],   [5,8,4,5]]\n\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def pathSum(self, root, sum):        &quot;&quot;&quot;        :type root: TreeNode        :type sum: int        :rtype: List[List[int]]        &quot;&quot;&quot;        import copy        def pathSumHelper(root, sum, ans, t=[]):            if not root:                return             t.append(root.val)            if not root.left and not root.right and root.val == sum:                ans.append(copy.copy(t))            else:                 pathSumHelper(root.left, sum-root.val, ans, t)                pathSumHelper(root.right, sum-root.val, ans, t)            t.pop() # 这里如果使用t.remove(root.val)在存在相同数字的情况下会出错                ans = []        pathSumHelper(root, sum, ans)        return ans\n","tags":["leetcode","tree"]},{"title":"leetcode 114 二叉树展开为链表","url":"/article/leetcode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/","content":"给定一个二叉树，原地将它展开为链表。\n例如，给定二叉树\n\t\t1\n   / \\\n  2   5\n / \\   \\\n3   4   6\n\n将其展开为：\n1 \\  2   \\    3     \\      4       \\        5         \\          6\n\n\n\n每一次把根节点的右子树拼接在左子树的右子树上\n例如：\n\t\t1  &lt;- cur                  1   / \\\t\t\t\t\t\t\t\t\t\t\t\t  \\  2   5\t\t\t\t\t\t\t\t\t\t\t\t\t\t2  &lt;- cur / \\   \\\t\t\t    ===&gt;\t\t\t  \t/\t  \\\t\t\t\t\t\t\t===&gt; ...3   4   6\t\t\t\t\t\t\t\t\t\t\t 3\t\t  4\t\t\t / \\\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\t\t\t7   8\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t6\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t /\t\\\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t7\t\t\t8\nclass Solution(object):    def flatten(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: None Do not return anything, modify root in-place instead.        &quot;&quot;&quot;        cur = root        while cur:            if cur.left:                p = cur.left                while p.right: p = p.right                p.right = cur.right                cur.right = cur.left                cur.left = None            cur = cur.right\n\n\n依次像左遍历，并把当前节点的右子树放到列表中，当遍历到最左的叶子节点时，pop列表中最近的一个右子树，继续\nclass Solution(object):    def flatten(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: None Do not return anything, modify root in-place instead.        &quot;&quot;&quot;        pre = None        rights = []        rights.append(root)        while rights:            p = rights.pop()            while p:                if p.right:                    rights.append(p.right)                if not pre:                    pre = p                else:                    pre.right = p                    pre = pre.right                p = p.left                pre.left = None\n\n","tags":["leetcode","tree"]},{"title":"leetcode 115  Distinct Subsequences","url":"/article/leetcode-115-Distinct-Subsequences/","content":"Given a string S and a string T, count the number of distinct subsequences of S which equals T.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ACE&quot; is a subsequence of &quot;ABCDE&quot; while &quot;AEC&quot; is not).\nExample 1:\nInput: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;Output: 3Explanation:As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.(The caret symbol ^ means the chosen letters)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^\nExample 2:\nInput: S = &quot;babgbag&quot;, T = &quot;bag&quot;Output: 5Explanation:As shown below, there are 5 ways you can generate &quot;bag&quot; from S.(The caret symbol ^ means the chosen letters)babgbag^^ ^babgbag^^    ^babgbag^    ^^babgbag  ^  ^^babgbag    ^^^\n\n首先很容易想到一个遍历的算法：\npublic int numDistinct1(String s, String t) &#123;      return dfs(s, t, 0); \t&#125;  public int dfs(String s, String t, int start) &#123;      if (&quot;&quot;.equals(s)) &#123;          return 0;      &#125;      if (&quot;&quot;.equals(t)) &#123;          return 1;      &#125;      int count = 0;      for (int i=start; i&lt;s.length(); i++) &#123;          if (s.charAt(i) == t.charAt(0)) &#123;              count += dfs(s, t.substring(1), i+1);           &#125;      &#125;      return count;  &#125;\n时间复杂度上面是一个O($n^2$)\n其实还可以用动态规划来做。\ndp[i][j] 表示 t[0:i]在s[0:j]中出现的次数。那么直接返回dp[t.length()][s.length()]就可以了。\n当dp[i][j] 确定后，考虑dp[i][j+1]的情况：\n\n\n当t[i] != s[j+1]时， 当前的字符不相等，那么t[0:i] 在s[0:j+1]中出现的次数就等于它在s[0:j]中出现的次数。即 dp[i][j+1] = dp[i][j].\n\n\n当t[i] == s[j+1]时，dp[i][j+1]包含两部分，\n\n\n在s[0: j]中，t[0: i] 出现的此时，这里是t[0:i]已经出现的次数，即dp[i][j]。\n\n\n新加入的s[j+1]带来的影响。我们已知了t[0: i-1]在s[0:j]中出现的次数，那么新加入的这个s[j+1]可以和s[0: j]中任意一个t[0:i-1]组成一个新的t[0：i]，所以这里将增加dp[i-1][j]。\n即dp[i][j+1] = dp[i][j] +  dp[i-1][j]\n举个例子：\n\n\n\n\n\na\nd\na\nb\ne\nb\na\n\n\n\n\n\n1\n1\n1\n1\n1\n1\n1\n1\n\n\na\n0\n1\n1\n2\n2\n2\n2\n3\n\n\nb\n0\n0\n0\n0\n?\n\n\n\n\n\n\n在求?时， a在ada中已经出现了2次，ab在ada中出现了0次，当添加一个b时，在ada中出现的两个a都可以和b组成ab，所以一共有0+2次。\n\n\npublic int numDistinct(String s, String t) &#123;       int[][] dp = new int[t.length()+1][s.length()+1];       for (int i=0; i&lt;=t.length(); i++) &#123;           for (int j=0; j&lt;=s.length(); j++) &#123;               if (i==0) &#123;                   dp[i][j] = 1;               &#125;               else if (j == 0) &#123;                   dp[i][j] = 0;               &#125;               else if (t.charAt(i-1) == s.charAt(j-1))&#123;                   dp[i][j] = dp[i-1][j-1] + dp[i][j-1];               &#125;               else                   dp[i][j] = dp[i][j-1];           &#125;       &#125;              return dp[t.length()][s.length()];   &#125;\n有一点需要注意的是，dp[0][0] 的值，当s为空的时候，对所有的t都不会有结果，即dp[*][0]看似都应该设置为0， 但是当s[0] = t[0] 时，如果dp[0][0] 为0，那么dp[1][1]不会有值。dp[0][0]必须设置为1.\n\n\n","tags":["leetcode"]},{"title":"leetcode 108 将有序数组转换为二叉搜索树","url":"/article/leetcode-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n示例:\n给定有序数组: [-10,-3,0,5,9],\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n\n\nclass Solution(object):    def sortedArrayToBST(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: TreeNode        &quot;&quot;&quot;        if not nums:            return None        if len(nums) == 1:            return TreeNode(nums[0])        mid = len(nums)//2        left = nums[:mid]        right = nums[mid+1:]        root = TreeNode(nums[mid])        root.left = self.sortedArrayToBST(left)        root.right = self.sortedArrayToBST(right)        return root\n","tags":["leetcode","tree"]},{"title":"leetcode 109 有序链表转换二叉搜索树","url":"/article/leetcode-109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\n示例:\n给定的有序链表： [-10, -3, 0, 5, 9],\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n      0\n     / \\\n    -3   9\n   /   /\n -10  5\n\n\n# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, x):#         self.val = x#         self.next = None# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def sortedListToBST(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: TreeNode        &quot;&quot;&quot;        if not head:            return None        if not head.next:            return TreeNode(head.val)                slow = head        fast = head        prev = None        while fast and fast.next:            prev = slow            slow = slow.next            fast = fast.next.next        if prev:            prev.next = None                    root = TreeNode(slow.val)                root.left = self.sortedListToBST(head)        root.right = self.sortedListToBST(slow.next)        return root\n","tags":["leetcode","tree"]},{"title":"leetcode 118 杨辉三角","url":"/article/leetcode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/","content":"给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n示例:\n输入: 5\n输出:\n[\n[1],\n[1,1],\n[1,2,1],\n[1,3,3,1],\n[1,4,6,4,1]\n]\n\nclass Solution(object):    def generate(self, numRows):        &quot;&quot;&quot;        :type numRows: int        :rtype: List[List[int]]        &quot;&quot;&quot;        if numRows &lt;= 0:            return []        ans = [[1]]        for i in range(1, numRows):            t = []            for j in range(i+1):                if j == 0:                    t.append(1)                elif i == j :                    t.append(1)                else:                    t.append(ans[-1][j-1] + ans[-1][j])            ans.append(t)        return ans\n","tags":["leetcode","数组"]},{"title":"leetcode 117 填充每个节点的下一个右侧节点指针 II","url":"/article/leetcode-117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II/","content":"给定一个二叉树\nstruct Node {\nint val;\nNode *left;\nNode *right;\nNode *next;\n}\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n初始状态下，所有 next 指针都被设置为 NULL。\n示例：\n输入：{&quot;$id&quot;:“1”,“left”:{&quot;$id&quot;:“2”,“left”:{&quot;$id&quot;:“3”,“left”:null,“next”:null,“right”:null,“val”:4},“next”:null,“right”:{&quot;$id&quot;:“4”,“left”:null,“next”:null,“right”:null,“val”:5},“val”:2},“next”:null,“right”:{&quot;$id&quot;:“5”,“left”:null,“next”:null,“right”:{&quot;$id&quot;:“6”,“left”:null,“next”:null,“right”:null,“val”:7},“val”:3},“val”:1}\n输出：{&quot;$id&quot;:“1”,“left”:{&quot;$id&quot;:“2”,“left”:{&quot;$id&quot;:“3”,“left”:null,“next”:{&quot;$id&quot;:“4”,“left”:null,“next”:{&quot;$id&quot;:“5”,“left”:null,“next”:null,“right”:null,“val”:7},“right”:null,“val”:5},“right”:null,“val”:4},“next”:{&quot;$id&quot;:“6”,“left”:null,“next”:null,“right”:{&quot;$ref&quot;:“5”},“val”:3},“right”:{&quot;$ref&quot;:“4”},“val”:2},“next”:null,“right”:{&quot;$ref&quot;:“6”},“val”:1}\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。\n提示：\n你只能使用常量级额外空间。\n使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n&quot;&quot;&quot;# Definition for a Node.class Node(object):    def __init__(self, val, left, right, next):        self.val = val        self.left = left        self.right = right        self.next = next&quot;&quot;&quot;class Solution(object):    def connect(self, root):        &quot;&quot;&quot;        :type root: Node        :rtype: Node        &quot;&quot;&quot;        if not root:            return root        p = root        while p:            nextStart = None            prev = None            while p:                if p.left:                    if not nextStart:                        nextStart = p.left                        prev = p.left                    else:                        prev.next = p.left                        prev = prev.next                if p.right:                    if not nextStart:                        nextStart = p.right                        prev = p.right                    else:                        prev.next = p.right                        prev = prev.next                p = p.next            p = nextStart        return root        \n","tags":["leetcode","树"]},{"title":"leetcode 122 买卖股票的最佳时机 II","url":"/article/leetcode-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/","content":"给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1:\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n示例 2:\n输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n示例 3:\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n","tags":["leetcode","数组","动态规划"]},{"title":"leetcode 130 Surrounded Regions","url":"/article/leetcode-130-Surrounded-Regions/","content":"Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\nExample:\nX X X XX O O XX X O XX O X X\nAfter running your function, the board should be:\nX X X XX X X XX X X XX O X X\nExplanation:\nSurrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.\n\n可以反过来思考，所有从board四周延伸出来的O都应该保持不变，除此之外的O都要转换为X。\n这样一来，先把所有四周延伸出来的O都值为一个其他值，例如*。\n然后遍历一遍board，将所有的O变为X，所有的*变为O。\nclass Solution &#123;    public void solve(char[][] board) &#123;        if (board.length == 0 || board[0].length == 0) return ;        int m = board.length;        int n = board[0].length;        for (int i=0; i&lt;m; i++) &#123;            if (board[i][0] == &#x27;O&#x27;)                covert(board, i, 0);            if (board[i][n-1] == &#x27;O&#x27;)                covert(board, i, n-1);        &#125;        for (int j=0; j&lt;n; j++) &#123;            if (board[0][j] == &#x27;O&#x27;)                covert(board, 0, j);            if (board[m-1][j] == &#x27;O&#x27;)                covert(board, m-1, j);        &#125;                for (int i=0; i&lt;m; i++) &#123;            for (int j=0; j&lt;n; j++) &#123;                if (board[i][j] == &#x27;O&#x27;)                    board[i][j] = &#x27;X&#x27;;                if (board[i][j] == &#x27;*&#x27;)                    board[i][j] = &#x27;O&#x27;;            &#125;        &#125;    &#125;        public void covert(char[][] board, int i, int j) &#123;        board[i][j] = &#x27;*&#x27;;        if (i-1&gt;=0 &amp;&amp; board[i-1][j] == &#x27;O&#x27;)            covert(board, i-1, j);        if (i+1 &lt; board.length &amp;&amp; board[i+1][j] == &#x27;O&#x27;)            covert(board, i+1, j);        if (j-1 &gt;= 0 &amp;&amp; board[i][j-1] == &#x27;O&#x27;)            covert(board, i, j-1);        if (j+1 &lt; board[0].length &amp;&amp; board[i][j+1] == &#x27;O&#x27;)            covert(board, i, j+1);    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 133 Clone Graph","url":"/article/leetcode-133-Clone-Graph/","content":"Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.\nExample:\n\nInput:&#123;&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[&#123;&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;1&quot;&#125;,&#123;&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&#123;&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[&#123;&quot;$ref&quot;:&quot;3&quot;&#125;,&#123;&quot;$ref&quot;:&quot;1&quot;&#125;],&quot;val&quot;:4&#125;],&quot;val&quot;:3&#125;],&quot;val&quot;:2&#125;,&#123;&quot;$ref&quot;:&quot;4&quot;&#125;],&quot;val&quot;:1&#125;Explanation:Node 1&#x27;s value is 1, and it has two neighbors: Node 2 and 4.Node 2&#x27;s value is 2, and it has two neighbors: Node 1 and 3.Node 3&#x27;s value is 3, and it has two neighbors: Node 2 and 4.Node 4&#x27;s value is 4, and it has two neighbors: Node 1 and 3.\nNote:\n\nThe number of nodes will be between 1 and 100.\nThe undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph.\nSince the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too.\nYou must return the copy of the given node as a reference to the cloned graph.\n\n\n\n\n使用一个map来保存源节点Node和与之对应的deep copy of Node的对应关系。\n\n\n遍历Node的每一个neighbor， 将如果neighbor没有保存在map中，建立一个neighbor和deep copy of neighbor的对应关系。并将deep copy of neighbor加入deep copy of Node的neighbots中。\n\n\n对Node的每一个neighbor重复上述操作。\n\n\n需要注意的是，每次输入的Node有可能已经操作过了，因此，每次操作开始前，需要判断Node是否已经处理过，即判断deep copy of Node的neighbors长度是否为0即可\n\n\n/*// Definition for a Node.class Node &#123;    public int val;    public List&lt;Node&gt; neighbors;    public Node() &#123;&#125;    public Node(int _val,List&lt;Node&gt; _neighbors) &#123;        val = _val;        neighbors = _neighbors;    &#125;&#125;;*/class Solution &#123;    public Node cloneGraph(Node node) &#123;        HashMap&lt;Node, Node&gt; m = new HashMap&lt;&gt;();        dfs(m, node);        return m.get(node);    &#125;        public void dfs(HashMap&lt;Node, Node&gt; m, Node node) &#123;        if (! m.containsKey(node)) &#123;            m.put(node, new Node(node.val, new LinkedList&lt;Node&gt;()));        &#125;        if ( m.get(node).neighbors.size() != 0)            return ;        for (Node n: node.neighbors) &#123;            if (!m.containsKey(n)) &#123;                m.put(n, new Node(n.val, new LinkedList&lt;Node&gt;()));            &#125;            m.get(node).neighbors.add(m.get(n));            dfs(m, n);        &#125;    &#125;    &#125;\n","tags":["leetcode"]},{"title":"leetcode 135 Candy","url":"/article/leetcode-135-Candy/","content":"There are N children standing in a line. Each child is assigned a rating value.\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\n\nWhat is the minimum candies you must give?\nExample 1:\nInput: [1,0,2]Output: 5Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\nExample 2:\nInput: [1,2,2]Output: 4Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.             The third child gets 1 candy because it satisfies the above two conditions.\n\n\n用一个数组保存每一个小孩的candies数目，并初始化为1。\n从前往后遍历rantings，如果当前比之前一个大，candies[i] = candies[i-1]+1\n从后往前遍历rantings，如果当前比他前面的一个小，candies[i-1] = max(candies[i-1], candies[i]+1)\n\nclass Solution &#123;    public int candy(int[] ratings) &#123;        if (ratings.length == 0) return 0;        int n = 0;        int[] candies = new int[ratings.length];        for(int i=0; i&lt;ratings.length; i++) &#123;            candies[i] = 1;        &#125;        for (int i=1; i&lt;ratings.length; i++) &#123;            if(ratings[i] &gt; ratings[i-1]) &#123;                candies[i] = candies[i-1]+1;            &#125;        &#125;        for (int i=ratings.length-1; i&gt;0; i--) &#123;            if(ratings[i-1] &gt; ratings[i])&#123;                candies[i-1] = Math.max(candies[i-1], candies[i]+1);            &#125;        &#125;                for (int i: candies)&#123;            n+= i;        &#125;        return n;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 121 买卖股票的最佳时机","url":"/article/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","content":"给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。\n注意你不能在买入股票前卖出股票。\n示例 1:\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n示例 2:\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n","tags":["leetcode","动态规划"]},{"title":"leetcode 120 三角形最小路径和","url":"/article/leetcode-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","content":"给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n例如，给定三角形：\n[\n[2],\n[3,4],\n[6,5,7],\n[4,1,8,3]\n]\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n说明：\n如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。\n\nclass Solution(object):    def minimumTotal(self, triangle):        &quot;&quot;&quot;        :type triangle: List[List[int]]        :rtype: int        &quot;&quot;&quot;        if not triangle or not triangle[0]:            return 0                dp = [triangle[0][0]]        for i in range(1, len(triangle)):            t = []            for j in range(i+1):                if j == 0:                    t.append(dp[j] + triangle[i][j])                 elif j == i:                    t.append(dp[j-1] + triangle[i][j])                else:                    t.append(min(dp[j-1], dp[j]) + triangle[i][j])            dp = t        return min(dp)        \n","tags":["leetcode"]},{"title":"leetcode 145 Binary Tree Postorder Traversal","url":"/article/leetcode-145-Binary-Tree-Postorder-Traversal/","content":"Given a binary tree, return the postorder traversal of its nodes’ values.\nExample:\nInput: [1,null,2,3]   1    \\     2    /   3Output: [3,2,1]\nFollow up: Recursive solution is trivial, could you do it iteratively?\n\nRecursive one is trivia:\nclass Solution &#123;    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();      \ttraversal(ans, root);      \treturn ans;    &#125;    \tpublic void traversal(List&lt;Integer&gt; ans, TreeNode root) &#123;      if (root == null) &#123;        return ;      &#125;      traversal(ans, root.right);      traversal(ans, root.left);      ans.add(root.val);  \t&#125;&#125;\nFor iterative one, it’s a little complicated,\nclass Solution &#123;\t\tpublic List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;        LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();        if (root == null) return ans;      \tStack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      \tstack.push(root);        while(!stack.isEmpty()) &#123;\t\t\t\t\t\tTreeNode p = stack.pop();          \tans.addFirst(p.val);            if (p.left != null) &#123;              \tstack.push(p.left);            &#125;            if (p.right!=null) &#123;              \tstack.push(p.right);            &#125;        &#125;      \treturn ans;    &#125;&#125;\n\nExpansions:\nPreorder Traversal\nRecursive one:\nclass Solution &#123;  public List&lt;Integer&gt; preorderTravesl(TreeNode root) &#123;    LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();    travel(ans, root);    return ans;  &#125;  public void travel(List&lt;Integer&gt; ans, TreeNode root) &#123;    if (root == null) &#123;      return ;    &#125;    ans.add(root.val);    travel(ans, root.left);    travel(ans, root.right);  &#125;&#125;\nIterative one:\nclass Solution &#123;  public List&lt;Integer&gt; preorderTravesl(TreeNode root) &#123;    LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();    if (root == null) return ans;    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    stack.push(root);    while (!stack.isEmpty()) &#123;      TreeNode p = stack.pop();      ans.add(p.val);      if (p.right != null) &#123;        stack.push(p.right);      &#125;      if (p.left != null) &#123;        stack.push(p.left);      &#125;    &#125;    return ans;  &#125;&#125;\n\nInorder Traversal\nRecurative One:\nclass Solution &#123;  public List&lt;Integer&gt; inorderTravesl(TreeNode root) &#123;    LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();    travel(ans, root);    return ans;  &#125;  public void travel(List&lt;Integer&gt; ans, TreeNode root) &#123;    if (root == null) &#123;      return ;    &#125;    travel(ans, root.left);    ans.add(root.val);    travel(ans, root.right);  &#125;&#125;\nIterative One:\nclass Solution &#123;  public List&lt;Integer&gt; preorderTravesl(TreeNode root) &#123;    LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();    if (root == null) return ans;    TreeNode p = root;    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    while (!stack.isEmpty() || p != null) &#123;      while (p != null) &#123;        stack.push(p);        p = p.left;      &#125;      p = stack.pop();      ans.add(p.val);      p = p.right;    &#125;    return ans;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 174 Dungeon Game","url":"/article/leetcode-174-Dungeon-Game/","content":"The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\nSome of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).\nIn order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\nWrite a function to determine the knight’s minimum initial health so that he is able to rescue the princess.\nFor example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.\n\n\n\n-2 (K)\n-3\n3\n\n\n\n\n-5\n-10\n1\n\n\n10\n30\n-5 §\n\n\n\nNote:\n\nThe knight’s health has no upper bound.\nAny room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n\n\n\n从right-bottom到up-top遍历\n每一次的最小的生命值要么是1，要么是当前值减去当前位置到right-bottom的最小值\n在dp[m-1][n-1]的位置，当dungeon[m-1][n-1]小于1时，需要1-dungeon[m-1][n-1]，当dungeon[m-1][n-1] 大于1时， dp[m-1][n-1]也需要为1；\n\nclass Solution &#123;    public int calculateMinimumHP(int[][] dungeon) &#123;        if (dungeon.length == 0 || dungeon[0].length == 0)            return 0;        int m = dungeon.length;        int n = dungeon[0].length;        int[][] dp = new int[m][n];        for (int i=m-1; i&gt;=0; i--) &#123;            for (int j=n-1; j&gt;=0; j--) &#123;                if (i==m-1 &amp;&amp; j==n-1) &#123;                    dp[i][j] = Math.max(1, 1-dungeon[i][j]);                &#125;                else if(i==m-1) &#123;                    dp[i][j] = Math.max(1, dp[i][j+1] - dungeon[i][j]);                &#125;                else if (j==n-1) &#123;                    dp[i][j] = Math.max(1, dp[i+1][j] - dungeon[i][j]);                &#125;                else &#123;                    int up = Math.max(1, dp[i+1][j] - dungeon[i][j]);                    int left = Math.max(1, dp[i][j+1] - dungeon[i][j]);                    dp[i][j] = Math.min(up, left);                &#125;                            &#125;        &#125;        return dp[0][0];    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 125 验证回文串","url":"/article/leetcode-125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/","content":"给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n说明：本题中，我们将空字符串定义为有效的回文串。\n示例 1:\n输入: &quot;A man, a plan, a canal: Panama&quot;\n输出: true\n示例 2:\n输入: &quot;race a car&quot;\n输出: false\n\n","tags":["leetcode","字符串"]},{"title":"leetcode 200 Number of Islands","url":"/article/leetcode-200-Number-of-Islands/","content":"\n\nNumber of Islands\n\nGiven a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1:\nInput:11110110101100000000Output: 1\nExample 2:\nInput:11000110000010000011Output: 3\n\nclass Solution &#123;    public int numIslands(char[][] grid) &#123;        if(grid == null || grid.length == 0)&#123;            return 0;        &#125;        int m = grid.length;        int n = grid[0].length;        int count = 0;        for(int i=0; i&lt;m; i++)&#123;            for(int j=0; j&lt;n; j++)&#123;                if(grid[i][j] == &#x27;1&#x27;)&#123;                    count ++;                    removeIsland(grid, i, j, m,n);                &#125;            &#125;        &#125;        return count;    &#125;        public void removeIsland(char[][] grid, int i,  int j, int m, int n)&#123;        if(i&lt;0 || j &lt;0 || i&gt;=m  || j&gt;=n || grid[i][j] == &#x27;0&#x27;) return ;        else&#123;            grid[i][j] = &#x27;0&#x27;;            removeIsland(grid, i, j-1, m,n);            removeIsland(grid, i-1, j, m,n);            removeIsland(grid, i, j+1, m,n);            removeIsland(grid, i+1, j, m,n);        &#125;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 187 Repeated DNA Sequences","url":"/article/leetcode-187-Repeated-DNA-Sequences/","content":"All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\nExample:\nInput: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]\n\nsubstring + set\n\n直观的来讲，可以直接使用substring来截取每一个subsequence，然后和放入set1 和 set2，直接用(!s1.add(substring) &amp;&amp; s2.add(substring))来判断。\n\n当第一次处理substring时， 由于set1中没有substring，此时set1.add(subtring)返回true；!s1.add(substring)返回false，判断的后面一部分就不会执行，那么set2中并没有放入substring。\n当第二次处理substring时， !s1.add(subtring)返回true，执行s1.add(substring) 返回true。此时判断总体返回true。\n\n\n\npublic class Solution &#123;  public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;    HashSet&lt;String&gt; set = new HashSet&lt;&gt;();    List&lt;String&gt; ans = new ArrayList&lt;&gt;();    for (int i=0; i+9&lt;s.length(); i++) &#123;      String part = s.substring(i, i+10);      if (!set.add(part) &amp;&amp; set.add() &#123;        ans.add(part);      &#125;    &#125;    return ans;  &#125;&#125;\n\n但是这种方法，使用substring的时间复杂度为$O(s.length())$.总体的复杂度实际为$ O(n ^ 2)$\n\nHashSet + bit Operation\n\n由于总共的字符只有四个字符，用二进制编码可以用两比特来表示，因此，可以先对字符进行编码，然后每十个字符转换成一个整数，用这个整数来代替上面的substring操作，这样一来，时间复杂度为$O(kn)$。\n\nclass Solution &#123;    public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;        HashSet&lt;String&gt; first = new HashSet&lt;&gt;();        HashSet&lt;String&gt; second = new HashSet&lt;&gt;();        List&lt;String&gt; ans = new ArrayList&lt;&gt;();        for (int i=0; i+9&lt;s.length(); i++) &#123;          String part = s.substring(i, i+10);          if (!first.add(part) &amp;&amp; second.add(part)) &#123;            ans.add(part);          &#125;        &#125;        return ans;    &#125;&#125;","tags":["leetcode"]},{"title":"leetcode 201 Bitwise AND of Numbers Range","url":"/article/leetcode-201-Bitwise-AND-of-Numbers-Range/","content":"Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.\nExample 1:\nInput: [5,7]Output: 4\nExample 2:\nInput: [0,1]Output: 0\n\n题目的要求是，求出区间[m,n]中，每一个数的每一位上的AND操作之后得到的数值。例如：\n\n\n[5,7]：\n\n\n0 0 1 0 1\n0 0 1 1 0\n0 0 1 1 1\n------\n0 0 1 0 0\n\n\n\n\n[0, 1]:\n\n\n0 0 0 0\n0 0 0 1\n-----\n0 0 0 0\n\n\n\n\n其实就相当于是求二进制的最长的公共前缀\n\n\nclass Solution &#123;    public int rangeBitwiseAnd(int m, int n) &#123;        int move = 0;        while (m != n) &#123;            m &gt;&gt;= 1;            n &gt;&gt;= 1;            move ++;        &#125;        return n &lt;&lt; move;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 199 Binary Tree Right Side View","url":"/article/leetcode-199-Binary-Tree-Right-Side-View/","content":"Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExample:\nInput: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation:   1            &lt;--- /   \\2     3         &lt;--- \\     \\  5     4       &lt;---\n\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        helper(ans, root, 0);        return ans;    &#125;    public void helper(List&lt;Integer&gt; ans, TreeNode root, int level) &#123;        if (root == null)            return ;        if (ans.size() == level) &#123;            ans.add(root.val);        &#125;           if (root.right != null)            helper(ans, root.right, level+1);        if (root.left != null)            helper(ans, root.left, level+1);    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 207 Course Schedule","url":"/article/leetcode-207-Course-Schedule/","content":"There are a total of n courses you have to take, labeled from 0 to n-1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\nExample 1:\nInput: 2, [[1,0]] Output: trueExplanation: There are a total of 2 courses to take.              To take course 1 you should have finished course 0. So it is possible.\nExample 2:\nInput: 2, [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take.              To take course 1 you should have finished course 0, and to take course 0 you should             also have finished course 1. So it is impossible.\nNote:\n\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\nYou may assume that there are no duplicate edges in the input prerequisites.\n\n\n\n等价于判断图中是否存在环\n对于图的表述，可以使用邻接矩阵和入度来表示\n对所有入度为0的课程，学习他。\n学习完一个课程之后，将以该课程为prerequisite的课程的入度都减一\n如果存在一个课程入度为0，将其加入待学习的set中\n每学习一个课程，count一下它\n最后比较count的数目是否为所有课程的数目\n\nclass Solution &#123;    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;        if (prerequisites.length == 0 || prerequisites[0].length == 0) return true;        LinkedList&lt;Integer&gt;[] neighbors = new LinkedList[numCourses];        for (int i=0; i&lt;numCourses; i++) neighbors[i] = new LinkedList&lt;Integer&gt;();        int[] indegree = new int[numCourses];        int n = 0;        for (int[] crs: prerequisites) &#123;            int take = crs[0];            int pre = crs[1];            if (neighbors[pre] == null) &#123;                neighbors[pre] = new LinkedList&lt;Integer&gt;();            &#125;            neighbors[pre].add(take);            indegree[take]++;        &#125;                Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();                for (int i=0; i&lt;numCourses; i++) &#123;            if (indegree[i] == 0) &#123;                q.offer(i);            &#125;        &#125;                while (!q.isEmpty()) &#123;            int crs = q.poll();            n ++;            for (int pre: neighbors[crs]) &#123;                indegree[pre] --;                if (indegree[pre] == 0) &#123;                    q.offer(pre);                &#125;            &#125;        &#125;        return n == numCourses;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 211 Add and Search Word - Data structure design","url":"/article/leetcode-211-Add-and-Search-Word---Data-structure-design/","content":"Design a data structure that supports the following two operations:\nvoid addWord(word)bool search(word)\nsearch(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\nExample:\naddWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true\nNote:\nYou may assume that all words are consist of lowercase letters a-z.\n\n\n可以使用trie数来处理\n主要是处理.的问题\n\nclass WordDictionary &#123;    class Node &#123;        Node[] next;        boolean isWord;                public Node() &#123;            next = new Node[26];        &#125;;    &#125;        Node root = new Node();        /** Initialize your data structure here. */    public WordDictionary() &#123;    &#125;        /** Adds a word into the data structure. */    public void addWord(String word) &#123;        Node p = root;            for (char c: word.toCharArray()) &#123;                if (p.next[c-&#x27;a&#x27;] == null) &#123;                    p.next[c-&#x27;a&#x27;] = new Node();                &#125;                p = p.next[c-&#x27;a&#x27;];            &#125;            p.isWord = true;    &#125;        /** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */    public boolean search(String word) &#123;        return find(word, root);    &#125;        public boolean find(String word, Node p) &#123;        for (int i=0; i&lt;word.length(); i++) &#123;            char c = word.charAt(i);            if (c&gt;=&#x27;a&#x27; &amp;&amp; c&lt;=&#x27;z&#x27;) &#123;                if (p.next[c-&#x27;a&#x27;] == null) &#123;                    return false;                &#125;                p = p.next[c-&#x27;a&#x27;];            &#125;            else &#123;                boolean find = false;                for (Node n: p.next) &#123;                    if (n != null) &#123;                        find = (find || find(word.substring(i+1), n));                    &#125;                &#125;                return find;            &#125;          &#125;        return p.isWord;    &#125;&#125;/** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */\n","tags":["leetcode"]},{"title":"leetcode 214 Shortest Palindrome","url":"/article/leetcode-214-Shortest-Palindrome/","content":"Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\nExample 1:\nInput: &quot;aacecaaa&quot;Output: &quot;aaacecaaa&quot;\nExample 2:\nInput: &quot;abcd&quot;Output: &quot;dcbabcd&quot;\n\n\n对于任意一个S，我们需要尽可能的找到一个S[0:i]是一个回文，这样的话，S[0:i]可以保持不变，然后把S[i：i-1] reverse后放在最前面，使之能够成为满足要求的最短的回文。\n如何在S中尽可能的找到S[0：i]是一个回文呢？\n\n对于一个回文，最终重要的性质是S[i] = S[n-i]\n如果i在S中从左往右遍历，j在S中从右往左遍历，如果S[i] == S[j]，i++，j保持- -, 这样一来，如果S[0，somewhere]是一个回文的话，i肯定在somewhere的右边。也就是说S[0：i]肯定包含这个要求的回文prefix。那么S[i:-1]就是肯定需要进行转置后放到S前面的。\n\n\n\nclass Solution &#123;    public String shortestPalindrome(String s) &#123;        int left = 0;        for (int right = s.length()-1; right&gt;=0; right--) &#123;            if (s.charAt(left) == s.charAt(right)) &#123;                left ++;            &#125;        &#125;        if (left == s.length())            return s;        String prefix = s.substring(0, left);        String suffix = s.substring(left);        return new StringBuilder(suffix).reverse().toString() + shortestPalindrome(prefix) + suffix;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 220 Contains Duplicate","url":"/article/leetcode-220-Contains-Duplicate/","content":"Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.\nExample 1:\nInput: nums = [1,2,3,1], k = 3, t = 0Output: true\nExample 2:\nInput: nums = [1,0,1,1], k = 1, t = 2Output: true\nExample 3:\nInput: nums = [1,5,9,1,5,9], k = 2, t = 3Output: false\n\n\n使用hashmap来保存t个数\n将每个数模(t+1)，将其放入对应的bucket中，那么每个bucket中的number的index差可定是在0-t之间的。\n对于相邻的两个bucket，也可能存在index差在0-t的number，一次，对于每个相邻的bucket，需要检查是否index差小于t\nnums[i]可能是负数，若负数模(t+1)，对应的bucket会错位，因此，nums[i]需要将其全部转换为正数，即nums[i]-Integer.MIN_VALUE;\n控制hashmap的item数目，来保证所求的index距离小于等于k\nCorner case是k&lt;1 || t &lt; 0\n\nclass Solution &#123;    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;        HashMap&lt;Long, Long&gt; m = new HashMap&lt;&gt;();        if ( k &lt; 1 || t &lt; 0)             return false;        for (int i=0; i&lt;nums.length; i++) &#123;            long mapped = (long)nums[i] - Integer.MIN_VALUE;            long bucket = mapped/((long)t+1);            if (m.containsKey(bucket)) &#123;                return true;            &#125;            if (m.containsKey(bucket-1) &amp;&amp; (mapped - m.get(bucket-1)) &lt;= t) &#123;                return true;            &#125;            if (m.containsKey(bucket+1) &amp;&amp; (m.get(bucket+1) - mapped) &lt;= t) &#123;                return true;            &#125;            if (i &gt;= k) &#123;                m.remove(((long)nums[i-k]-Integer.MIN_VALUE)/((long)t+1));            &#125;            m.put(bucket, mapped);        &#125;        return false;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 236 Lowest Common Ancestor of a Binary Tree","url":"/article/leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/","content":"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nGiven the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]\n\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.\nExample 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\nNote:\n\nAll of the nodes’ values will be unique.\np and q are different and both values will exist in the binary tree.\n\n\n\n最小公共节点的特征: p 和 q 要么分别来自它的左右分支，要么p和q中有一本身就是最小公共节点。\n这样一来，可以用递归的方式，先依次遍历每一个节点。递归的在每一个节点的左右节点查找p和q\n如果当前节点的左右分支都有返回值，那么当前节点就是一个最小公共节点\n否则，由于公共最小节点可定存在，那么左右分支中必有一个是返回值。返回左右节点中非空的那个\n\nclass Solution &#123;  public TreeNode smallestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;    if (root == null || root == p || root == q)      return root;    TreeNode left = smallestCommonAncesstor(root.left, p, q);    TreeNode right = smallestCommonAncesstor(root.right, p, q);    if (left != null &amp;&amp; right != null) &#123;      return root;    &#125;    if (left == null)      return right;    return left;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 25 K 个一组翻转链表","url":"/article/leetcode-25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","content":"给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。\n如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n示例 :\n给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5\n当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5\n当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5\n说明 :\n你的算法只能使用常数的额外空间。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n\n\n非递归\n# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution(object):    def reverseKGroup(self, head, k):        &quot;&quot;&quot;        :type head: ListNode        :type k: int        :rtype: ListNode        &quot;&quot;&quot;        dump = ListNode(-1)        prev = dump # 上一次的尾巴        prev.next = head        tail = prev # 从上一次的尾巴开始计数        while True:            count = k            while tail and count:                tail = tail.next                count -= 1            if not tail:                break            curr = prev.next            tag = curr            while curr is not tail:                curr.next, tail.next, prev.next = tail.next, curr, curr.next                curr = prev.next            prev = tag            tail = tag        return dump.next\n\n\n\n\n递归\n# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution(object):    def reverseKGroup(self, head, k):        &quot;&quot;&quot;        :type head: ListNode        :type k: int        :rtype: ListNode        &quot;&quot;&quot;        n = k        p = head        tail = None        while p and n:            tail = p            p = p.next            n -= 1        if n != 0:            return head        tail.next = self.reverseKGroup(tail.next, k)        while head is not tail:            p = head            head = head.next            p.next = tail.next            tail.next = p        return tail\n\n","tags":["leetcode","链表"]},{"title":"leetcode 14 最长公共前缀","url":"/article/leetcode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","content":"编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 “”。\n示例 1:\n输入: [“flower”,“flow”,“flight”]\n输出: &quot;fl&quot;\n示例 2:\n输入: [“dog”,“racecar”,“car”]\n输出: &quot;&quot;\n解释: 输入不存在公共前缀。\n说明:\n所有输入只包含小写字母 a-z 。\n\nclass Solution(object):    def longestCommonPrefix(self, strs):        &quot;&quot;&quot;        :type strs: List[str]        :rtype: str        &quot;&quot;&quot;        if not strs:            return &quot;&quot;        s1 = max(strs)        s2 = min(strs)        for i, s in enumerate(s2):            if s != s1[i]:                return s2[:i]        return s2        \n","tags":["leetcode","字符串"]},{"title":"leetcode 24 两两交换链表中的节点","url":"/article/leetcode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","content":"给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例:\n给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.\n\n# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution(object):    def swapPairs(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not head or not head.next:            return head        dump = ListNode(-1)        dump.next = head        prev = dump        cur = head        while cur:            tail = cur.next            if not tail:                break            cur.next = tail.next            tail.next = cur            prev.next = tail            prev = cur            cur = cur.next        return dump.next\n\n\n递归\nclass Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        if(head == null || head.next == null)&#123;            return head;        &#125;        ListNode next = head.next;        head.next = swapPairs(next.next);        next.next = head;        return next;    &#125;&#125;\n\n\n非递归\nclass Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode pre = new ListNode(0);        pre.next = head;        ListNode temp = pre;        while(temp.next != null &amp;&amp; temp.next.next != null) &#123;            ListNode start = temp.next;            ListNode end = temp.next.next;            temp.next = end;            start.next = end.next;            end.next = start;            temp = start;        &#125;        return pre.next;    &#125;&#125;\n\n\n","tags":["leetcode","链表"]},{"title":"leetcode 212 Word Search II","url":"/article/leetcode-212.-Word-Search-II/","content":"Given a 2D board and a list of words from the dictionary, find all words in the board.\nEach word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\nExample:\nInput: board = [  [&#x27;o&#x27;,&#x27;a&#x27;,&#x27;a&#x27;,&#x27;n&#x27;],  [&#x27;e&#x27;,&#x27;t&#x27;,&#x27;a&#x27;,&#x27;e&#x27;],  [&#x27;i&#x27;,&#x27;h&#x27;,&#x27;k&#x27;,&#x27;r&#x27;],  [&#x27;i&#x27;,&#x27;f&#x27;,&#x27;l&#x27;,&#x27;v&#x27;]]words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]Output: [&quot;eat&quot;,&quot;oath&quot;]\nNote:\n\nAll inputs are consist of lowercase letters a-z.\nThe values of words are distinct.\n\n\nclass Solution &#123;    class TrieNode&#123;        TrieNode[] next;        boolean isWord;        public TrieNode() &#123;            next = new TrieNode[26];        &#125;;    &#125;        public TrieNode buildTrie(String[] words) &#123;        TrieNode root = new TrieNode();        for (String s: words) &#123;            TrieNode p = root;            for (char c: s.toCharArray()) &#123;                if (p.next[c-&#x27;a&#x27;] == null) &#123;                    p.next[c-&#x27;a&#x27;] = new TrieNode();                &#125;                p = p.next[c-&#x27;a&#x27;];            &#125;            p.isWord = true;        &#125;        return root;    &#125;        public List&lt;String&gt; findWords(char[][] board, String[] words) &#123;        List&lt;String&gt; ans = new LinkedList&lt;&gt;();        if (board.length == 0 || board[0].length == 0 || words.length == 0) return ans;        TrieNode root = buildTrie(words);        int m = board.length;        int n = board[0].length;        boolean[][] visited = new boolean[m][n];        StringBuilder sb = new StringBuilder();        for (int i=0; i&lt;m; i++) &#123;            for (int j=0; j&lt;n; j++) &#123;                helper(ans, sb, root, i, j, m, n, visited, board);            &#125;        &#125;        return ans;    &#125;    public void helper(List&lt;String&gt; ans, StringBuilder sb, TrieNode root, int i, int j, int m, int n, boolean[][] visited, char[][] matrix) &#123;        if (root == null) return ;                if (root.isWord) &#123;            ans.add(sb.toString());            root.isWord = false; // 这里不用终止        &#125;                  if (i&lt;0 || j&lt;0 || i&gt;=m || j &gt;=n || visited[i][j])             return ;                visited[i][j] = true;        char c = matrix[i][j];        sb.append(c);        helper(ans, sb, root.next[c-&#x27;a&#x27;], i-1, j, m, n, visited, matrix);        helper(ans, sb, root.next[c-&#x27;a&#x27;], i+1, j, m, n, visited, matrix);        helper(ans, sb, root.next[c-&#x27;a&#x27;], i, j-1, m, n, visited, matrix);        helper(ans, sb, root.next[c-&#x27;a&#x27;], i, j+1, m, n, visited, matrix);        sb.deleteCharAt(sb.length()-1);        visited[i][j] = false;            &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 26 删除排序数组中的重复项","url":"/article/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","content":"给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n示例 1:\n给定数组 nums = [1,1,2],\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。\n你不需要考虑数组中超出新长度后面的元素。\n示例 2:\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n你不需要考虑数组中超出新长度后面的元素。\n\nclass Solution(object):    def removeDuplicates(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        i = 0        j = 0        while j &lt; len(nums):            while j &lt; len(nums) and nums[i] == nums[j] :                j += 1            i += 1            if j &lt; len(nums):                nums[i] = nums[j]        return i                    \n","tags":["leetcode","数组"]},{"title":"leetcode 27 移除元素","url":"/article/leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","content":"给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1:\n给定 nums = [3,2,2,3], val = 3,\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n你不需要考虑数组中超出新长度后面的元素。\n示例 2:\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n注意这五个元素可为任意顺序。\n你不需要考虑数组中超出新长度后面的元素。\n\nclass Solution(object):    def removeElement(self, nums, val):        &quot;&quot;&quot;        :type nums: List[int]        :type val: int        :rtype: int        &quot;&quot;&quot;        i = 0        j = 0        while j &lt; len(nums):            if nums[j] == val:                j += 1            else:                nums[i] = nums[j]                i += 1                j += 1        return i\n","tags":["leetcode","数组","双指针"]},{"title":"leetcode 28 实现strStr()","url":"/article/leetcode-28-%E5%AE%9E%E7%8E%B0strStr()/","content":"实现 strStr() 函数。\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。\n示例 1:\n输入: haystack = “hello”, needle = &quot;ll&quot;\n输出: 2\n示例 2:\n输入: haystack = “aaaaa”, needle = &quot;bba&quot;\n输出: -1\n说明:\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\n\n","tags":["leetcode","字符串"]},{"title":"leetcode 29 两数相除","url":"/article/leetcode-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/","content":"给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。\n返回被除数 dividend 除以除数 divisor 得到的商。\n示例 1:\n输入: dividend = 10, divisor = 3\n输出: 3\n示例 2:\n输入: dividend = 7, divisor = -3\n输出: -2\n说明:\n被除数和除数均为 32 位有符号整数。\n除数不为 0。\n假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。\n\nclass Solution(object):    def divide(self, dividend, divisor):        &quot;&quot;&quot;        :type dividend: int        :type divisor: int        :rtype: int        &quot;&quot;&quot;        ans = 0        sign = (dividend &gt; 0) ^ (divisor &gt; 0)        dividend, divisor = abs(dividend), abs(divisor)        while dividend &gt;= divisor:            t = divisor            cur = 1            while dividend &gt;= t:                dividend -= t                t = t &lt;&lt; 1                ans += cur                cur = cur &lt;&lt; 1        if sign:            ans = -ans        return min(max(-(1&lt;&lt;31), ans), (1&lt;&lt;31)-1)\n","tags":["leetcode","数学"]},{"title":"leetcode 315 Count of Smaller Numbers After Self","url":"/article/leetcode-315-Count-of-Smaller-Numbers-After-Self/","content":"You are given an integer array nums and you have to return a new countsarray. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].\nExample:\nInput: [5,2,6,1]Output: [2,1,1,0] Explanation:To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element.\n\nbasic idea:\n\n\n对数组进行mergesort，每次将left数组和right数组合并成一个数组\n\n\n在合并的时候，当这个数是从right数组过来的时候，那么这以后，从left过来的数的count就要加上1.\n\n\n当合并的数是从left过来的时候，把left对应的counts[i]加上count\n\n\n在merge的时候，不用对原始的nums进行merge，只需要对nums对应的index进行重新排序就好\n\n\nclass Solution &#123;    public List&lt;Integer&gt; countSmaller(int[] nums) &#123;        int[] res = new int[nums.length];        int[] idx = new int[nums.length];        for (int i=0; i&lt;nums.length; i++) idx[i] = i;        mergeSort(nums, res, idx, 0, nums.length-1);        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        for (int i: res) &#123;            ans.add(i);        &#125;        return ans;    &#125;        public void mergeSort(int[] nums, int[] res, int[] idx, int left, int right) &#123;        if (right &lt;= left) &#123;            return ;        &#125;        int mid = (left + right) / 2;        mergeSort(nums, res, idx, left, mid);        mergeSort(nums, res, idx, mid+1, right);        merge(nums, res, idx, left, mid, mid+1, right);    &#125;        public void merge(int[] nums, int[] res, int[] idx, int l1, int r1, int l2, int r2) &#123;        int[] temp = new int[r2-l1+1];        int count = 0;        int t = 0;        int start = l1;        while ( l1 &lt;= r1 || l2 &lt;= r2) &#123;            if (l1 &gt; r1) &#123;                temp[t++] = idx[l2++];            &#125;            else if (l2 &gt; r2) &#123;                res[idx[l1]] += count;                temp[t++] = idx[l1++];            &#125;            else if (nums[idx[l1]] &gt; nums[idx[l2]]) &#123;                temp[t++] = idx[l2++];                count ++;            &#125;            else &#123;                res[idx[l1]] += count;                temp[t++] = idx[l1++];            &#125;        &#125;        for (int i=0; i&lt;temp.length; i++) &#123;            idx[start+i] = temp[i];        &#125;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 316 Remove Duplicate Letters","url":"/article/leetcode-316-Remove-Duplicate-Letters/","content":"Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nExample 1:\nInput: &quot;bcabc&quot;Output: &quot;abc&quot;\nExample 2:\nInput: &quot;cbacdcbc&quot;Output: &quot;acdb&quot;\n\n先用一个count数组保存每一个字符出现的次数。\n然后从左到右遍历count数组，同时保存当前遇到的最小的字符的下表。\n每遇到一个新的字符，将count数组中对应的位置减1，如果得到0，说明再往后就不再会出现该字符了，那么就需要把该字符之前的最小的字符保存到返回的string中。\nclass Solution &#123;    public String removeDuplicateLetters(String s) &#123;        if (s.isEmpty())            return &quot;&quot;;        int[] count = new int[26];        for (char c: s.toCharArray()) &#123;            count[c-&#x27;a&#x27;] ++;        &#125;        int idx = 0;        for (int i=0; i&lt;s.length(); i++) &#123;            if (s.charAt(i) &lt; s.charAt(idx))                 idx = i;            if (--count[s.charAt(i) - &#x27;a&#x27;] == 0)                break;        &#125;        return s.charAt(idx) + removeDuplicateLetters(s.substring(idx+1).replace(&quot;&quot;+s.charAt(idx), &quot;&quot;));            &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 32 最长有效括号","url":"/article/leetcode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","content":"给定一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。\n示例 1:\n输入: &quot;(()&quot;\n输出: 2\n解释: 最长有效括号子串为 &quot;()&quot;\n示例 2:\n输入: &quot;)()())&quot;\n输出: 4\n解释: 最长有效括号子串为 “()()”\nclass Solution(object):    def longestValidParentheses(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: int        &quot;&quot;&quot;        stack = [0]        lmax = 0        if not s:            return 0        for i in s:            if i == &#x27;(&#x27;:                stack.append(0)            else:                if len(stack) &lt;=1:                    stack = [0]                else:                    stack[-2] += stack[-1]+2                    stack.pop()                    lmax = max(lmax, stack[-1])        return lmax                        \n","tags":["leetcode","字符串","动态规划"]},{"title":"leetcode 30 串联所有单词的子串","url":"/article/leetcode-30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/","content":"给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。\n注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。\n示例 1：\n输入：\ns = “barfoothefoobarman”,\nwords = [“foo”,“bar”]\n输出：[0,9]\n解释：\n从索引 0 和 9 开始的子串分别是 “barfoor” 和 “foobar” 。\n输出的顺序不重要, [9,0] 也是有效答案。\n示例 2：\n输入：\ns = “wordgoodgoodgoodbestword”,\nwords = [“word”,“good”,“best”,“word”]\n输出：[]\n\nclass Solution(object):    def findSubstring(self, s, words):        &quot;&quot;&quot;        :type s: str        :type words: List[str]        :rtype: List[int]        &quot;&quot;&quot;        if not words:            return []        wordsSet = sorted(words)        ans, num, width = [], len(words), len(words[0])        space = num*width        if len(s) &lt; space:            return ans        for i in range(len(s)-space+1):            t = []            for j in range(i, i+space, width):                t.append(s[j:j+width])            if sorted(t) == wordsSet:                ans.append(i)        return ans                    \n","tags":["leetcode","字符串"]},{"title":"leetcode 34 在排序数组中查找元素的第一个和最后一个位置","url":"/article/leetcode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","content":"给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n你的算法时间复杂度必须是 O(log n) 级别。\n如果数组中不存在目标值，返回 [-1, -1]。\n示例 1:\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]\n示例 2:\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]\nclass Solution(object):    def searchRange(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: List[int]        &quot;&quot;&quot;        ans = [-1, -1]        if not nums:            return ans        left = 0        right = len(nums)-1        while left &lt; right:            mid = left + ((right-left)&gt;&gt;1)            if nums[mid] &lt; target:                left = mid + 1            else:                right = mid        if nums[right] != target:            return ans        ans[0] = right                right = len(nums)-1        while left &lt; right:            mid = left + ((right-left+1)&gt;&gt;1)            if nums[mid] &gt; target:                right = mid-1            else:                left = mid        ans[1] = left        return ans        \n","tags":["leetcode","二分查找"]},{"title":"leetcode 31 下一个排列","url":"/article/leetcode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","content":"实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n必须原地修改，只允许使用额外常数空间。\n以下是一些例子，输入位于左侧列，其相应输出位于右侧列。\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n\n\n从后往前遍历，每一次判断nums[i]是否大于nums[i+1]，如果大于就继续，不大于就暂时停止。\n遍历一遍得到i之后，如果i==-1，说明整个数组都是递减的，此时的下一个数值为整个数组的reverse\n如果i在中间的某一个idx，从i往后遍历，找到最小的那个大于nums[i]的数，swap这两个数\nreverse之后，将i后面的整个数组reverse\n\n举个例子：\n        1\t2\t5\t7\t6\t4\t3            i\t\tjswap:        1\t2\t6\t7\t5\t4\t3        \t\ti   reverse:\t\t\t\t1\t2\t6\t3\t4\t5\t7\nclass Solution(object):    def nextPermutation(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: None Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        def reverse(nums, left, right):            while left &lt; right:                nums[left], nums[right] = nums[right], nums[left]                left += 1                right -= 1                        if not nums:            return         i = len(nums)-2        while i &gt;= 0 and nums[i] &gt;= nums[i+1]:            i -= 1        if i == -1:            nums.reverse()            return         j = i+1        while j &lt;= len(nums)-1 and nums[j]&gt;nums[i]:            j += 1        j -= 1        nums[i], nums[j] = nums[j], nums[i]        reverse(nums, i+1, len(nums)-1)                        \n","tags":["leetcode","数组"]},{"title":"leetcode 36 有效的数独","url":"/article/leetcode-36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/","content":"判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。\n数字 1-9 在每一行只能出现一次。\n数字 1-9 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n上图是一个部分填充的有效的数独。\n数独部分空格内已填入了数字，空白格用 ‘.’ 表示。\n示例 1:\n输入:[  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true\n示例 2:\n输入:[  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false\n解释:\n除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。\n但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。\n说明:\n一个有效的数独（部分已被填充）不一定是可解的。\n只需要根据以上规则，验证已经填入的数字是否有效即可。\n给定数独序列只包含数字 1-9 和字符 ‘.’ 。\n给定数独永远是 9x9 形式的。\n\n\n","tags":["leetcode","数组"]},{"title":"leetcode 37 解数独","url":"/article/leetcode-37-%E8%A7%A3%E6%95%B0%E7%8B%AC/","content":"编写一个程序，通过已填充的空格来解决数独问题。\n一个数独的解法需遵循如下规则：\n数字 1-9 在每一行只能出现一次。\n数字 1-9 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n空白格用 ‘.’ 表示。\n\n一个数独。\n\n答案被标成红色。\nNote:\n给定的数独序列只包含数字 1-9 和字符 ‘.’ 。\n你可以假设给定的数独只有唯一解。\n给定数独永远是 9x9 形式的。\n\nclass Solution(object):    def solveSudoku(self, board):        &quot;&quot;&quot;        :type board: List[List[str]]        :rtype: None Do not return anything, modify board in-place instead.        &quot;&quot;&quot;        def dfs(usedCol, usedRow, usedGrid, col, row):            if col == 9:                col = 0                row += 1                if row == 9:                    print(board)                    return True            if board[row][col] != &#x27;.&#x27;:                if dfs(usedCol, usedRow, usedGrid, col + 1, row):                    return True            else:                for i in range(9):                    if not usedRow[row][i] and not usedCol[col][i] and not usedGrid[row // 3][col // 3][i]:                        usedRow[row][i] = True                        usedCol[col][i] = True                        usedGrid[row // 3][col // 3][i] = True                        board[row][col] = str(i + 1)                        if dfs(usedCol, usedRow, usedGrid, col + 1, row):                            return True                        board[row][col] = &#x27;.&#x27;                        usedRow[row][i] = False                        usedCol[col][i] = False                        usedGrid[row // 3][col // 3][i] = False            return False        usedCol = [[False] * 9 for i in range(9)]        usedRow = [[False] * 9 for i in range(9)]        usedGrid = [[[False] * 9 for i in range(3)] for j in range(3)]        for i in range(9):            for j in range(9):                if board[i][j] != &#x27;.&#x27;:                    num = ord(board[i][j]) - ord(&#x27;1&#x27;)                    usedRow[i][num] = True                    usedCol[j][num] = True                    usedGrid[i // 3][j // 3][num] = True        dfs(usedCol, usedRow, usedGrid, 0, 0)\n","tags":["leetcode","数组"]},{"title":"leetcode 38 报数","url":"/article/leetcode-38-%E6%8A%A5%E6%95%B0/","content":"报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：\n\n\n1\n\n\n\n11\n\n\n\n21\n\n\n\n1211\n\n\n\n111221\n\n\n\n1 被读作  “one 1”  (“一个一”) , 即 11。\n11 被读作 “two 1s” (“两个一”）, 即 21。\n21 被读作 “one 2”,  “one 1” （“一个二” ,  “一个一”) , 即 1211。\n给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。\n注意：整数顺序将表示为一个字符串。\n示例 1:\n输入: 1\n输出: &quot;1&quot;\n示例 2:\n输入: 4\n输出: “1211”\n\nclass Solution(object):    def countAndSay(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: str        &quot;&quot;&quot;        lastWord = &#x27;1&#x27;        for i in range(1, n):            j = 0            curWord = &#x27;&#x27;            cnt = 0            while j &lt; len(lastWord):                c = lastWord[j]                cnt = 1                j = j+1                while j&lt;len(lastWord) and lastWord[j] == c:                    cnt += 1                    j += 1                 curWord += str(cnt) + str(c)            lastWord = curWord                    return lastWord\n","tags":["leetcode","数组"]},{"title":"leetcode 404 Sum of Left Leaves","url":"/article/leetcode-404-Sum-of-Left-Leaves/","content":"Find the sum of all left leaves in a given binary tree.\nExample:\n    3   / \\  9  20    /  \\   15   7There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.\n\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int sumOfLeftLeaves(TreeNode root) &#123;        if (root == null)            return 0;        return helper(root, false);    &#125;        public int helper(TreeNode root, boolean isLeft) &#123;        if (root == null)            return 0;        if (isLeft &amp;&amp; root.left == null &amp;&amp; root.right == null)             return root.val;        return helper(root.left, true) + helper(root.right, false);    &#125;&#125;\n\nUsing stack\n\npublic int sumOfLeftLeaves(TreeNode&lt;Integer&gt; root) &#123;    int res = 0;    if (root == null) return res;    Stack&lt;TreeNode&lt;Integer&gt;&gt; stack = new Stack&lt;&gt;();    while (root != null || !stack.isEmpty()) &#123;        while (root != null) &#123;            stack.push(root);            root = root.right;        &#125;        root = stack.pop();        root = root.left;        if (root != null &amp;&amp; root.left == null &amp;&amp; root.right == null) res += root.val;    &#125;    return res;&#125;\n","tags":["leetcode"]},{"title":"leetcode 403 Frog Jump","url":"/article/leetcode-403-Frog-Jump/","content":"A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\nGiven a list of stones’ positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.\nIf the frog’s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.\nNote:\n\nThe number of stones is ≥ 2 and is &lt; 1,100.\nEach stone’s position will be a non-negative integer &lt; 231.\nThe first stone’s position is always 0.\n\nExample 1:\n[0,1,3,5,6,8,12,17]There are a total of 8 stones.The first stone at the 0th unit, second stone at the 1st unit,third stone at the 3rd unit, and so on...The last stone at the 17th unit.Return true. The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\nExample 2:\n[0,1,2,3,4,8,9,11]Return false. There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n\n\n对每一个nums[i]设置一个HashSet&lt;&gt;，用来保存当前nums[i]能走的步长。\n对每一个nums[i]中保存的步长step，看nums[i]+step是否能够到达最后一个数nums[nums.length-1]\n\n如果能，则返回true\n如果不能，那么在nums[i]+step的HashSet中保存下step，step+1，step-1 (step-1需要大于0)\n\n\n\nclass Solution &#123;    public boolean canCross(int[] stones) &#123;        HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; m = new HashMap&lt;&gt;();        if (stones.length == 0 || stones.length == 1) return true;        for (int i: stones) &#123;            m.put(i, new HashSet&lt;Integer&gt;());        &#125;        m.get(0).add(1);        for (int i: stones) &#123;            HashSet&lt;Integer&gt; steps = m.get(i);            for (int step: steps) &#123;                int reach = step + i;                if (reach == stones[stones.length-1])                    return true;                HashSet set = m.get(reach);                if (set != null) &#123;                    set.add(step);                    if (step-1&gt;0)                        set.add(step-1);                    set.add(step+1);                &#125;            &#125;        &#125;        return false;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 405 Convert a Number to Hexadecimal","url":"/article/leetcode-405-Conver-a-Number-to-Hex/","content":"Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.\nNote:\n\nAll letters in hexadecimal (a-f) must be in lowercase.\nThe hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character.\nThe given number is guaranteed to fit within the range of a 32-bit signed integer.\nYou must not use any method provided by the library which converts/formats the number to hex directly.\n\nExample 1:\nInput:26Output:&quot;1a&quot;\nExample 2:\nInput:-1Output:&quot;ffffffff&quot;\n\nclass Solution(object):    def toHex(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: str        &quot;&quot;&quot;        dic = &#123;10: &#x27;a&#x27;, 11: &#x27;b&#x27;, 12: &#x27;c&#x27;, 13: &#x27;d&#x27;, 14: &#x27;e&#x27;, 15: &#x27;f&#x27;&#125;                if num == 0:            return &#x27;0&#x27;                if num  &lt; 0:            num = num + 2**32                ans = []                while num != 0:            t = num % 16            num = num / 16            if t &lt; 10:                ans.insert(0, str(t))            else:                ans.insert(0, dic[t])        return &#x27;&#x27;.join(ans);\nKeyNodes:\n\n\n负数的情况比较复杂，可以考虑直接从负数转换为对应的正数的编码。\n\n\n方法一：\n直接在负数的基础上加上$2^{32}$\n\n\n方法二：\nnum = -numnum ^= 0xffffffffnum += 1\n\n\n\n\n注意保存在ans之后，需要进行reverse操作\n\n\n如果使用str来保存最后的结果，可以使用str[::-1]来进行reverse操作。\n\n\n","tags":["leetcode"]},{"title":"leetcode 400 Nth Digit","url":"/article/leetcode-400-Nth-Digit/","content":"Find the $n$ th digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …\nNote:\nn is positive and will fit within the range of a 32-bit signed integer (n &lt; 231).\nExample 1:\nInput:3Output:3\nExample 2:\nInput:11Output:0Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\n\n\n\n先总结一下规律\n0\t\t1\t\t2\t\t3\t\t4\t\t5\t\t6\t\t7\t\t8\t\t9\t\t\t-&gt; start = 0, width = 1, count = 9---10\t11\t12\t13\t14\t15\t16\t17\t18\t19\t\t-&gt; start = 10, width = 2, count = 9020\t21\t22\t23\t24\t25\t26\t27\t28\t29...90\t91\t92\t93\t94\t95\t96\t97\t98\t99---100\t101\t102\t....\t\t\t\t\t\t\t\t\t\t\t\t\t-&gt; start = 100, width = 3, count = 900\n\n\n用start来保存每一个分组的开始的数组\n\n\n用width来保存每当前分组中，每一个数包涵几个数字\n\n\n用count来保存每一个分组中，一共有多少个数\n\n\n那么，每一个分组中，一共包含 count * width位数\n\n\n第一步，先找到n位于哪个分组，找到该分组的start\n\n\n第二步，找到n位于当前分组的那个数中\n\n\n第三步，确定n位是当前这数的第几个位\n\n\nclass Solution &#123;    public int findNthDigit(int n) &#123;        int start = 1;        int step = 1;        long count = 9;        while (n &gt; step * count) &#123;            n -= step * count;            step += 1;            count *= 10;            start *= 10;        &#125;        start += (n-1) / step; // n-1的目的是为了从0开始索引        String num = String.valueOf(start);        return num.charAt((n - 1) % step) - &#x27;0&#x27;;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 409 Longest Palindrome","url":"/article/leetcode-409-Longest-Palindrome/","content":"Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\nThis is case sensitive, for example &quot;Aa&quot; is not considered a palindrome here.\nNote:\nAssume the length of given string will not exceed 1,010.\nExample:\nInput:&quot;abccccdd&quot;Output:7Explanation:One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.\n\n\n用两个数组保存大写和小写的每个字母的count\n遍历所有字母的count，如果count是偶数，那就可以放在目标回文的两边，如果是奇数，可以取两个放在目标回文的两边。所以先ans += count/2， 返回ans*2\n要注意的是，如果存在奇数个的count，比如说1个，那么可以把他放到目标回文中间，那么ans += 1\n\n\nclass Solution &#123;    public int longestPalindrome(String s) &#123;        int[] lowercast = new int[26];        int[] uppercast = new int[26];        int count = 0;        int sole = 0;        for (int i=0; i&lt;s.length(); i++) &#123;            char c = s.charAt(i);            if (c &gt;= &#x27;a&#x27; &amp;&amp; c&lt;=&#x27;z&#x27;) &#123;                lowercast[c-&#x27;a&#x27;] ++;            &#125;            if (c &gt;=&#x27;A&#x27; &amp;&amp; c&lt;=&#x27;Z&#x27;) &#123;                uppercast[c-&#x27;A&#x27;] ++;            &#125;        &#125;        for (int i=0; i&lt;26; i++) &#123;            count += lowercast[i]/2;            count += uppercast[i]/2;            if (uppercast[i]%2 == 1 || lowercast[i]%2 == 1) &#123;                sole = 1;            &#125;        &#125;        return count*2 + sole;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 410 Split Array Largest Sum","url":"/article/leetcode-410-Split-Array-Largest-Sum/","content":"Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these msubarrays.\nNote:\nIf n is the length of array, assume the following constraints are satisfied:\n\n1 ≤ n ≤ 1000\n1 ≤ m ≤ min(50, n)\n\nExamples:\nInput:nums = [7,2,5,10,8]m = 2Output:18Explanation:There are four ways to split nums into two subarrays.The best way is to split it into [7,2,5] and [10,8],where the largest sum among the two subarrays is only 18.\n\nBinary Search\n\n最小的返回值是，当m为len(nums)的时候，max(nums)就是返回值。\n最大的返回值是，当m为1的时候，sum(nums)就是返回值。\n因此，我们可以在max(nums)和sum(nums)这个区间找到minimize largest sum\n\n采用二分查找的方法，取中位数mid。判断中位数是否能够成为每一个split的larget sum\n遍历nums数组，贪心的进行分组。如果累加到当前位置的和大于mid，就进行一个新的划分。并统计当前的划分个数。\n如果划分个数已经大于m。说明还有多的数。那么minimize largest sum应该大于mid，这样，left = mid+1。\n否则，就说明当前的数都已经有了划分，并且要么划分个数没有到达m个，或者刚好等于m个。\n\n如果是没有到达m个，就需要从其他的划分中取出数组成新的split，这样一来，当前的minimize largest sum 要进一步减小，right = mid\n\n如果已经到达了m个，第m个split中的sum可能这m个split的每一个sum都小于mid, 当前的minimize largest sum 要进一步缉拿小，right = mid\n\n\n\n\n\n\n\nclass Solution &#123;    public int splitArray(int[] nums, int m) &#123;        int max = 0;        long sum = 0;        for (int i: nums) &#123;            max = Math.max(max, i);            sum += i;        &#125;        long l = max;        long r = sum;                if (m == 1) return (int) sum;                while (l &lt; r) &#123;            long mid = l + (r - l)/2;            if (isLeft(nums, mid, m)) &#123;                l = mid + 1;            &#125;            else                 r = mid;        &#125;        return (int) l;    &#125;        public boolean isLeft(int[] nums, long target, int m) &#123;        int split = 1;        long sum = 0;        for (int i: nums) &#123;            sum += i;            if (sum &gt; target) &#123;                sum = i;                split ++;                if (split &gt; m) &#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 413 Arithmetic Slices","url":"/article/leetcode-413-Arithmetic-Slices/","content":"A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, these are arithmetic sequence:\n1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9\nThe following sequence is not arithmetic.\n1, 1, 2, 5, 7\nA zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.\nA slice (P, Q) of array A is called arithmetic if the sequence:\nA[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.\nThe function should return the number of arithmetic slices in the array A.\nExample:\nA = [1, 2, 3, 4]return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.\n\n\n要注意是连续的串\n当连续的3个数符合要求时，产生1结果\n当连续的4个数符合要求时，产生1+2个结果\n当连续的5个数符合要求时，产生1+2+3个结果\n当连续的n个数符合要求时，产生 1+2+3+……+n个结果\n用一个数cur来保存当前的串产生的结果，用sum来保存返回结果\n每当相连的三个数相等时，cur++， sum += cur\n\nclass Solution &#123;    public int numberOfArithmeticSlices(int[] A) &#123;        int sum = 0;        int cur = 0;        for (int i=1; i&lt;A.length-1; i++) &#123;            if(A[i] - A[i-1] == A[i+1] - A[i]) &#123;                cur += 1;                sum += cur;            &#125;            else &#123;                cur = 0;            &#125;        &#125;        return sum;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 414 Third Maximum Number","url":"/article/leetcode-414-Third-Maximum-Number/","content":"Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).\nExample 1:\nInput: [3, 2, 1]Output: 1Explanation: The third maximum is 1.\nExample 2:\nInput: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead.\nExample 3:\nInput: [2, 2, 3, 1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum.\n\nclass Solution &#123;    public int thirdMax(int[] nums) &#123;        if (nums.length == 0)            return 0;        if (nums.length == 1)            return nums[1];        if (nums.length == 2)            return Math.max(nums[0], nums[1]);                Integer a = null;        Integer b = null;        Integer c = null;                for (int i=0; i&lt;nums.length; i++) &#123;            Integer d = nums[i];                        if (d.equals(a) || d.equals(b) || d.equals(c))                continue;            if (a == null || d &gt; a) &#123;                c = b;                b = a;                a = d;            &#125;            else if ( b == null || d &gt; b) &#123;                c = b;                b = d;            &#125;            else if (c == null || d &gt; c) &#123;                c = d;            &#125;        &#125;        return c==null?a: c;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 415 Add Strings","url":"/article/leetcode-415-Add-Strings/","content":"Given two non-negative integers num1and num2 represented as string, return the sum of num1 and num2.\nNote:\n\nThe length of both num1 and num2 is &lt; 5100.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n\nclass Solution &#123;    public String addStrings(String num1, String num2) &#123;        int i=num1.length()-1;        int j=num2.length()-1;        int carry = 0;        StringBuilder ans = new StringBuilder();        while (i&gt;=0 || j&gt;=0) &#123;            int a = i&gt;=0? num1.charAt(i)-&#x27;0&#x27;: 0;            int b = j&gt;=0? num2.charAt(j)-&#x27;0&#x27;: 0;            int sum = (a+b+carry)%10;            carry = (a+b+carry)/10;            ans.insert(0, sum);            j--;            i--;        &#125;        if (carry != 0)            ans.insert(0, carry);        return ans.toString();    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 416 Partition Equal Subset Sum","url":"/article/leetcode-416-Partition-Equal-Subset-Sum/","content":"Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\nNote:\n\nEach of the array element will not exceed 100.\nThe array size will not exceed 200.\n\nExample 1:\nInput: [1, 5, 11, 5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11].\nExample 2:\nInput: [1, 2, 3, 5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets.\n\n\ndfs (time exceed)\n\nclass Solution &#123;    public boolean canPartition(int[] nums) &#123;        int sum = 0;        if (nums == null) return false;        for (int i: nums) sum += i;        if (sum % 2 != 0) return false;        sum = sum/2;        return helper(nums, sum, 0);    &#125;        public boolean helper(int[] nums, int target, int k) &#123;        if (target == 0)            return true;        if (target &lt; 0)            return false;        for (int i=k; i&lt;nums.length; i++) &#123;            if (helper(nums, target-nums[i], i+1))                return true;        &#125;        return false;    &#125;&#125;\n\n0/1 backpack\n\nclass Solution &#123;    public boolean canPartition(int[] nums) &#123;        int sum = 0;        if (nums == null) return false;        for (int i: nums) sum += i;        if (sum % 2 != 0) return false;        sum = sum/2;        boolean[] dp = new boolean[sum+1];        dp[0] = true;        // 如果采用以下方案，对每一个sum，nums[i]是有可能被复用的，      \t// 因此，需要把对nums的循环放到外层。        // for(int i=1; i&lt;= sum; i++) &#123;        //     for (int j: nums) &#123;        //         if (i-j &gt;= 0) &#123;        //             dp[i] = dp[i] || dp[i-j];        //         &#125;        //     &#125;        // &#125;              for (int i: nums) &#123;            // 同样，当对sum的循环是从小到大时，nums[i]同样也可以被服用，          \t// 比如，当nums[0] = 1时，后续的sum[]都会为true            // 从大到小的话，只有最小的dp[j-i]才有可能被设为true            for (int j=sum; j&gt;=i; j--) &#123;                if (j &gt;= i)                    dp[j] = dp[j] || dp[j-i];            &#125;        &#125;        return dp[sum];    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 417 Pacific Atlantic Water Flow","url":"/article/leetcode-417-Pacific-Atlantic-Water-Flow/","content":"Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.\nWater can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.\nFind the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\nNote:\n\nThe order of returned grid coordinates does not matter.\nBoth m and n are less than 150.\n\nExample:\nGiven the following 5x5 matrix:  Pacific ~   ~   ~   ~   ~        ~  1   2   2   3  (5) *       ~  3   2   3  (4) (4) *       ~  2   4  (5)  3   1  *       ~ (6) (7)  1   4   5  *       ~ (5)  1   1   2   4  *          *   *   *   *   * AtlanticReturn:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).\n\n\nbfs\n\n使用两个queue来分别保存已知的能够到达两个海岸坐标\n每次从queue中去一个出来，判断他的四周四个能否同样到达他所对应的海岸\n用两个矩阵来保存每个点能否到达对应的海岸\n\n\n\nclass Solution &#123;  public List&lt;int[]&gt; pacificAtlantic(int[][] matrix) &#123;    List&lt;int[]&gt; ans = new LinkedList&lt;int[]&gt;();    if (matrix.length == 0 || matrix[0].length == 0)      return ans;    int m = matrix.length;    int n = matrix[0].length;    int[][] dir = new int[][]&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;          boolean[][] pacific = new boolean[m][n];    boolean[][] atlantic = new boolean[m][n];          Queue&lt;int[]&gt; p = new LinkedList&lt;&gt;();    Queue&lt;int[]&gt; a = new LinkedList&lt;&gt;();          for (int i=0; i&lt;m; i++) &#123;      p.offer(new int[]&#123;i, 0&#125;);      pacific[i][0] = true;      a.offer(new int[]&#123;i, n-1&#125;);      atlantic[i][n-1] = true;    &#125;          for (int i=0; i&lt;n; i++) &#123;      p.offer(new int[]&#123;0, i&#125;);      pacific[0][i] = true;      a.offer(new int[]&#123;m-1, i&#125;);      atlantic[m-1][i] = true;    &#125;    bfs(matrix, pacific, p, dir);    bfs(matrix, atlantic, a, dir);    for (int i=0; i&lt;m; i++) &#123;      for (int j=0; j&lt;n; j++) &#123;        if (pacific[i][j] &amp;&amp; atlantic[i][j])          ans.add(new int[]&#123;i, j&#125;);      &#125;    &#125;    return ans;  &#125;  public void bfs(int[][] matrix, boolean[][] visit, Queue&lt;int[]&gt; q, int[][] dir) &#123;    while (!q.isEmpty()) &#123;      int[] idx = q.poll();      int x = idx[0];      int y = idx[1];      for (int[] d: dir) &#123;        int xx = x + d[0];        int yy = y + d[1];        if (xx&lt;0 || xx&gt;=matrix.length || yy&lt;0 || yy&gt;=matrix[0].length || visit[xx][yy])          continue;        if (matrix[xx][yy] &gt;= matrix[x][y])&#123;            q.offer(new int[]&#123;xx, yy&#125;);            visit[xx][yy] = true;        &#125;              &#125;    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 407 Trapping Rain Water II","url":"/article/leetcode-407-Trapping-Rain-Water-II/","content":"Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\nNote:\nBoth m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.\nExample:\nGiven the following 3x6 height map:[  [1,4,3,1,3,2],  [3,2,1,3,2,4],  [2,3,3,2,3,1]]Return 4.\n\nThe above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.\n\nAfter the rain, water is trapped between the blocks. The total volume of water trapped is 4.\n\n\n我们从matrix的四周出发，一次将四周的点都保存到一个qriorityqueue中\n每次从queue中取出height最小的点t，从t出发，遍历他的四周的点s，如果s&lt;t，说明s肯定能够trap住water的，而且，由于当前t是四周最小的点，所以s能够trap住(s-t)的water\n更新t中的height，将t加入pq中，直到所有的点都遍历完\n\nclass Solution &#123;    class Cell &#123;        int x;        int y;        int val;        public Cell(int x, int y, int val) &#123;            this.x = x;            this.y = y;            this.val = val;        &#125;    &#125;        public int trapRainWater(int[][] heightMap) &#123;        if (heightMap == null || heightMap.length == 0 || heightMap[0].length == 0)            return 0;        PriorityQueue&lt;Cell&gt; pq = new PriorityQueue(1, new Comparator&lt;Cell&gt;()&#123;            public int compare(Cell a, Cell b) &#123;                return a.val - b.val;            &#125;        &#125;);        int water = 0;        int m = heightMap.length;        int n = heightMap[0].length;        boolean[][] visit = new boolean[m][n];        int[][] directions = new int[][]&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;1, 0&#125;&#125;;        // 处理四周的cell        for (int i=0; i&lt;m; i++) &#123;            visit[i][0] = true;            visit[i][n-1] = true;            pq.offer(new Cell(i, 0, heightMap[i][0]));            pq.offer(new Cell(i, n-1, heightMap[i][n-1]));        &#125;                for (int i=0; i&lt;n; i++) &#123;            visit[0][i] = true;            visit[m-1][i] = true;            pq.offer(new Cell(0, i, heightMap[0][i]));            pq.offer(new Cell(m-1, i, heightMap[m-1][i]));        &#125;                while (! pq.isEmpty()) &#123;            Cell t = pq.poll();            for (int[] d: directions) &#123;                int x = d[0] + t.x;                int y = d[1] + t.y;                if (x&gt;=0 &amp;&amp; x &lt; m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; !visit[x][y]) &#123;                    visit[x][y] = true;                    water += Math.max(0, t.val - heightMap[x][y]);                    pq.offer(new Cell(x, y, Math.max(t.val, heightMap[x][y])));                &#125;            &#125;        &#125;        return water;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 419 Battleships in a Board","url":"/article/leetcode-419-Battleships-in-a-Board/","content":"Given an 2D board, count how many battleships are in it. The battleships are represented with\n&#x27;X&#x27;\ns, empty slots are represented with\n&#x27;.&#x27;\ns. You may assume the following rules:\n\nYou receive a valid board, made of only battleships or empty slots.\nBattleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\nAt least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n\nExample:\nX..X...X...X\nIn the above board there are 2 battleships.\nInvalid Example:\n...XXXXX...X\nThis is an invalid board that you will not receive - as battleships will always have a cell separating between them.\nFollow up:\nCould you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?\n\n\n每当遇到’x’的时候，判断它是不是它所在的battership的最左上角的那个，如果是的话，count ++\n\nclass Solution &#123;    public int countBattleships(char[][] board) &#123;        int count = 0;        if (board == null || board.length == 0 || board[0].length == 0)            return count;        for (int i=0; i&lt;board.length; i++) &#123;            for (int j=0; j&lt;board[0].length; j++) &#123;                if (board[i][j] == &#x27;X&#x27;) &#123;                    if (i-1&gt;=0 &amp;&amp; board[i-1][j] == &#x27;X&#x27;) &#123;                        continue;                    &#125;                    if (j-1&gt;=0 &amp;&amp; board[i][j-1] == &#x27;X&#x27;) &#123;                        continue;                    &#125;                    count ++;                &#125;            &#125;        &#125;        return count;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 421 Maximum XOR of Two Numbers in an Array","url":"/article/leetcode-421-Maximum-XOR-of-Two-Numbers-in-an-Array/","content":"Given a non-empty array of numbers, $a_0, a_1, …, a_{n-1}$, where $0 \\le a_i \\le 2^{32}$.\nFind the maximum result of $a_i \\ \\text{xor} \\  a_j$, where 0 ≤ i, j &lt; n.\nCould you do this in O(n) runtime?\nExample:\nInput: [3, 10, 5, 25, 2, 8]Output: 28Explanation: The maximum result is 5 ^ 25 = 28.\n\n\n用树状结构来保存每一个数。\n\nclass Node:    zero = None    one = None        class Solution(object):        def add(self, root, i):        node = root        for j in range(31, -1, -1):            mask = 1 &lt;&lt; j            left = mask &amp; i            if left:                if node.one == None:                    node.one = Node()                node = node.one            else:                if node.zero == None:                    node.zero = Node()                node = node.zero    def find(self, root, i):        ans = 0        node = root        for j in range(31, -1, -1):            mask = 1 &lt;&lt; j            left = i &amp; mask            if node.one and node.zero:                if left:                    node = node.zero                if not left:                    node = node.one                ans += mask            else:                if (node.one and not left) or (node.zero and left):                    ans += mask                node = node.one or node.zero        return ans    def findMaximumXOR(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        root = Node()        ans = 0        max_left = 0        candidate = []        for i in nums:            self.add(root, i)            left = math.ceil(0 if i == 0 else math.log(i, 2))            if left == max_left:                candidate.append(i)            if left &gt; max_left:                max_left = left                candidate = []                candidate.append(i)                        for i in nums:            ans = max(ans, self.find(root, i))        return ans\n","tags":["leetcode"]},{"title":"leetcode 424 Longest Repeating Character Replacement","url":"/article/leetcode-424-Longest-Repeating-Character-Replacement/","content":"Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\nNote:\nBoth the string’s length and k will not exceed 104.\nExample 1:\nInput:s = &quot;ABAB&quot;, k = 2Output:4Explanation:Replace the two &#x27;A&#x27;s with two &#x27;B&#x27;s or vice versa.\nExample 2:\nInput:s = &quot;AABABBA&quot;, k = 1Output:4Explanation:Replace the one &#x27;A&#x27; in the middle with &#x27;B&#x27; and form &quot;AABBBBA&quot;.The substring &quot;BBBB&quot; has the longest repeating letters, which is 4.\n\n\n用一个滑动窗口 &lt;start, end&gt; ，统计当前窗口中字符信息;\n窗口中的字符信息用一个count数组来保存，每当end向后移动，count[s[end]-‘A’] ++, 当start向后移动时， count[s[start]-‘A’] —;\n用一个currentMaxt来保存窗口在滑动过程中，出现字符最多的字符的数目。\n可以知道，满足要求的子串中，肯定包含了currentMax，这样的话，只需要在保存满足k限制的最大的窗口，就可以得到答案\n\nclass Solution &#123;    public int characterReplacement(String s, int k) &#123;        int[] count = new int[26];        int start = 0;        int end = 0;        int currentMax = 0;        int ans = 0;        for (end=0; end&lt;s.length(); end++) &#123;            int i = s.charAt(end)-&#x27;A&#x27;;            count[i] ++;            currentMax = Math.max(currentMax, count[i]);            while (end-start+1-currentMax &gt; k) &#123;                count[s.charAt(start)-&#x27;A&#x27;] --;                start ++;            &#125;            ans = Math.max(ans, end-start+1);        &#125;        return ans;    &#125;&#125;\n\npython version:\nclass Solution(object):    def characterReplacement(self, s, k):        &quot;&quot;&quot;        :type s: str        :type k: int        :rtype: int        &quot;&quot;&quot;        start, current_max, ans = 0, 0, 0        counter = collections.Counter()        for i in range(len(s)):            counter[s[i]] += 1            current_max = len(counter.most_common()) #             while (i - start + 1 - current_max) &gt; k:                counter[s[start]] -= 1                start += 1            ans = max(ans, i - start + 1)        return ans\n","tags":["leetcode"]},{"title":"leetcode 429 N-ary Tree Level Order Traversal","url":"/article/leetcode-429-N-ary-Tree-Level-Order-Traversal/","content":"Given an n-ary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).\nFor example, given a 3-ary tree:\n\nWe should return its level order traversal:\n[     [1],     [3,2,4],     [5,6]]\nNote:\n\nThe depth of the tree is at most 1000.\nThe total number of nodes is at most 5000.\n\n\nclass Solution(object):        def helper(self, ans, level, root):        if len(ans) == level:            ans.append([])        ans[level].append(root.val)        for child in root.children:            self.helper(ans, level+1, child)        def levelOrder(self, root):        &quot;&quot;&quot;        :type root: Node        :rtype: List[List[int]]        &quot;&quot;&quot;        ans = []        if root == None:            return ans        self.helper(ans, 0, root)        return ans\n","tags":["leetcode"]},{"title":"leetcode 42 接雨水","url":"/article/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/","content":"给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n示例:\n输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6\n\nclass Solution(object):    def trap(self, height):        &quot;&quot;&quot;        :type height: List[int]        :rtype: int        &quot;&quot;&quot;        left = [0]*len(height)        right = [0]*len(height)        h = 0        for i in range(0, len(height)):            left[i] = h            h = max(h, height[i])                    h = 0        for i in range(len(height)-1, -1, -1):            right[i] = h            h = max(h, height[i])        ans = 0        for i in range(len(height)):            ans += max(0, min(left[i], right[i]) - height[i])        return ans            \n","tags":["leetcode","数组"]},{"title":"leetcode 406 Queue Reconstruction by Height","url":"/article/leetcode-406-Queue-Reconstruction-by-Height/","content":"Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.\nNote:\nThe number of people is less than 1,100.\nExample\nInput:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]\n\nclass Solution(object):    def reconstructQueue(self, people):        &quot;&quot;&quot;        :type people: List[List[int]]        :rtype: List[List[int]]        &quot;&quot;&quot;        res = []        people_dic = &#123;&#125;        heights = []                for i, (height, k) in enumerate(people):            if height not in people_dic:                heights.append(height)                people_dic[height] = [(k, i)]            else:z                people_dic[height].append((k, i))                heights.sort()                for h in heights[::-1]:            t = people_dic[h]            t.sort()                        for (k,i) in t:                res.insert(t[0], people[t[1]])                return res\nKeyNotes:\n\n\n总的来说，先需要将每一个people按照height进行从大到小的排序，每一次先对height高的人分配位置。\n\n\n当有两个人的height一样高时，那就会根据k来进行从小到大的排序。\n\n\n比如说，[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]，那最先开始，我们需要对[7,0],[7,1]来排序，\n\n\n此时， ans = [[7, 0], [7, 1]]\n\n\n接下来对[5, 0], [5, 2]进行排序：\n\n对[5, 0]， 需要插入在ans的第0个位置， 得到ans = [[5,0] ,[7, 0], [7, 1]]\n对[5, 2]， 需要插入到ans的第2个位置， 得到ans = [[5, 0], [7, 0], [5, 2], [7, 1]]\n\nand so on …\n\n\n\n\n","tags":["leetcode"]},{"title":"leetcode 434 Number of Segments in a String","url":"/article/leetcode-434-Number-of-Segments-in-a-String/","content":"Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.\nPlease note that the string does not contain any non-printablecharacters.\nExample:\nInput: &quot;Hello, my name is John&quot;Output: 5\n\nclass Solution &#123;    public int countSegments(String s) &#123;        int count = 0;        for (int i=0; i&lt;s.length(); i++) &#123;            if (s.charAt(i) != &#x27; &#x27; &amp;&amp; (i==0 || s.charAt(i-1)==&#x27; &#x27;)) &#123;                count ++;            &#125;        &#125;        return count;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 435 无重叠区间","url":"/article/leetcode-435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/","content":"给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n注意:\n可以认为区间的终点总是大于它的起点。\n区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n示例 1:\n输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。\n示例 2:\n输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n示例 3:\n输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。\n\n\n慢一些\n\nclass Solution(object):    def eraseOverlapIntervals(self, intervals):        &quot;&quot;&quot;        :type intervals: List[List[int]]        :rtype: int        &quot;&quot;&quot;        if len(intervals) &lt;= 1:            return 0        intervals.sort(key = lambda x: (x[0], -x[1]))        end = intervals[0][1]        count = 0        for i in range(1, len(intervals)):            if end &gt; intervals[i][0]:                end = min(end, intervals[i][1])                count += 1            else:                end = max(end, intervals[i][1])        return count\n\n快一些\n\nclass Solution(object):    def eraseOverlapIntervals(self, intervals):        &quot;&quot;&quot;        :type intervals: List[List[int]]        :rtype: int        &quot;&quot;&quot;        intervals.sort(key=lambda x:(x[0],-x[1]))        count = 0        i = 0        for j in range(1,len(intervals)):            if intervals[i][1] &gt; intervals[j][1]:  # 删除最小的元素                count += 1                i = j            elif intervals[i][1] &gt; intervals[j][0]: # 将会删除中间元素                count += 1            else:                i = j        return count\n","tags":["leetcode"]},{"title":"leetcode 437 Path Sum III","url":"/article/leetcode-437-Path-Sum-III/","content":"You are given a binary tree in which each node contains an integer value.\nFind the number of paths that sum to a given value.\nThe path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).\nThe tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\nExample:\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8      10     /  \\    5   -3   / \\    \\  3   2   11 / \\   \\3  -2   1Return 3. The paths that sum to 8 are:1.  5 -&gt; 32.  5 -&gt; 2 -&gt; 13. -3 -&gt; 11\n\n\n写一个函数pathSumFrom，表示从当前node开始向下查找\n而pathSum表示的是，从这棵树中找。\n\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public int pathSum(TreeNode root, int sum) &#123;        if (root == null)            return 0;        return pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);    &#125;        public int pathSumFrom(TreeNode root, int sum) &#123;        if (root == null)            return 0;        return (sum == root.val ? 1: 0) + pathSumFrom(root.left, sum-root.val) + pathSumFrom(root.right, sum-root.val);    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 430 扁平化多级双向链表","url":"/article/leetcode-430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","content":"您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。\n示例:\n输入:\n1—2---3—4---5—6–NULL\n|\n7—8---9—10–NULL\n|\n11–12–NULL\n输出:\n1-2-3-7-8-11-12-9-10-4-5-6-NULL\n\n\n\n&quot;&quot;&quot;# Definition for a Node.class Node(object):    def __init__(self, val, prev, next, child):        self.val = val        self.prev = prev        self.next = next        self.child = child&quot;&quot;&quot;class Solution(object):    def flatten(self, head):        &quot;&quot;&quot;        :type head: Node        :rtype: Node        &quot;&quot;&quot;        if not head:            return head        pres = []        dump = Node(-1)        pre = dump        cur = None        pres.append(head)        while pres:            if not cur:                cur = pres.pop(-1)            while cur and not cur.child:                pre.next = cur                cur.prev = pre                pre = pre.next                cur = cur.next            if cur:                pre.next = cur                cur.prev = pre                pre = pre.next                if cur.next:                    pres.append(cur.next)                pres.append(cur.child)                cur.child = None                cur = None        dump.next.prev = None        return dump.next\n\n&quot;&quot;&quot;# Definition for a Node.class Node(object):    def __init__(self, val, prev, next, child):        self.val = val        self.prev = prev        self.next = next        self.child = child&quot;&quot;&quot;class Solution(object):    def flatten(self, head):        &quot;&quot;&quot;        :type head: Node        :rtype: Node        &quot;&quot;&quot;        if not head:            return head        stack = []        prev = None        stack.append(head)        while stack:            cur = stack.pop(-1)            if cur.next:                stack.append(cur.next)            if cur.child:                stack.append(cur.child)                cur.child = None            if prev:                prev.next = cur                cur.prev = prev                prev = prev.next            else:                prev = cur        return head\n","tags":["leetcode linkedlist"]},{"title":"leetcode 433 最小基因变化","url":"/article/leetcode-433-%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/","content":"一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 “A”, “C”, “G”, “T&quot;中的任意一个。假设我们要调查一个基因序列的变化。一次基因变化意味着这个基因序列中的一个字符发生了变化。例如，基因序列由&quot;AACCGGTT” 变化至 “AACCGGTA” 即发生了一次基因变化。与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。\n现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。\n注意:\n1.起始基因序列默认是合法的，但是它并不一定会出现在基因库中。\n2.所有的目标基因序列必须是合法的。\n3.假定起始基因序列与目标基因序列是不一样的。\n示例 1:\nstart: &quot;AACCGGTT&quot;end:   &quot;AACCGGTA&quot;bank: [&quot;AACCGGTA&quot;]返回值: 1\n示例 2:\nstart: &quot;AACCGGTT&quot;end:   &quot;AAACGGTA&quot;bank: [&quot;AACCGGTA&quot;, &quot;AACCGCTA&quot;, &quot;AAACGGTA&quot;]返回值: 2\n示例 3:\nstart: &quot;AAAAACCC&quot;end:   &quot;AACCCCCC&quot;bank: [&quot;AAAACCCC&quot;, &quot;AAACCCCC&quot;, &quot;AACCCCCC&quot;]返回值: 3\n\nclass Solution(object):    def minMutation(self, start, end, bank):        &quot;&quot;&quot;        :type start: str        :type end: str        :type bank: List[str]        :rtype: int        &quot;&quot;&quot;        def getCandidate(t, bank):            candidate = []            for i in range(len(t)):                for j in &#123;&#x27;A&#x27;, &#x27;C&#x27;, &#x27;G&#x27;, &#x27;T&#x27;&#125;:                    temp = t[:i] + j + t[i+1:]                    if temp in bank:                        candidate.append(temp)                        bank.remove(temp)            return candidate                if end not in bank:            return -1        bank = set(bank)        queue = collections.deque([(start, 0)])        while queue:            t, level = queue.popleft()            candidate = getCandidate(t, bank)            for c in candidate:                if c == end:                    return level+1                queue.append((c, level+1))        return -1\n","tags":["leetcode"]},{"title":"leetcode 440 字典序的第K小数字","url":"/article/leetcode-440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97/","content":"给定整数 n 和k，找到 1 到n 中字典序第 k 小的数字。注意：1 ≤ k ≤ n ≤ 109。\n示例 :\n输入:n: 13   k: 2输出:10解释:字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。\n\nclass Solution(object):    def findKthNumber(self, n, k):        &quot;&quot;&quot;        :type n: int        :type k: int        :rtype: int        &quot;&quot;&quot;        def getSteps(cur1, cur2, n):            steps = 0            while cur1 &lt;= n:                steps += min(n+1, cur2) - cur1                cur1 *= 10                cur2 *= 10            return steps                    cur = 1        k = k-1        while k &gt; 0:            steps = getSteps(cur, cur+1, n)            if k &gt;= steps:                cur = cur + 1                k = k - steps            else:                cur = cur * 10                k = k - 1        return cur\n","tags":["leetcode"]},{"title":"leetcode 44 通配符 II","url":"/article/leetcode-44-%E9%80%9A%E9%85%8D%E7%AC%A6-II/","content":"给定一个字符串 (s) 和一个字符模式 § ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。\n‘?’ 可以匹配任何单个字符。\n’*’ 可以匹配任意字符串（包括空字符串）。\n两个字符串完全匹配才算匹配成功。\n说明:\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。\n示例 1:\n输入:\ns = &quot;aa&quot;\np = &quot;a&quot;\n输出: false\n解释: “a” 无法匹配 “aa” 整个字符串。\n示例 2:\n输入:\ns = &quot;aa&quot;\np = &quot;&quot;\n输出: true\n解释: '’ 可以匹配任意字符串。\n示例 3:\n输入:\ns = &quot;cb&quot;\np = &quot;?a&quot;\n输出: false\n解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。\n示例 4:\n输入:\ns = &quot;adceb&quot;\np = &quot;ab&quot;\n输出: true\n解释: 第一个 ‘’ 可以匹配空字符串, 第二个 '’ 可以匹配字符串 “dce”.\n示例 5:\n输入:\ns = &quot;acdcb&quot;\np = &quot;a*c?b&quot;\n输入: false\n\n递归：\nclass Solution(object):    def isMatch(self, s, p):        &quot;&quot;&quot;        :type s: str        :type p: str        :rtype: bool        &quot;&quot;&quot;       \tif not s and not p:            return True        if s and not p:            return False        if p[0] == &#x27;?&#x27;:            return self.isMatch(s[1:], p[1:])        elif p[0] == &#x27;*&#x27;:            return self.isMatch(s, p[1:]) or self.isMatch(s[1:], p[1:]) or self.isMatch(s[1:], p)        else:            if s and s[0] == p[0] or (not s and p[0] == &#x27;*&#x27;):                return self.isMatch(s[1:], p[1:])               \n动态规划:\nm = len(p)+1n = len(s)+1dp = [[False]*m for _ in range(n)]dp[0][0] = Truefor j in range(1, m):    if p[j-1] == &#x27;*&#x27;:        dp[0][j] = dp[0][j-1]for i in range(1, n):    for j in range(1, m):        if p[j-1] == &#x27;*&#x27;:            dp[i][j] = dp[i][j-1] or dp[i-1][j] # *一个都不匹配 / *匹配多个        elif p[j-1] == s[i-1] or p[j-1] == &#x27;?&#x27;:            dp[i][j] = dp[i-1][j-1]return dp[-1][-1]\n","tags":["leetcode","递归","字符串","动态规划"]},{"title":"leetcode 436 寻找右区间","url":"/article/leetcode-436-%E5%AF%BB%E6%89%BE%E5%8F%B3%E5%8C%BA%E9%97%B4/","content":"给定一组区间，对于每一个区间 i，检查是否存在一个区间 j，它的起始点大于或等于区间 i 的终点，这可以称为 j 在 i 的“右侧”。\n对于任何区间，你需要存储的满足条件的区间 j 的最小索引，这意味着区间 j 有最小的起始点可以使其成为“右侧”区间。如果区间 j 不存在，则将区间 i 存储为 -1。最后，你需要输出一个值为存储的区间值的数组。\n注意:\n你可以假设区间的终点总是大于它的起始点。\n你可以假定这些区间都不具有相同的起始点。\n示例 1:\n输入: [ [1,2] ]输出: [-1]解释:集合中只有一个区间，所以输出-1。\n示例 2:\n输入: [ [3,4], [2,3], [1,2] ]输出: [-1, 0, 1]解释:对于[3,4]，没有满足条件的“右侧”区间。对于[2,3]，区间[3,4]具有最小的“右”起点;对于[1,2]，区间[2,3]具有最小的“右”起点。\n示例 3:\n输入: [ [1,4], [2,3], [3,4] ]输出: [-1, 2, -1]解释:对于区间[1,4]和[3,4]，没有满足条件的“右侧”区间。对于[2,3]，区间[3,4]有最小的“右”起点。\n\n\n二重遍历 (容易超时)\n\nclass Solution(object):    def findRightInterval(self, intervals):        &quot;&quot;&quot;        :type intervals: List[List[int]]        :rtype: List[int]        &quot;&quot;&quot;        ans = []        for i in intervals:            idx = -1            for t, j in enumerate(intervals):                if i == j:                    continue                else:                    if j[0] &gt;= i[1] and (idx==-1 or intervals[idx][0] &gt; j[0]):                        idx = t            ans.append(idx)        return ans \n\n二分法\n\n","tags":["leetcode"]},{"title":"leetcode 438 找到字符串中所有字母异位词","url":"/article/leetcode-438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","content":"给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。\n说明：\n字母异位词指字母相同，但排列不同的字符串。\n不考虑答案输出的顺序。\n示例 1:\n输入:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;输出:[0, 6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。\n示例 2:\n输入:s: &quot;abab&quot; p: &quot;ab&quot;输出:[0, 1, 2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。\n\n","tags":["leetcode"]},{"title":"leetcode 446 等差数列划分 II - 子序列","url":"/article/leetcode-446-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86-II---%E5%AD%90%E5%BA%8F%E5%88%97/","content":"如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。例如，以下数列为等差数列:\n1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9\n以下数列不是等差数列。\n1, 1, 2, 5, 7\n数组 A 包含 N 个数，且索引从 0 开始。该数组子序列将划分为整数序列 $(P_0, P_1, …, P_k)$，P 与 Q 是整数且满足 $0 ≤ P_0 &lt; P_1 &lt; … &lt; P_k &lt; N$。\n如果序列 $A[P_0]，A[P_1]，…，A[P_{k-1}]，A[P_k]$ 是等差的，那么数组 A 的子序列$ (P_0，P_1，…，P_K)$ 称为等差序列。值得注意的是，这意味着 k ≥ 2。\n函数要返回数组 A 中所有等差子序列的个数。\n输入包含 N 个整数。每个整数都在 $-2^{31}$ 和 $2^{31-1}$ 之间，另外 0 ≤ N ≤ 1000。保证输出小于 $2^{31-1}$。\n示例：\n输入：\t[2, 4, 6, 8, 10]输出：\t7解释：      所有的等差子序列为：      [2,4,6]      [4,6,8]      [6,8,10]      [2,4,6,8]      [4,6,8,10]      [2,4,6,8,10]      [2,6,10]\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\nclass Solution(object):    def numberOfArithmeticSlices(self, A):        &quot;&quot;&quot;        :type A: List[int]        :rtype: int        &quot;&quot;&quot;        distList = [dict() for i in range(len(A))]        ans = 0        for i in range(1, len(A)):            for j in range(i):                delta = A[i] - A[j]                if delta not in distList[i]:                    distList[i][delta] = 0                distList[i][delta] += 1                if delta in distList[j]:                    distList[i][delta] += distList[j][delta]                    ans += distList[j][delta]        return ans\n","tags":["leetcode"]},{"title":"leetcode 448 Find All Numbers Disappeared in an Array","url":"/article/leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/","content":"Given an array of integers where 1 ≤ a[i] ≤ n (n= size of array), some elements appear twice and others appear once.\nFind all the elements of [1, n] inclusive that do not appear in this array.\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\nExample:\nInput:[4,3,2,7,8,2,3,1]Output:[5,6]\n\n\n不允许用额外的空间，这样一来，只能用nums数组当做哈希表。\n遍历nums中的每一个数，如果nums[i]是一个正数，就把nums中第nums[i]-1位置的数字变为负数\n最终遍历一遍nums，所有为负的地方表示其index+1出现过\n\nclass Solution(object):    def findDisappearedNumbers(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[int]        &quot;&quot;&quot;        for i in range(len(nums)):            idx = abs(nums[i]) - 1            if nums[idx] &lt; 0:                continue            else:                nums[idx] = -1 * nums[idx]        ans = []        for i in range(len(nums)):            if nums[i] &gt; 0:                ans.append(i+1)        return ans\n","tags":["leetcode"]},{"title":"leetcode 441 排列硬币","url":"/article/leetcode-441-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/","content":"你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。给定一个数字 n，找出可形成完整阶梯行的总行数。n 是一个非负整数，并且在32位有符号整型的范围内。\n示例 1:n = 5硬币可排列成以下几行:¤¤ ¤¤ ¤因为第三行不完整，所以返回2.\n示例 2:n = 8硬币可排列成以下几行:¤¤ ¤¤ ¤ ¤¤ ¤因为第四行不完整，所以返回3.\n\n\n二分查找\n\nclass Solution(object):    def arrangeCoins(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: int        &quot;&quot;&quot;        if n &lt;= 1:            return n        left = 1        right = n        while left &lt; right:            mid = (left + right) &gt;&gt; 1            if mid*(mid+1)//2 == n:                return mid            if mid*(mid+1)//2 &lt; n:                left = mid + 1            else:                right = mid        return left-1 # 考虑有n=4的情况，这个时候，left==right==3        \n\n\nMath\n$$\n\\frac{k\\times(k+1)}{2} = n \\\nk^2 \\times k - 2n = 0 \\\nk_1 = \\frac{-b + \\sqrt{b^2-4ac}}{2a} = \\frac{-1+\\sqrt{1+8n}}{2} \\\nk_2 = \\frac{-b + \\sqrt{b^2-4ac}}{2a} = \\frac{-1-\\sqrt{1+8n}}{2} &lt;0\n$$\n\nclass Solution(object):    def arrangeCoins(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: int        &quot;&quot;&quot;        return int((math.sqrt(1+8*n)-1)//2)        \n","tags":["leetcode"]},{"title":"leetcode 452 Minimum Number of Arrows to Burst Balloons","url":"/article/leetcode-452-Minimum-Number-of-Arrows-to-Burst-Balloons/","content":"There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.\nAn arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xendbursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.\nExample:\nInput:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).\n\n总的来说，就是在水平方向上🏹，用最少的箭射吧全部的区间射掉。\n先按数组中的第一个元素对区间排序\n设定一个当前一箭能够着的最高的位置\n遍历每一个区间，如果当前区间的开始点大于当前一箭能够着的最高点，就说明当前这个区间需要再用一把箭，ans ++，且令下一把箭能够够着的最高点设为当前区间的结束点。\n如果当前区间的开始点小于前一箭能够够着的最高点，说明前一把箭能够射中当前区间，此时需要更新前一把在保证射掉当前区间的同时，能够够着的最高点，也就是需要比较前一把箭的最高点和当前区间的结束点的位置，如果当前区间结束点的位置要小于前一把箭的最高点，则将前一把箭的组高点设为当前区间的结束点。\nclass Solution(object):    def findMinArrowShots(self, points):        &quot;&quot;&quot;        :type points: List[List[int]]        :rtype: int        &quot;&quot;&quot;        points = sorted(points, key=lambda x:x[0])        highest = -float(&#x27;inf&#x27;)        ans = 0        for start, end in points:            if highest &lt; start:                ans += 1                highest = end            elif highest &gt; end:                highest = end        return ans\nSimilar Question:\n435 Non-overlapping Intervals &lt;- very similar😈\n56 Merge Intervals &lt;- very similar😈\n252 Meeting Rooms\n253 Meeting Rooms II\n","tags":["leetcode"]},{"title":"leetcode 456 132 Pattern","url":"/article/leetcode-456-132-Pattern/","content":"Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\nNote: n will be less than 15,000.\nExample 1:\nInput: [1, 2, 3, 4]Output: FalseExplanation: There is no 132 pattern in the sequence.\nExample 2:\nInput: [3, 1, 4, 2]Output: TrueExplanation: There is a 132 pattern in the sequence: [1, 4, 2].\nExample 3:\nInput: [-1, 3, 2, 0]Output: TrueExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n\n从右到左遍历\n使用一个stack来保存数据\n每当有一个数大于stack中最末尾的数时，popstack直到stack中末尾的数大于当前数\n把当前数放入stack\n如果当前数小于stack中的末尾的数时，直接pop进stack中\n\n这样一来stack中保持降序排列，每次有一个数大于stack最末尾的数时，我们找到这些降序排列的数中，最大的一个小于当前数的数，标记为samllest。\n所以，当有一个数小于smallest时，栈中肯定有一个数大于samllest。这样就说明存在132模式。\nclass Solution(object):    def find132pattern(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: bool        &quot;&quot;&quot;        import sys        smallest = -sys.maxint        stack = []        for i in nums[::-1]:            if i &lt; smallest:                return True            else:                while stack and i &gt; stack[-1]:                    smallest = stack.pop()                stack.append(i)        return False                \n","tags":["leetcode array"]},{"title":"leetcode 457 Circular Array Loop","url":"/article/leetcode-457-Circular-Array-Loop/","content":"You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it’s negative (-k), move backward k steps. Since the array is circular, you may assume that the last element’s next element is the first element, and the first element’s previous element is the last element.\nDetermine if there is a loop (or a cycle) in nums. A cycle must start and end at the same index and the cycle’s length &gt; 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements.\nExample 1:\nInput: [2,-1,1,2,2]Output: trueExplanation: There is a cycle, from index 0 -&gt; 2 -&gt; 3 -&gt; 0. The cycle&#x27;s length is 3.\nExample 2:\nInput: [-1,2]Output: falseExplanation: The movement from index 1 -&gt; 1 -&gt; 1 ... is not a cycle, because the cycle&#x27;s length is 1. By definition the cycle&#x27;s length must be greater than 1.\nExample 3:\nInput: [-2,1,-1,-2,-2]Output: falseExplanation: The movement from index 1 -&gt; 2 -&gt; 1 -&gt; ... is not a cycle, because movement from index 1 -&gt; 2 is a forward movement, but movement from index 2 -&gt; 1 is a backward movement. All movements in a cycle must follow a single direction.\nNote:\n\n-1000 ≤ nums[i] ≤ 1000\nnums[i] ≠ 0\n1 ≤ nums.length ≤ 5000\n\n\n遍历nums，对每一个nums[i]开始循环遍历他的下一跳。\n中断条件包括：\n\n当这一跳的方向和初始的方向不一致，设初始的数为num，当前这一跳的数为nums[i]，那么当num*nums[i] &lt;=0时，中断。\n当这一跳调到自己时，中断。即nums[i] % len(nums) == 0时，中断。\n当这一跳曾经跳过时，中断。在跳的过程中，我们用标记来标注跳过的位置，如果当前这一跳被标记上跳过了，那么中断。\n\nclass Solution(object):    def circularArrayLoop(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: bool        &quot;&quot;&quot;        for i, num in enumerate(nums):            mark = str(i) # 注意这里用到的标记是str(i)            while (type(nums[i]) == int) and (num * nums[i] &gt; 0) and (nums[i] % len(nums) != 0):                jump = nums[i]                nums[i] = mark # 将跳过的位置标进行标记                i = (jump + i) % len(nums)            if nums[i] == mark:                return True        return False\n","tags":["leetcode array"]},{"title":"leetcode 458 Poor Pigs","url":"/article/leetcode-458-Poor-Pigs/","content":"If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the poisonous bucket within p minutes? There is exactly one bucket with poison.\n\nA pig can be allowed to drink simultaneously on as many buckets as one would like, and the feeding takes no time.\nAfter a pig has instantly finished drinking buckets, there has to be a cool down time of m minutes. During this time, only observation is allowed and no feedings at all.\nAny given bucket can be sampled an infinite number of times (by an unlimited number of pigs).\n\n\n假设现在一共有25个桶，2只猪，每只猪在喝完水后有15分钟的观察时间，一共有60分钟的时间供我们找出有毒的水桶。这样就意味着我们一共可以进行四轮验证。\n对着25桶水，我们这样对它们进行排列：\n1\t\t2\t\t3\t\t4\t\t56\t\t7\t\t8\t\t9\t\t1011\t12\t13\t14\t1516\t17\t18\t19\t2021\t22\t23\t24\t25\n对于第一只猪，我们按行来验证，第一次给它喝下第一行的水，第二次给它喝下第二行的水。\n在对第一只猪操作的同时，我们在第一次为第二只猪喝下第一列的水，第二次给它喝下第二列的水。\n假设第一只猪在第i次喝完水后挂了，第二只在第j次喝完水后挂了，那么有毒的水就是第i，j个桶。\n如果第一只猪在四次实验后还活着，说明有毒的水在第5行。也就是说，虽然我们只能验证4轮，但是我们可以设置5行(列)\n那么，每一只猪相当于是一个维度。每一个维度上，一共有(验证次数+1)个桶组成一个超立方体。\nclass Solution(object):    def poorPigs(self, buckets, minutesToDie, minutesToTest):        &quot;&quot;&quot;        :type buckets: int        :type minutesToDie: int        :type minutesToTest: int        :rtype: int        &quot;&quot;&quot;        test_times = minutesToTest//minutesToDie        pig = 0        while (test_times + 1) ** pig &lt; buckets:            pig += 1        return pig\n","tags":["leetcode math"]},{"title":"leetcode 459 Repeated Substring Pattern","url":"/article/leetcode-459-Repeated-Substring-Pattern/","content":"Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\nExample 1:\nInput: &quot;abab&quot;Output: TrueExplanation: It&#x27;s the substring &quot;ab&quot; twice.\nExample 2:\nInput: &quot;aba&quot;Output: False\nExample 3:\nInput: &quot;abcabcabcabc&quot;Output: TrueExplanation: It&#x27;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.)\n\n对s+s去头和去末尾，在其中找s。\n","tags":["leetcode string"]},{"title":"leetcode 461 Hamming Distance","url":"/article/leetcode-461-Hamming-Distance/","content":"The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, calculate the Hamming distance.\nNote:\n0 ≤ x, y &lt; $2^{31}$.\nExample:\nInput: x = 1, y = 4Output: 2Explanation:1   (0 0 0 1)4   (0 1 0 0)       ↑   ↑The above arrows point to positions where the corresponding bits are different.\n\n\n这里给定了是32位的数，对x异或y中的每一位进行累加即可\n\nclass Solution(object):    def hammingDistance(self, x, y):        &quot;&quot;&quot;        :type x: int        :type y: int        :rtype: int        &quot;&quot;&quot;        count = 0        for i in range(32):            mask = 1 &lt;&lt; i            count += 1 if ((x ^ y) &amp; mask) &gt; 0 else 0        return count\n\n如果没有给定数的范围，可以用最小二乘法来求\n\nclass Solution(object):    def hammingDistance(self, x, y):        &quot;&quot;&quot;        :type x: int        :type y: int        :rtype: int        &quot;&quot;&quot;        if x == y:            return 0                xor = x ^ y        count = 0        while xor != 0:            if xor % 2 == 1:                count += 1            xor = xor // 2        return count\n","tags":["leetcode bit-manipulation"]},{"title":"leetcode 463 Island Perimeter","url":"/article/leetcode-463-Island-Perimeter/","content":"You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.\nExample:\nInput:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Output: 16Explanation: The perimeter is the 16 yellow stripes in the image below:\n\n最简单的答案：遍历matrix，一次判断当前cell和他四周的cell之间的关系。\nclass Solution(object):    def islandPerimeter(self, grid):        &quot;&quot;&quot;        :type grid: List[List[int]]        :rtype: int        &quot;&quot;&quot;        m = len(grid)        n = len(grid[0])        perimeter = 0        for i in range(m):            for j in range(n):                if grid[i][j]:                    if i==0:                        perimeter += 1                    if j==0:                        perimeter += 1                    if i==m-1:                        perimeter += 1                    if j==n-1:                        perimeter += 1                                        if i-1&gt;=0 and not grid[i-1][j]:                        perimeter += 1                    if i+1&lt;m and not grid[i+1][j]:                        perimeter += 1                    if j-1&gt;=0 and not grid[i][j-1]:                        perimeter += 1                    if j+1&lt;n and not grid[i][j+1]:                        perimeter += 1        return perimeter                    \n\n\nMore Concise\n\nclass Solution:    def islandPerimeter(self, grid):        if not grid:            return 0        N = len(grid)        M = len(grid[0])        ans = 0        for i in range(N):            for j in range(M):                for k in [(-1, 0), (0, 1), (1, 0), (0, -1)]:                    if i+k[0] &lt; 0 or i + k[0] &gt;= N or j+k[1] &lt; 0 or j+k[1] &gt;= M or grid[i+k[0]][j+k[1]] == 0:                        ans += 1        return ans\n","tags":["leetcode matrix"]},{"title":"leetcode 464 Can I Win","url":"/article/leetcode-464-Can-I-Win/","content":"In the “100 game,” two players take turns adding, to a running total, any integer from 1…10. The player who first causes the running total to reach or exceed 100 wins.\nWhat if we change the game so that players cannot re-use integers?\nFor example, two players might take turns drawing from a common pool of numbers of 1…15 without replacement until they reach a total &gt;= 100.\nGiven an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.\nYou can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.\nExample\nInput:maxChoosableInteger = 10desiredTotal = 11Output:falseExplanation:No matter which integer the first player choose, the first player will lose.The first player can choose an integer from 1 up to 10.If the first player choose 1, the second player can only choose integers from 2 up to 10.The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.Same with other integers chosen by the first player, the second player will always win.\n\n\n假设有一个函数dfs，它返回当前的剩余数字集合下，我能否一定能赢。\n那么他的处理过程是，他在剩余数字集合抽取一个数字，并将desireTotal减掉这个数字，表示我当前选择这个数字，然后对手调用这个函数，判断他能否一定能赢。\n\n如果对手调用这个函数后，返回false，则说明我在选择这个数字后，对手肯定输了，那么我肯定赢了。\n如果对手调用这个函数后，返回true，则说明，我这么选对手能赢，那么我需要换一个数字选。\n当所有的可选则的数字我都选了一遍后，我都赢不了，那么我就肯定赢不了了。\n\n\n那么对于剩下的数字集合，我们需要用一个变量每个数字的状态，判断它是否可以选择。由于题目中限定了最多不超过20，这样一来，我们可以用一个整数key来存每个数字的状态，这个key中，第i位是否为1来判断数字i是否可选。\n那么对于一个给定的desireTotal，我们如何判断当前我的输赢状态呢？\n\n首先，如果在dfs中，假设经过若干轮迭代，当前轮到我选择数组，此时，我发现desireTotal小于等于0，这就说明，在上一轮对手已经让场面上的数字之和大于desireTotal了，那么对手已经赢了，我输了，此时，dfs应该返回false\n如果desireTotal大于0，此时，我需要从剩余数字集合中依次抽取数字，进行判断。\n\n\n\n\nclass Solution &#123;    public boolean canIWin(int maxChoosableInteger, int desiredTotal) &#123;        // desiredTotal &lt; 2 肯定我能赢        if (desiredTotal &lt;2 )            return true;        // 总共的可选数字加起来都小于desiredTotal，两个人都不能赢        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 &lt; desiredTotal)            return false;        HashMap&lt;Integer, Boolean&gt; map = new HashMap&lt;&gt;();        int key = 0;        // key中的第位为1，表明i可以选择。        for (int i=1; i&lt;= maxChoosableInteger; i++) &#123;            key |= (1 &lt;&lt; i);        &#125;        return dfs(map, key, maxChoosableInteger, desiredTotal);    &#125;        boolean dfs(HashMap&lt;Integer, Boolean&gt; map, int key, int maxChoosableInteger, int desiredTotal) &#123;        if (map.containsKey(key))            return map.get(key);      \t// 当desiredTotal小于等于0时，说明对方在上一把已经赢了        if (desiredTotal &lt;= 0)            return false;      \t// 遍历取走一个，判断能否赢        for (int i=1; i&lt;=maxChoosableInteger; i++) &#123;            if ( (key &amp; (1&lt;&lt;i)) != 0) &#123;                key = key - (1&lt;&lt;i);                if (!dfs(map, key, maxChoosableInteger, desiredTotal-i)) &#123;                    // 这里注意将key放入map，注意key要还原成输入的样子                    key = key + (1&lt;&lt;i);                    map.put(key, true);                    return true;                &#125;                // 这里也需要注意                key = key + (1&lt;&lt;i);            &#125;        &#125;        map.put(key, false);        return false;    &#125;&#125;\n\nPython Version:\n\n注意这里是无放回的要求，所以需要记录下每一个数的状态。\n\nclass Solution(object):    def canIWin(self, maxChoosableInteger, desiredTotal):        &quot;&quot;&quot;        :type maxChoosableInteger: int        :type desiredTotal: int        :rtype: bool        &quot;&quot;&quot;        if desiredTotal &gt; maxChoosableInteger * (maxChoosableInteger + 1) / 2:            return False        if desiredTotal &lt;= maxChoosableInteger:            return True        memo = &#123;&#125;        key = range(1, maxChoosableInteger+1, 1)        return self.helper(maxChoosableInteger, desiredTotal, memo, key)    def helper(self, maxChoosableInteger, desiredTotal, memo, key):        idx = str(key)        if idx in memo:            return memo[idx]        if desiredTotal &lt;=0:            return False        if key[-1] &gt; desiredTotal:            return True        for i in range(len(key)):            t = key[:i] + key[i+1:]            if not self.helper(maxChoosableInteger, desiredTotal-key[i], memo, t):                memo[idx] = True                return True        memo[idx] = False        return False\n\nbit manipulation\n\nclass Solution(object):    def canIWin(self, maxChoosableInteger, desiredTotal):        &quot;&quot;&quot;        :type maxChoosableInteger: int        :type desiredTotal: int        :rtype: bool        &quot;&quot;&quot;        if desiredTotal &gt; maxChoosableInteger * (maxChoosableInteger + 1) / 2:            return False        if desiredTotal &lt;= maxChoosableInteger:            return True        memo = &#123;&#125;        key = 0 # 每一位上如果是0，表示没有被用过        return self.helper(maxChoosableInteger, desiredTotal, memo, key)    def helper(self, maxChoosableInteger, desiredTotal, memo, key):        if key in memo:            return memo[key]        if desiredTotal &lt;=0:            return False        for i in range(maxChoosableInteger):            if not (key &amp; (1&lt;&lt;i)):                # 注意这里是desiredTotal-(i+1)                if not self.helper(maxChoosableInteger, desiredTotal-(i+1), memo, key ^ (1 &lt;&lt; i)):                    memo[key] = True                    return True        memo[key] = False        return False\n","tags":["leetcode"]},{"title":"leetcode 467 Unique Substrings in Wraparound String","url":"/article/leetcode-467-Unique-Substrings-in-Wraparound-String/","content":"Consider the string s to be the infinite wraparound string of “abcdefghijklmnopqrstuvwxyz”, so s will look like this: “…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd…”.\nNow we have another string p. Your job is to find out how many unique non-empty substrings of pare present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.\nNote: p consists of only lowercase English letters and the size of p might be over 10000.\nExample 1:\nInput: &quot;a&quot;Output: 1Explanation: Only the substring &quot;a&quot; of string &quot;a&quot; is in the string \u0010s.\nExample 2:\nInput: &quot;cac&quot;Output: 2Explanation: There are two substrings &quot;a&quot;, &quot;c&quot; of string &quot;cac&quot; in the string s.\nExample 3:\nInput: &quot;zab&quot;Output: 6Explanation: There are six substrings &quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, &quot;zab&quot; of string &quot;zab&quot; in the string s.\n\n\n\n判断是否是连续的字符: (ord(i) - ord(i-1)) % 26 == 1\n\n\n有可能有重复的substring。比如，如果出现 abc和abcd的话，我们只需要计入abcd产生的substring\n\n\n对于每遇到的一个字符，确定以该字符结尾连续substring有多少个即可。比如，对于abcd，\n\na结尾：1\nb结尾：2\nc结尾：3\nd结尾：4\n总共：1+2+3+4 = 10，即为所求的abcd产生的有序的子串的个数\n\nclass Solution(object):    def findSubstringInWraproundString(self, p):        &quot;&quot;&quot;        :type p: str        :rtype: int        &quot;&quot;&quot;        dic = &#123;i:1 for i in p&#125;        l = 1        for i, j in zip(p, p[1:]): # 遍历判断前后两者的关系的时候，可以用这种方式            if (ord(j) - ord(i)) % 26 == 1:                l += 1            else:                l = 1            dic[j] = max(dic[j], l) # 只保存以j结尾产生的最长的串        return sum(dic.values())\n\n","tags":["leetcode string"]},{"title":"leetcode 442 Find All Duplicates in an Array","url":"/article/leetcode-442-Find-All-Duplicates-in-an-Array/","content":"Given an array of integers, 1 ≤ a[i] ≤ n (n= size of array), some elements appear twice and others appear once.\nFind all the elements that appear twice in this array.\nCould you do it without extra space and in O(n) runtime?\nExample:\nInput:[4,3,2,7,8,2,3,1]Output:[2,3]\n\n\n在一个长度为n的数组中，每一个数的范围为1~n。其中存在一些数出现的次数为两次，要求找出这些数。\n如果空间要求不为O(1)的话，可以通过哈希表的方式在做。但是现在空间要求为O(1)，我们不能额外建立哈希表。考虑到nums数组的长度为n，他本身就适合做哈希表。\n我们从0~n-1遍历nums的每一个元素，假设当前正在遍历第i个元素，nums[i] = x，那么为了记录下x出现过一次，我们将nums[x-1]变为乘以-1，表示x出现过一次。\n因此，我们每一次遍历到一个新的元素nums[j]时，我们判断nums[nums[j]-1]的位置是否为负数，如果是负数的话，就表示nums[j]-1曾经出现过，那么将其加入到ans集合中。\n\nclass Solution(object):    def findDuplicates(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[int]        &quot;&quot;&quot;        ans = []        for i in range(len(nums)):            idx = abs(nums[i])-1            if nums[idx] &lt; 0:                ans.append(idx+1)            else:                nums[idx] *= -1        return ans        \n","tags":["leetcode"]},{"title":"leetcode 451 Sort Characters By Frequency","url":"/article/leetcode-451-Sort-Characters-By-Frequency/","content":"Given a string, sort it in decreasing order based on the frequency of characters.\nExample 1:\nInput:&quot;tree&quot;Output:&quot;eert&quot;Explanation:&#x27;e&#x27; appears twice while &#x27;r&#x27; and &#x27;t&#x27; both appear once.So &#x27;e&#x27; must appear before both &#x27;r&#x27; and &#x27;t&#x27;. Therefore &quot;eetr&quot; is also a valid answer.\nExample 2:\nInput:&quot;cccaaa&quot;Output:&quot;cccaaa&quot;Explanation:Both &#x27;c&#x27; and &#x27;a&#x27; appear three times, so &quot;aaaccc&quot; is also a valid answer.Note that &quot;cacaca&quot; is incorrect, as the same characters must be together.\nExample 3:\nInput:&quot;Aabb&quot;Output:&quot;bbAa&quot;Explanation:&quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.Note that &#x27;A&#x27; and &#x27;a&#x27; are treated as two different characters.\n\n\n非常自然的就想到了用Collections中的Counter来计数\nCounter中有一个most_common()函数按照出现的次数进行排序\n\nclass Solution(object):    def frequencySort(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: str        &quot;&quot;&quot;        counter = collections.Counter(s)        ans = &#x27;&#x27;        for (c, n) in counter.most_common():            ans += c * n        return ans\n","tags":["leetcode"]},{"title":"leetcode 450 Delete Node in a BST","url":"/article/leetcode-450-Delete-Node-in-a-BST/","content":"Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\nBasically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.\n\nNote: Time complexity should be O(height of tree).\nExample:\nroot = [5,3,6,2,4,null,7]key = 3    5   / \\  3   6 / \\   \\2   4   7Given key to delete is 3. So we find the node with value 3 and delete it.One valid answer is [5,4,6,2,null,null,7], shown in the following BST.    5   / \\  4   6 /     \\2       7Another valid answer is [5,2,6,null,4,null,7].    5   / \\  2   6   \\   \\    4   7\n\n在一颗二叉搜索树中，去掉指定的数，构建新的二叉搜索树。\n\n我们假设deleteNode函数返回已经修改的二叉搜索树的子树，我们递归的寻找需要删除的那个root\n当我们找到了这个root之后，判断这个root是否只有一个左子树或者右子树，这种情况下，只要把当前的root替换为其左子树的root或者右子树的root即可\n如果我们要delete的这个root有左右子树都有\n\n那么我么去他的左子树，找到他左子树的最大的数，令root的值等于该最大值，并且在其root的左子树中delete该最大值节点\n或者我们去他的右子树，找到他右子树的最小的数，令root的值等于该最小值，并且在其root的右子树中delete该最小节点\n\n\n\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def deleteNode(self, root, key):        if not root:            return root        elif root.val &lt; key:            root.right = self.deleteNode(root.right, key)        elif root.val &gt; key:            root.left = self.deleteNode(root.left, key)        else:            if not root.left:                return root.right            if not root.right:                return root.left            t = root.left            while t.right:                t = t.right            root.val = t.val            root.left = self.deleteNode(root.left, t.val)        return root\n","tags":["leetcode"]},{"title":"leetcode 491 递增子序列","url":"/leetcode/leetcode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","content":"\n给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。\n示例:\n输入: [4, 6, 7, 7]\n输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n说明:\n给定数组的长度不会超过15。\n数组中的整数范围是 [-100,100]。\n给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。\n链接：https://leetcode-cn.com/problems/increasing-subsequences\n\nclass Solution(object):    def findSubsequences(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        ans = []        self.bfs(nums, 0, len(nums), ans, [])        return ans    def bfs(self, nums, start, end, ans, temp):        if start &lt;= end and len(temp) &gt;= 2:            if temp not in ans:                ans.append(copy.copy(temp))        for i in range(start, end):            if len(temp) &gt; 0 and nums[i] &gt;= temp[-1] or len(temp) == 0:                temp.append(nums[i])                self.bfs(nums, i+1, end, ans, temp)                temp.remove(nums[i])        \n","categories":["leetcode"],"tags":["leetcode"]},{"title":"leetcode 492 构造矩形","url":"/leetcode/leetcode-492-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/","content":"\n作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：\n\n\n你设计的矩形页面必须等于给定的目标面积。\n\n\n宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。\n\n\n长度 L 和宽度 W 之间的差距应当尽可能小。\n你需要按顺序输出你设计的页面的长度 L 和宽度 W。\n\n\n示例：\n输入: 4\n输出: [2, 2]\n解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。\n但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。\n说明:\n给定的面积不大于 10,000,000 且为正整数。\n你设计的页面的长度和宽度必须都是正整数。\n链接：https://leetcode-cn.com/problems/construct-the-rectangle\n\nclass Solution(object):    def constructRectangle(self, area):        &quot;&quot;&quot;        :type area: int        :rtype: List[int]        &quot;&quot;&quot;        import math        r = int(math.sqrt(area))        while area % r:            r -= 1        return [area//r,r]        \n","categories":["leetcode"],"tags":["leetcode"]},{"title":"leetcode 493 翻转对","url":"/leetcode/leetcode-493-%E7%BF%BB%E8%BD%AC%E5%AF%B9/","content":"\n给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。\n你需要返回给定数组中的重要翻转对的数量。\n示例 1:\n输入: [1,3,2,3,1]\n输出: 2\n示例 2:\n输入: [2,4,3,5,1]\n输出: 3\n注意:\n给定数组的长度不会超过50000。\n输入数组中的所有数字都在32位整数的表示范围内。\n链接：https://leetcode-cn.com/problems/reverse-pairs\n\nclass Solution(object):    def reversePairs(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        dic = &#123;&#125;        cnt = 0        s = []        for i in nums[::-1]:            if not s:                s.append(i*2)            else:                # 二分搜索                l, r = 0, len(s)-1                while l &lt;= r:                    mid = (l + r) &gt;&gt; 1                    if s[mid] &gt;= i:                        r = mid - 1                    else:                        l = mid + 1                cnt += l                # 二分插入                l, r = 0, len(s)-1                while l &lt;= r:                    mid = (l + r) &gt;&gt; 1                    if s[mid] &gt; 2*i:                        r = mid - 1                    else:                        l = mid + 1                s = s[:l] + [2*i] + s[l:]        return cnt\nimport bisectclass Solution:    def reversePairs(self, nums: List[int]) -&gt; int:        ri, res, n = [], 0, len(nums)        for i in reversed(range(0, n)):            res += bisect.bisect_left(ri, nums[i])            bisect.insort(ri, 2 * nums[i])        return res\ndef reversePairs(self, nums: List[int]) -&gt; int:    self.inversions = 0    self.Merge_Sort(nums, 0, len(nums)-1)    return self.inversionsdef Merge_Sort(self, nums, l, r):    if l &gt;= r:        return    mid = l + (r - l) // 2    self.Merge_Sort(nums, l, mid)    self.Merge_Sort(nums, mid+1, r)    i, j = l, mid+1    while i &lt;= mid and j &lt;= r:        if nums[j]*2 &lt; nums[i]:            # 当前左半部分，右半部分是排序好的            # 左半部分的当前元素满足，则前元素的右边元素也满足            # 故 mid + 1 - i            self.inversions +=  mid + 1 - i            j += 1        else:             i += 1    # 排序    nums[l:r+1] = sorted(nums[l:r+1])\n","categories":["leetcode"],"tags":["leetcode"]},{"title":"leetcode 494 目标和","url":"/leetcode/leetcode-494-%E7%9B%AE%E6%A0%87%E5%92%8C/","content":"\n给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n示例：\n输入：nums: [1, 1, 1, 1, 1], S: 3\n输出：5\n解释：\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n一共有5种方法让最终目标和为3。\n提示：\n数组非空，且长度不会超过 20 。\n初始的数组的和不会超过 1000 。\n保证返回的最终结果能被 32 位整数存下。\n链接：https://leetcode-cn.com/problems/target-sum\n\n\n递归\n\nclass Solution(object):    def findTargetSumWays(self, nums, S):        &quot;&quot;&quot;        :type nums: List[int]        :type S: int        :rtype: int        &quot;&quot;&quot;        return self.helper(nums, S, 0, len(nums), [])        def helper(self, nums, S, start, end, t):        if start == end:            if S == sum(t):                return 1            return 0        ans = 0        t.append(nums[start])        ans += self.helper(nums, S, start+1, end, t)        t.pop(-1)        t.append(nums[start] * (-1))        ans += self.helper(nums, S, start+1, end, t)        t.pop(-1)        return ans\n\n动态规划\n\nclass Solution(object):    def findTargetSumWays(self, nums, S):        &quot;&quot;&quot;        :type nums: List[int]        :type S: int        :rtype: int        &quot;&quot;&quot;        # p - n = S        # p - n + n = S + n        # p + n = S + 2n        # sum(nums) = S + 2n        # n = (sum(nums) - S)/2        N = sum(nums)        if S &gt; N or (N-S)%2:            return 0        target = (N - S)/2        dp = [1] + [0] * target                for i in nums:            for j in range(target, i-1, -1):                    dp[j] += dp[j-i]        return dp[-1]\n但是，通常而言，不会考虑到这么特殊的情况，还有一种比较通用的dp，应该是能想到的。\n\n动态规划2\n\n# 可以理解为，dp[i][j]表示的是到第i个元素，sum为j的组合数# 那么: dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]\n","categories":["leetcode"],"tags":["leetcode"]},{"title":"leetcode 495 提莫攻击","url":"/leetcode/leetcode-495-%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/","content":"\n在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。\n你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。\n示例1:\n输入: [1,4], 2\n输出: 4\n原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。\n第 4 秒初，提莫再次攻击艾希，使得艾希获得另外 2 秒中毒时间。\n所以最终输出 4 秒。\n示例2:\n输入: [1,2], 2\n输出: 3\n原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。\n但是第 2 秒初，提莫再次攻击了已经处于中毒状态的艾希。\n由于中毒状态不可叠加，提莫在第 2 秒初的这次攻击会在第 3 秒末结束。\n所以最终输出 3 。\n链接：https://leetcode-cn.com/problems/teemo-attacking\n\nclass Solution(object):    def findPoisonedDuration(self, timeSeries, duration):        &quot;&quot;&quot;        :type timeSeries: List[int]        :type duration: int        :rtype: int        &quot;&quot;&quot;        if not timeSeries:            return 0        timeSeries.sort()        acc = 0        for i in range(len(timeSeries)-1):            diff = timeSeries[i+1] - timeSeries[i]            if  diff &lt; duration:                acc += diff            else:                acc += duration        return acc+duration\n","categories":["leetcode"],"tags":["leetcode"]},{"title":"leetcode 496 下一个更大元素 I","url":"/leetcode/leetcode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I/","content":"\n给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n链接：https://leetcode-cn.com/problems/next-greater-element-i\n示例 1:\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出: [-1,3,-1]\n解释:\n对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。\n对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。\n对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。\n示例 2:\n输入: nums1 = [2,4], nums2 = [1,2,3,4].\n输出: [3,-1]\n解释:\n对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。\n对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n\nclass Solution(object):    def nextGreaterElement(self, nums1, nums2):        &quot;&quot;&quot;        :type nums1: List[int]        :type nums2: List[int]        :rtype: List[int]        &quot;&quot;&quot;        ans = []        for i in nums1:            start_idx  = nums2.index(i)            exist = False            for j in range(start_idx, len(nums2)):                if nums2[j] &gt; i:                    ans.append(nums2[j])                    exist = True                    break            if not exist:                ans.append(-1)        return ans\n# 保持一个降序的站，每次来新的元素，从栈的右端排出比当前元素小的元素，每次排出时，判断排出的数是否是nums1中的class Solution(object):    def nextGreaterElement(self, nums1, nums2):        &quot;&quot;&quot;        :type nums1: List[int]        :type nums2: List[int]        :rtype: List[int]        &quot;&quot;&quot;        ans = [-1 for i in range(len(nums1))]        stack = []        for i in nums2:            if not stack:                stack.append(i)            else:                if stack[-1] &gt;= i:                    stack.append(i)                    continue                else:                    while stack and stack[-1] &lt; i:                        out = stack.pop()                        if out in nums1:                            ans[nums1.index(out)] = i                    stack.append(i)        return ans\nclass Solution(object):    def nextGreaterElement(self, nums1, nums2):        &quot;&quot;&quot;        :type nums1: List[int]        :type nums2: List[int]        :rtype: List[int]        &quot;&quot;&quot;        dic = &#123;&#125;        stack = []        for i in nums2:            if not stack:                stack.append(i)            else:                if stack[-1] &gt;= i:                    stack.append(i)                    continue                else:                    while stack and stack[-1] &lt; i:                        dic[stack.pop()] = i                    stack.append(i)        return [dic[i] if i in dic.keys() else -1 for i in nums1]\n","categories":["leetcode"],"tags":["leetcode"]},{"title":"leetcode 497 非重叠矩形中的随机点","url":"/leetcode/leetcode-497-%E9%9D%9E%E9%87%8D%E5%8F%A0%E7%9F%A9%E5%BD%A2%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%82%B9/","content":"\n给定一个非重叠轴对齐矩形的列表 rects，写一个函数 pick 随机均匀地选取矩形覆盖的空间中的整数点。\n提示：\n整数点是具有整数坐标的点。\n矩形周边上的点包含在矩形覆盖的空间中。\n第 i 个矩形 rects [i] = [x1，y1，x2，y2]，其中 [x1，y1] 是左下角的整数坐标，[x2，y2] 是右上角的整数坐标。\n每个矩形的长度和宽度不超过 2000。\n1 &lt;= rects.length &lt;= 100\npick 以整数坐标数组 [p_x, p_y] 的形式返回一个点。\npick 最多被调用10000次。\n链接：https://leetcode-cn.com/problems/random-point-in-non-overlapping-rectangles\n\nfrom bisect import bisect_leftfrom random import randintclass Solution(object):    def __init__(self, rects):        &quot;&quot;&quot;        :type rects: List[List[int]]        &quot;&quot;&quot;        self.rects = rects        self.weight = []        s = 0        for rect in rects:            area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1) #注意加1            s += area            self.weight.append(s)    def pick(self):        &quot;&quot;&quot;        :rtype: List[int]        &quot;&quot;&quot;        index = bisect_left(self.weight, randint(1, self.weight[-1]))        rect = self.rects[index]        return [randint(rect[0], rect[2]), randint(rect[1], rect[3])]\n","categories":["leetcode"],"tags":["leetcode"]},{"title":"leetcode 498 对角线遍历","url":"/leetcode/leetcode-498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/","content":"\n给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。\n\n示例:\n输入:\n[\n[ 1, 2, 3 ],\n[ 4, 5, 6 ],\n[ 7, 8, 9 ]\n]\n输出:  [1,2,4,7,5,3,6,8,9]\n解释:\n\n\nclass Solution(object):    def findDiagonalOrder(self, matrix):        &quot;&quot;&quot;        :type matrix: List[List[int]]        :rtype: List[int]        &quot;&quot;&quot;        if not matrix: return matrix        m, n = len(matrix), len(matrix[0])        dic = &#123;&#125;        for i in range(m):            for j in range(n):                if  i+j not  in dic:                    dic[i+j] = []                dic[i+j].append(matrix[i][j])        ans = []        for i in range(m+n-1):            if i % 2:                ans.extend(dic[i])            else:                ans.extend(dic[i][::-1])        return ans\n","categories":["leetcode"],"tags":["leetcode"]},{"title":"leetcode 5 最长回文子串","url":"/article/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","content":"给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n示例 1：\n输入: &quot;babad&quot;\n输出: &quot;bab&quot;\n注意: “aba” 也是一个有效答案。\n示例 2：\n输入: &quot;cbbd&quot;\n输出: “bb”\n\n","tags":["leetcode","字符串"]},{"title":"leetcode 475 Heaters","url":"/article/leetcode-475-Heaters/","content":"Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.\nNow, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\nSo, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\nNote:\n\nNumbers of houses and heaters you are given are non-negative and will not exceed 25000.\nPositions of houses and heaters you are given are non-negative and will not exceed 10^9.\nAs long as a house is in the heaters’ warm radius range, it can be warmed.\nAll the heaters follow your radius standard and the warm radius will the same.\n\nExample 1:\nInput: [1,2,3],[2]Output: 1Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\nExample 2:\nInput: [1,2,3,4],[1,4]Output: 1Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n\n需要找到每一个房间和它最近的火炉的距离的最小值得最大值。\n直观的方法是双重遍历。\n\nclass Solution &#123;    public int findRadius(int[] houses, int[] heaters) &#123;        int longest = 0;        for (int house: houses) &#123;            int temp = Integer.MAX_VALUE;            for (int heater: heaters) &#123;                int distance = Math.abs(house-heater);                temp = Math.min(temp, distance);            &#125;            longest = Math.max(longest, temp);        &#125;        return longest;    &#125;&#125;\n但是这样的话，时间复杂度很高。\n\n\n如果我们对houses和heaters进行排序的话，假设我们顺序\n\n","tags":["leetcode"]},{"title":"leetcode 51 N queue","url":"/article/leetcode-51-N-queue/","content":"n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n上图为 8 皇后问题的一种解法。给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。\n示例:输入: 4输出: [ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]\n\nclass Solution(object):    def solveNQueens(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: List[List[str]]        &quot;&quot;&quot;        ans = []        board = [[&#x27;.&#x27; for i in range(n)] for j in range(n)]                def dfs(board, idx):            for i in range(n):                board[idx][i] = &#x27;Q&#x27;                if checked(board, idx, i):                    if idx == n-1:                        ans.append([&quot;&quot;.join(t) for t in board])                    else:                        dfs(board, idx+1)                board[idx][i] = &#x27;.&#x27;                def checked(board, i, j):            for k in range(i):                if board[k][j] == &#x27;Q&#x27;:                    return False                for m in range(n):                    if board[k][m] == &#x27;Q&#x27; and i-k == abs(m-j):                        return False            return True        dfs(board, 0)        return ans        \n","tags":["leetcode","回溯"]},{"title":"leetcode 52 N queen II","url":"/article/leetcode-52-N-queen-II/","content":"n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。\n示例:\n输入: 4输出: 2解释: 4 皇后问题存在如下两个不同的解法。[ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]\n\nclass Solution(object):    def totalNQueens(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: int        &quot;&quot;&quot;        ans = [0]                def dfs(position, ans, idx):            for i in range(0, n):                position[idx] = i                if checked(position, idx):                    if idx == n-1:                        ans[0] += 1                    else:                        dfs(position, ans, idx+1)                def checked(position, idx):            for i in range(idx):                if position[i] == position[idx] or idx-i == abs(position[idx] - position[i]):                    return False            return True                dfs([0 for i in range(n)], ans, 0)        return ans[0]        \n","tags":["leetcode","回溯"]},{"title":"leetcode 56 Merge Intervals","url":"/article/leetcode-56-Merge-Intervals/","content":"Given a collection of intervals, merge all overlapping intervals.\nExample 1:\nInput: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\nExample 2:\nInput: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considerred overlapping.\n\n\n先按照start从小到大的顺序排序\n设定当前start，end为第一个的值\n遍历一遍intervals，在这个过程中更新start，end，每次更新，就把原来的值插入到ans中\n注意每次比较的时候不是i不是和i-1去比较，而是和start，end比较\n\n/** * Definition for an interval. * public class Interval &#123; *     int start; *     int end; *     Interval() &#123; start = 0; end = 0; &#125; *     Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */class Solution &#123;    public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123;        ArrayList&lt;Interval&gt; ans = new ArrayList&lt;Interval&gt;();                if(intervals.size()==0 || intervals == null)&#123;            return ans;        &#125;        Collections.sort(intervals, new Comparator&lt;Interval&gt;()&#123;            @Override            public int compare(Interval o1, Interval o2)&#123;                    if(o1.start &lt; o2.start)&#123;                    return -1;                &#125;                else if(o1.start &gt; o2.start)&#123;                    return 1;                &#125;                else&#123;                    return 0;                &#125;            &#125;        &#125;);        int start = intervals.get(0).start;        int end = intervals.get(0).end;        for(int i=1; i&lt; intervals.size(); i++)&#123;            if(intervals.get(i).start &lt;= end &amp;&amp; intervals.get(i).end &lt;= end)&#123;                                     &#125;            else if(intervals.get(i).start &lt;= end &amp;&amp; intervals.get(i).end &gt; end)&#123;                end = intervals.get(i).end;            &#125;            else&#123;                ans.add(new Interval(start, end));                start = intervals.get(i).start;                end = intervals.get(i).end;            &#125;                    &#125;        ans.add(new Interval(start, end));        return ans;            &#125;&#125;\n\n讨论区更descent的方法：\nclass Solution &#123;    private class IntervalComparator implements Comparator&lt;Interval&gt; &#123;        @Override        public int compare(Interval a, Interval b) &#123;            return a.start &lt; b.start ? -1 : a.start == b.start ? 0 : 1;        &#125;    &#125;    public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123;        Collections.sort(intervals, new IntervalComparator());        LinkedList&lt;Interval&gt; merged = new LinkedList&lt;Interval&gt;();        for (Interval interval : intervals) &#123;            // if the list of merged intervals is empty or if the current            // interval does not overlap with the previous, simply append it.            if (merged.isEmpty() || merged.getLast().end &lt; interval.start) &#123;                merged.add(interval);            &#125;            // otherwise, there is overlap, so we merge the current and previous            // intervals.            else &#123;                merged.getLast().end = Math.max(merged.getLast().end, interval.end);            &#125;        &#125;        return merged;    &#125;\n","tags":["leetcode"]},{"title":"leetcode 59. Spiral Matrix II","url":"/article/leetcode-59-Spiral-Matrix-II/","content":"Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.\nExample:\nInput: 3Output:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]]\n\n\n设定left， right， up， down, 来指定当前的上下左右边界。\n在不超过边界的前提下，依次从左到右，从上到下，从右到左，从下到上遍历。\n注意输入参数小于0的情况。\n\nclass Solution &#123;    public int[][] generateMatrix(int n) &#123;        if (n&lt;=0) return new int[0][0];        int content = 1;        int i=0, j = 0;        int up = 0;        int down = n-1;        int left = 0;        int right = n-1;        int[][] ans = new int[n][n];        while(i&gt;=up &amp;&amp; i&lt;=down &amp;&amp; j&gt;=left &amp;&amp; j&lt;= right)&#123;            while(j&lt;=right)&#123;                ans[i][j] = content;                content ++;                j++;            &#125;            up ++;            j--;            i++;            while(i&lt;=down)&#123;                ans[i][j] = content;                i++;                content++;            &#125;            right --;            i--;            j--;            while(j&gt;= left)&#123;                ans[i][j] = content;                j --;                content ++;            &#125;            down --;            j++;            i--;            while(i&gt;= up)&#123;                ans[i][j] = content;                i --;                content ++;            &#125;            left ++;            i++;            j++;        &#125;        return ans;    &#125;&#125;\npython\n\n","tags":["leetcode"]},{"title":"leetcode 64 最小路径和","url":"/article/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","content":"给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明：每次只能向下或者向右移动一步。\n示例:\n输入:[  [1,3,1],  [1,5,1],  [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。\n\nclass Solution(object):    def minPathSum(self, grid):        &quot;&quot;&quot;        :type grid: List[List[int]]        :rtype: int        &quot;&quot;&quot;        if not grid or not grid[0]:            return False        m, n = len(grid), len(grid[0])        dp = [[0 for i in range(n)] for j in range(m)]                for i in range(m):            for j in range(n):                if i==0 and j==0:                    dp[i][j] = grid[i][j]                elif i==0:                    dp[i][j] = dp[i][j-1] + grid[i][j]                elif j==0:                    dp[i][j] = dp[i-1][j] + grid[i][j]                else:                    dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j]        return dp[-1][-1]                \n","tags":["leetcode","数组","动态规划"]},{"title":"leetcode 65 有效数字","url":"/article/leetcode-65-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/","content":"验证给定的字符串是否可以解释为十进制数字。\n例如:\n“0” =&gt; true\n&quot; 0.1 &quot; =&gt; true\n&quot;abc&quot; =&gt; false\n&quot;1 a&quot; =&gt; false\n&quot;2e10&quot; =&gt; true\n&quot; -90e3   &quot; =&gt; true\n&quot; 1e&quot; =&gt; false\n&quot;e3&quot; =&gt; false\n&quot; 6e-1&quot; =&gt; true\n&quot; 99e2.5 &quot; =&gt; false\n&quot;53.5e93&quot; =&gt; true\n&quot; --6 &quot; =&gt; false\n&quot;-+3&quot; =&gt; false\n&quot;95a54e53&quot; =&gt; false\n说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：\n数字 0-9\n指数 - “e&quot;\n正/负号 - “+”/”-&quot;\n小数点 - &quot;.&quot;\n当然，在输入中，这些字符的上下文也很重要。\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/valid-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\nclass Solution(object):    def isNumber(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: bool        &quot;&quot;&quot;        head = &quot;&quot;        tail = &quot;&quot;        # 去除&quot;   123   &quot;        s = s.strip()        # trim后为空的情况        if not s:            return False        # 用e分为左右脸部分        items = s.split(&#x27;e&#x27;)        legal = &#123; &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;&#125;        # 去掉超过一个e的的情况        if len(items) &gt; 2:            return False        # 当有一个e的时候，分别分配给左右两部分        if len(items) == 2:            head = items[0]            tail = items[1]            # 左右两部分都为空，去除情况为&quot;e&quot;的时候            if not head or not tail:                return False        # 当不存在e的时候，分配给head        if len(items) == 1:            head = items[0]        # 如果e存在的话，对e的指数部分进行处理        if tail:            # 指数部分不能存在&#x27;.&#x27;            if &#x27;.&#x27; in tail:                return False            # 指数部分可以有符号            if tail[0] in &#123;&#x27;+&#x27;, &#x27;-&#x27;&#125;:                # 指数部分只有符号                tail = tail[1:]                if not tail:                    return False            # 去掉符号后，指数部分只能有数字            for i in tail:                if i not in legal:                    return False        if head:            sign = False            # 先通过小数点对整数和小数部分进行切分            items = head.split(&#x27;.&#x27;)            integer, fraction = &#x27;&#x27;, &#x27;&#x27;            # 如果存在多个小数点，去除            if len(items) &gt; 2:                return False            # 不存在小数点，视为整数            if len(items) == 1:                integer = items[0]            # 存在一个小数点，分为整数和小数            if len(items) == 2:                integer = items[0]                fraction = items[1]            # 如果整数以符号开头，去掉开头的符号            if integer and integer[0] in &#123;&#x27;+&#x27;, &#x27;-&#x27;&#125;:                integer = integer[1:]            # 去掉符号后，整数和小数都为空，去掉&#x27;+.&#x27;, &#x27;.&#x27;的情况            if not integer and not fraction:                return False                        for i in integer:                if i not in legal:                    return False            for i in fraction:                if i not in legal:                    return False        return True                                                        \n","tags":["leetcode","字符串"]},{"title":"leetcode 60 Permutation Sequence","url":"/article/leetcode-60-Permutation-Sequence/","content":"The set [1,2,3,...,n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n&quot;123&quot;\n&quot;132&quot;\n&quot;213&quot;\n&quot;231&quot;\n&quot;312&quot;\n&quot;321&quot;\n\nGiven n and k, return the kth permutation sequence.\nNote:\n\nGiven n will be between 1 and 9 inclusive.\nGiven k will be between 1 and n! inclusive.\n\n\n分析，对于n=3，k=5；\n对于n=3的排列：\n\n1 + {2,3}的排列\n2 + {1,3}的排列\n3 + {1,2}的排列\n\n确定最高位数值 = k-1 / (n-1)!\n确定最高位后，下一位的确定和最高位一样，即可以依次迭代下去。\n要注意一点，在确定完一位之后，后面的数值排列需要按照从小到大的顺序排列。\n可以使用一个StringBuilder，开始时，StringBuilder中的数值为：1-n;\n每确定一位，将这一位append到StringBuilder末尾，同时删除原位置的数值。\n考虑到当n很大时，例如n=8时，对于k=3，前面的5位顺序未发生变化。同样的，我们每次将StringBuilder中的第0位的数值append到最后，并删除。\nclass Solution &#123;    public String getPermutation(int n, int k) &#123;        StringBuilder ans = new StringBuilder();        int[] fac = new int[n];        // 构造初始的答案：1234...n        for(int i=1; i&lt;=n; i++)&#123;            ans.append((char) (&#x27;0&#x27; + i));        &#125;        // 构造阶乘数组[1,1,2,6,...,(n-1)!]        fac[0] = 1;        for(int i=1; i&lt;n; i++)&#123;            fac[i] = fac[i-1]*i;        &#125;   \t\t// k用来映射到stringbuilder的下标，因此需要减一，        // 如果不减一的话，可以考虑n=3，k=6的情况，index将为3，超过边界了。        k = k-1;        for(int i=n-1; i&gt;=0; i--)&#123;            // 找到需要append到末尾的index            int index = k/fac[i];            ans.append(ans.charAt(index));            ans.deleteCharAt(index);            k = k % fac[i];        &#125;        return ans.toString();            &#125;&#125;\n1 {2, 3, 4} 6\n2 {1, 3, 4} 6\n3 {1, 2, 4} 6\n4 {1, 2, ,3} 6\n","tags":["leetcode"]},{"title":"leetcode 66 加一","url":"/article/leetcode-66-%E5%8A%A0%E4%B8%80/","content":"给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。\n示例 1:\n输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。\n示例 2:\n输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。\n\n\n从后往前判断是不是9，如果是9就置0并继续，如果不是就就+1结束。\n循环结束之后，要判断是不是已经+1过，如果没有+1， 就需要在最前面填上1.\n\n\n","tags":["leetcode","数组"]},{"title":"leetcode 67 二进制求和","url":"/article/leetcode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/","content":"给定两个二进制字符串，返回他们的和（用二进制表示）。输入为非空字符串且只包含数字 1 和 0。\n示例 1:\n输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot;\n示例 2:\n输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot;\n\n","tags":["leetcode","字符串"]},{"title":"leetcode 70 爬楼梯","url":"/article/leetcode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/","content":"假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n注意：给定 n 是一个正整数。\n示例 1：\n输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶\n示例 2：\n输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶\n\nclass Solution(object):    def climbStairs(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: int        &quot;&quot;&quot;        dp = [0 for i in range(n)]        for i in range(n):            if i == 0:                dp[i] = 1            elif i == 1:                dp[i] = 2            else:                dp[i] = dp[i-1] + dp[i-2]        return dp[-1]\n","tags":["leetcode","数组","动态规划"]},{"title":"leetcode 69 mySqrt","url":"/article/leetcode-69-mySqrt/","content":"实现 int sqrt(int x) 函数。\n计算并返回 x 的平方根，其中 x 是非负整数。\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n示例 1:\n输入: 4输出: 2\n示例 2:\n输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。\n\n","tags":["leetcode","二分查找"]},{"title":"leetcode 71 简化路径","url":"/article/leetcode-71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/","content":"以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （…） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径\n请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。\n示例 1：\n输入：&quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。\n示例 2：\n输入：&quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。\n示例 3：\n输入：&quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。\n示例 4：\n输入：&quot;/a/./b/../../c/&quot;输出：&quot;/c&quot;\n示例 5：\n输入：&quot;/a/../../b/../c//.//&quot;输出：&quot;/c&quot;\n示例 6：\n输入：&quot;/a//b////c/d//././/..&quot;输出：&quot;/a/b/c&quot;\n\nclass Solution(object):    def simplifyPath(self, path):        &quot;&quot;&quot;        :type path: str        :rtype: str        &quot;&quot;&quot;        items = path.split(&#x27;/&#x27;)        stack = []        for i in items:            if i == &#x27;&#x27;:                continue            elif i == &#x27;.&#x27;:                continue            elif i == &#x27;..&#x27;:                if stack:                    stack.pop()            else:                stack.append(i)        ans = &#x27;/&#x27;.join(stack)        return &#x27;/&#x27;+ans            \n","tags":["leetcode","字符串","栈"]},{"title":"leetcode 68 文本左右对齐","url":"/article/leetcode-68-%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/","content":"给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ’ ’ 填充，使得每行恰好有 maxWidth 个字符。要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。文本的最后一行应为左对齐，且单词之间不插入额外的空格。\n说明:\n单词是指由非空格字符组成的字符序列。\n每个单词的长度大于 0，小于等于 maxWidth。\n输入单词数组 words 至少包含一个单词。\n示例:\n输入:words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]maxWidth = 16输出:[   &quot;This    is    an&quot;,   &quot;example  of text&quot;,   &quot;justification.  &quot;]\n示例 2:\n输入:words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]maxWidth = 16输出:[  &quot;What   must   be&quot;,  &quot;acknowledgment  &quot;,  &quot;shall be        &quot;]解释: 注意最后一行的格式应为 &quot;shall be    &quot; 而不是 &quot;shall     be&quot;,     因为最后一行应为左对齐，而不是左右两端对齐。            第二行同样为左对齐，这是因为这行只包含一个单词。\n示例 3:\n输入:words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,         &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]maxWidth = 20输出:[  &quot;Science  is  what we&quot;,  &quot;understand      well&quot;,  &quot;enough to explain to&quot;,  &quot;a  computer.  Art is&quot;,  &quot;everything  else  we&quot;,  &quot;do                  &quot;]\n\n\n","tags":["leetcode","字符串"]},{"title":"leetcode 76 最小覆盖子串","url":"/article/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/","content":"给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。\n输入: \tS = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;输出: \t&quot;BANC&quot;说明：\t如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。\t如果 S 中存在这样的子串，我们保证它是唯一的答案。\n\nclass Solution(object):    def minWindow(self, s, t):        &quot;&quot;&quot;        :type s: str        :type t: str        :rtype: str        &quot;&quot;&quot;        from collections import Counter        dic = Counter(t)        start = 0        end = 0        length = sys.maxsize        window = Counter()        ans = &quot;&quot;        while end &lt; len(s):            window[s[end]] += 1            while all(map(lambda x: window[x] &gt;= dic[x] , dic.keys())):                if end-start &lt; length:                    length = end-start+1                    ans = s[start: end+1]                window[s[start]] -= 1                start += 1            end += 1        return ans\n","tags":["leetcode"]},{"title":"leetcode 72 编辑距离","url":"/article/leetcode-72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","content":"给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：\n\t插入一个字符\n\t删除一个字符\n\t替换一个字符\n示例 1:\n输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;)\n示例 2:\n输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &#x27;t&#x27;)inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)exection -&gt; execution (插入 &#x27;u&#x27;)\n\n","tags":["leetcode","数组","动态规划"]},{"title":"leetcode 8 字符串转换整数 (atoi)","url":"/article/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-(atoi)/","content":"请你来实现一个 atoi 函数，使其能将字符串转换成整数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n说明：\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，qing返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n示例 1:\n输入: &quot;42&quot;\n输出: 42\n示例 2:\n输入: &quot;   -42&quot;\n输出: -42\n解释: 第一个非空白字符为 ‘-’, 它是一个负号。\n我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n示例 3:\n输入: &quot;4193 with words&quot;\n输出: 4193\n解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。\n示例 4:\n输入: &quot;words and 987&quot;\n输出: 0\n解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。\n因此无法执行有效的转换。\n示例 5:\n输入: &quot;-91283472332&quot;\n输出: -2147483648\n解释: 数字 “-91283472332” 超过 32 位有符号整数范围。\n因此返回 INT_MIN (−231) 。\n\nclass Solution(object):    def myAtoi(self, str):        &quot;&quot;&quot;        :type str: str        :rtype: int        &quot;&quot;&quot;        str = str.strip()        if not str:            return 0        sign = None        t = 0        max_ = 1&lt;&lt;31        if str[0] == &#x27;-&#x27;:            sign = -1            str = str[1:]        elif str[0] == &#x27;+&#x27;:            sign = 1            str = str[1:]        else:            sign = 1                        for i in str:            if ord(&#x27;0&#x27;) &lt;= ord(i) &lt;= ord(&#x27;9&#x27;):                toadd = ord(i) - ord(&#x27;0&#x27;)                if sign == 1 and t &gt; (max_-1 - toadd)/10:                    return max_-1                elif sign == -1 and t &gt; (max_ - toadd)/10:                    return -max_                else:                    t = t*10 + toadd            else:                break        if sign == -1:            t = -t        return t        \n","tags":["leetcode","字符串"]},{"title":"leetcode 77 Combinations","url":"/article/leetcode-77-Combinations/","content":"Given two integers n and k, return all possible combinations of k numbers out of 1 … n.\nExample:\nInput: n = 4, k = 2Output:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]\n\n\nbfs回溯就好了\n\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();        List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;();        bfs(result, current, n , k, 1);        return result;    &#125;    public void bfs(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; current, int n, int k, int c)&#123;        if(current.size() == k)&#123;            result.add(new ArrayList&lt;Integer&gt;(current));            return ;        &#125;        for(int i=c; i&lt;=n; i++)&#123;            current.add(i);            bfs(result, current, n ,k, ++c);            current.remove(current.size()-1);                    &#125;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 78 子集","url":"/article/leetcode-78-%E5%AD%90%E9%9B%86/","content":"","tags":["leetcode","数组","回溯"]},{"title":"leetcode 79 单词搜索","url":"/article/leetcode-79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/","content":"给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n示例:\nboard =[  [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],  [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],  [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]]给定 word = &quot;ABCCED&quot;, 返回 true.给定 word = &quot;SEE&quot;, 返回 true.给定 word = &quot;ABCB&quot;, 返回 false.\n\n\n","tags":["leetcode","数组","回溯"]},{"title":"leetcode 80 删除排序数组中的重复项 II","url":"/article/leetcode-80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II/","content":"给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\n示例 1:\n给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n示例 2:\n给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n\n\n\n双指针\nclass Solution(object):    def removeDuplicates(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        if len(nums) &lt;= 2:            return len(nums)        prev = None        cnt = 0        total = 0        p = 0        for i in nums:            if prev == None:                prev = i                cnt = 1            elif prev == i:                cnt += 1            else:                if cnt &gt;= 2:                    nums[p] = prev                    nums[p+1] = prev                    p += 2                    prev = i                    cnt = 1                    total += 2                else:                    nums[p] = prev                    p += 1                    prev = i                    cnt = 1                    total += 1        if cnt &gt;= 2:            nums[p] = prev            nums[p+1] = prev            total += 2        if cnt == 1:            nums[p] = prev            total += 1        return total\n\n\npattern\nclass Solution:    def removeDuplicates(self, nums， k):        i = 0        for n in nums:            if i &lt; k or n != nums[i-k]:                nums[i] = n                i += 1        return i\n\n","tags":["leetcode","数组","双指针"]},{"title":"leetcode 81 Search in Rotated Sorted Array II","url":"/article/leetcode-81-Search-in-Rotated-Sorted-Array-II/","content":"Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).\nYou are given a target value to search. If found in the array return true, otherwise return false.\nExample 1:\nInput: nums = [2,5,6,0,0,1,2], target = 0Output: true\nExample 2:\nInput: nums = [2,5,6,0,0,1,2], target = 3Output: false\nFollow up:\n\nThis is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.\nWould this affect the run-time complexity? How and why?\n\n\nclass Solution &#123;    public boolean search(int[] nums, int target) &#123;        if(nums.length == 0)&#123;            return false;        &#125;        int low = 0;        int high = nums.length -1;\t\t// 1 第一次二分搜索，找到最小的值       \t// 1.1 在搜索时，可能遇到收尾都是相同字符的情况，111111121,121111111，对low或者high进行处理，排除这种情况        while(nums[low] == nums[high] &amp;&amp; high &gt; low) &#123;            high--;        &#125;        // 1.2 二分搜索，注意while中为等于号时，low = mid + 1， high = mid - 1        while(low &lt;= high)&#123;            int mid = low + ((high - low) &gt;&gt; 2);            if(nums[mid] &gt;= nums[0])&#123;                low = mid+1;            &#125;            else&#123;                high = mid-1;            &#125;        &#125;\t    // 2 当二分结束后，low指向最小的值，但是，这里要考虑最数组只有一个数的情况        if(target == nums[0])&#123;            return true;        &#125;        else if(target &gt; nums[0])&#123;            high = low-1;            low = 0;        &#125;        else&#123;            high = nums.length - 1;        &#125;        // 3 第二次二分搜索， 为已排序数组的二分搜索。        while(low &lt;= high)&#123;            int mid = low + ((high - low)&gt;&gt;2);            if(nums[mid] == target)&#123;                return true;            &#125;            else if(nums[mid] &gt; target)&#123;                high = mid-1;            &#125;            else&#123;                low = mid+1;            &#125;        &#125;        return false;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 81 搜索旋转排序数组 II","url":"/article/leetcode-81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II/","content":"假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。\n示例 1:\n输入: nums = [2,5,6,0,0,1,2], target = 0输出: true\n示例 2:\n输入: nums = [2,5,6,0,0,1,2], target = 3输出: false\n这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。\n这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？\n\nclass Solution(object):    def search(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: bool        &quot;&quot;&quot;        if not nums:            return False        left, right = 0, len(nums)-1        while left &lt;= right:            mid = left + ((right - left)&gt;&gt;1)            if nums[mid] == target:                return True            if nums[mid] == nums[left] and nums[mid] == nums[right]:                left += 1                right -= 1            elif nums[mid] &lt;= nums[right]:                if nums[mid] &lt; target  and target &lt;= nums[right]:                    left = mid + 1                else:                    right = mid - 1            else:                if nums[left] &lt;= target and target &lt; nums[mid]:                    right = mid -1                else:                    left = mid + 1        return False\n","tags":["leetcode","数组","二分查找"]},{"title":"leetcode 85 Maximal Rectangle","url":"/article/leetcode-85-Maximal-Rectangle/","content":"Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.\nExample:\nInput:[  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]Output: 6\n\n\n\n用一个数组a[n]在存储每一行的累积的连续的1有多少\n\n\n\n1\n0\n1\n0\n0\n\n\n\n\n1\n0\n1\n1\n1\n\n\n1\n1\n1\n1\n1\n\n\n1\n0\n0\n1\n0\n\n\n\n对应的a为\n\n\n\n1\n0\n1\n0\n0\n\n\n\n\n2\n0\n2\n1\n1\n\n\n3\n1\n3\n2\n2\n\n\n4\n0\n0\n3\n0\n\n\n\n\n\n那对于每一个a[n]，需要求他能组成的最大的长方形是多少。\n\n\n用一个stack保存index，同时保证stack中所指向的a[index]是升序的。\n\n每次遇到一个a[i]，都和stack中的a[peek]进行比较，如果大于a[peek]，继续入栈。\n如果小于a[peek]，那么将peek pop出来\n接下来计算包含peek在内，对大能组成的长方形是多大。\n此时a[i]是peek右边第一个比peek小的数\nstack.peek是a[i]左边第一个比peek大的数(当stack为空的时候，left设置为-1)\n这样一来，就可以求出来包含peek在内的最大的长方形的大小。\n计算完peek之后，继续i保持不变，继续计算包括stack.peek在内能组成的最大的长方形。\n\nclass Solution &#123;    public int maximalRectangle(char[][] matrix) &#123;        if (matrix.length == 0 || matrix[0].length == 0) &#123;            return 0;        &#125;        int max = Integer.MIN_VALUE;        int[] a = new int[matrix[0].length];        for (int i=0; i&lt;matrix.length; i++) &#123;            for (int j=0; j&lt;matrix[0].length; j++) &#123;                if (matrix[i][j] == &#x27;0&#x27;)                    a[j] = 0;                else &#123;                    a[j] += 1;                &#125;            &#125;                        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();            for(int j=0; j&lt;=matrix[0].length; j++) &#123;                int h = j == matrix[0].length?0: a[j];                if (s.isEmpty() || a[s.peek()] &lt; h) &#123;                    s.push(j);                &#125;                else &#123;                    int top = s.pop();                    int left = -1;                    if (!s.isEmpty())                        left = s.peek();                    int right = j;                    max = Math.max(max, a[top]*(right-left-1));                    j--;                &#125;            &#125;        &#125;        return max;    &#125;&#125;\n\n","tags":["leetcode"]},{"title":"leetcode 82 删除排序链表中的重复元素 II","url":"/article/leetcode-82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II/","content":"给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。\n示例 1:\n输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5\n示例 2:\n输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3\n\n# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution(object):    def deleteDuplicates(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not head:            return head        prev = None        p = head        while p:            nex = p.next            while nex and nex.val == p.val:                nex = nex.next            if nex != p.next:                # nex 和 p 没有相邻，说明 p是有重复的，prev的next就需要跳过所有的p到nex                # 那如果没有prev时，说明head也没有确定，这是，将head暂定为nex，但是nex不一定能                # 满足要求，所以prev还是为None                if not prev:                    head = nex                else:                    prev.next = nex            else:                # 当确定p是只有一个值得时候，我们就让prev == p                prev = p            p = nex        return head                                                                    \n","tags":["leetcode","链表"]},{"title":"leetcode 86 Partition List","url":"/article/leetcode-86-Partition-List/","content":"Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\nExample:\nInput: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5\n\n\n把所有小于x的数放在x的左边，大于等于x的数放在右边。\n从左往右依次遍历一遍数组，设置两个标记分别标记左边和右边\n把小于x的放置到左边，把大于等于x的放置到右边\n把左右两边连接起来\n\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode partition(ListNode head, int x) &#123;        ListNode left = new ListNode(0);        ListNode right = new ListNode(0);        ListNode small = left;        ListNode great = right;        ListNode p = head;        if(p == null || p.next == null)&#123;            return p;        &#125;        while(p != null)&#123;            if(p.val &lt; x)&#123;                small.next = p;                small = small.next;            &#125;            else&#123;                great.next = p;                great = great.next;            &#125;            p = p.next;        &#125;        small.next = right.next;        great.next = null;        return left.next;            &#125;&#125;\n\n注意最后的great.next一定要设置成空。不然对于这种情况：\n1-&gt;2-&gt;3-&gt;6-&gt;4会形成环\n\n","tags":["leetcode"]},{"title":"leetcode 83 删除排序链表中的重复元素","url":"/article/leetcode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","content":"给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n示例 1:\n输入: 1-&gt;1-&gt;2输出: 1-&gt;2\n示例 2:\n输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3\n\n# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution(object):    def deleteDuplicates(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not head:            return head        pre = head        p = head.next        while p:            while p and p.val == pre.val:                p = p.next            if not p:                break            else:                pre = pre.next                pre.val = p.val                p = p.next        pre.next = None        return head\n","tags":["leetcode","链表"]},{"title":"leetcode 84 柱状图中最大的矩形","url":"/article/leetcode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/","content":"给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n![image-20190706184103401](/Users/xiongz/Library/Application Support/typora-user-images/image-20190706184103401.png)\n![image-20190706184139193](/Users/xiongz/Library/Application Support/typora-user-images/image-20190706184139193.png)\n\n\n\n我们维护一个栈，栈中的元素保持递减的关系\n\n\n当我们遇到一个数nums[i] 如果nums[i]小于栈顶的元素，这就意味着，对于栈顶元素，他能组成的最大的矩形的左边界为栈中的栈顶元素的前一个元素，右边界为当前的i。这样一来，我们先把当前的栈顶元素pop出来，得到h此时的栈顶元素能够组成的最大的矩形面积为nums[h]*(i-1 - stack[-1])。\n\n\n这么遍历完一遍之后，stack中可能存在还有元素的情况。那么此时，由于数组已经遍历完毕，对于栈中的所有元素，他的左边界为栈中它前面的一个元素，右边界为整个数组的长度。\n  \n\n","tags":["leetcode","数组","栈"]},{"title":"leetcode 87 Scramble String","url":"/article/leetcode-87-Scramble-String/","content":"Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\nBelow is one possible representation of s1 = &quot;great&quot;:\n    great   /    \\  gr    eat / \\    /  \\g   r  e   at           / \\          a   t\nTo scramble the string, we may choose any non-leaf node and swap its two children.\nFor example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;.\n    rgeat   /    \\  rg    eat / \\    /  \\r   g  e   at           / \\          a   t\nWe say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;.\nSimilarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;.\n    rgtae   /    \\  rg    tae / \\    /  \\r   g  ta  e       / \\      t   a\nWe say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;.\nGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.\nExample 1:\nInput: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;Output: true\nExample 2:\nInput: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;Output: false\n\nclass Solution &#123;    public boolean isScramble(String s1, String s2) &#123;        if (s1.equals(s2))            return true;        if (s1.length() != s2.length())            return false;        int[] alphabet = new int[26];        for (int i=0; i&lt;s1.length(); i++) &#123;            alphabet[s1.charAt(i)-&#x27;a&#x27;] --;            alphabet[s2.charAt(i)-&#x27;a&#x27;] ++;        &#125;        for (int c: alphabet) &#123;            if (c != 0)                return false;        &#125;                for (int i=1; i&lt;s1.length(); i++) &#123;            if (isScramble(s1.substring(0, i), s2.substring(0, i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i)) )                return true;            if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(0, s2.length()-i)))                 return true;        &#125;        return false;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 85 最大矩形","url":"/article/leetcode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","content":"给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n示例:\n输入:[  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出: 6\n\n\n维护一个数组h，保存每一层到现在的状态，那么就可以转换为到在每个状态的最大值得情况\n等价于在一个数组中，找到最大的矩形\n\n\n","tags":["leetcode","数组","栈"]},{"title":"leetcode 89 格雷编码","url":"/article/leetcode-89-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/","content":"格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。\n示例 1:\n输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2\n对于给定的 n，其格雷编码序列并不唯一。\n例如，\n[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1\n示例 2:\n输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。\n给定编码总位数为 $n$ 的格雷编码序列，其长度为 $2^n$。当 $n = 0$ 时，长度为 $2^0 = 1$。因此，当 $n = 0$ 时，其格雷编码序列为 [0]。\n\nclass Solution(object):    def grayCode(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: List[int]        &quot;&quot;&quot;        return [i ^ (i &gt;&gt; 1) for i in range(1 &lt;&lt; n)]\nw\n","tags":["leetcode","数学"]},{"title":"leetcode 9 回文数","url":"/article/leetcode-9-%E5%9B%9E%E6%96%87%E6%95%B0/","content":"判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n示例 1:\n输入: 121\n输出: true\n示例 2:\n输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3:\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n进阶:\n你能不将整数转为字符串来解决这个问题吗？\n\nclass Solution(object):    def isPalindrome(self, x):        &quot;&quot;&quot;        :type x: int        :rtype: bool        &quot;&quot;&quot;        s = str(x)        left = 0        right = len(s)-1        while left &lt; right:            if s[left] != s[right]:                return False            left += 1            right -= 1        return True\n","tags":["leetcode","字符串"]},{"title":"leetcode 87 扰乱字符串","url":"/article/leetcode-87-%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。\n下图是字符串 s1 = “great” 的一种可能的表示形式。\n\tgreat\n  /    \\\n  gr    eat\n / \\    /  \\\ng   r  e   at\n           / \\\n          a   t\n\n在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。\n例如，如果我们挑选非叶节点 “gr” ，交换它的两个子节点，将会产生扰乱字符串 “rgeat” 。\n\t\trgeat\n   /    \\\n  rg    eat\n / \\    /  \\\nr   g  e   at\n           / \\\n          a   t\n\n我们将 &quot;rgeat” 称作 “great” 的一个扰乱字符串。\n同样地，如果我们继续将其节点 “eat” 和 “at” 进行交换，将会产生另一个新的扰乱字符串 “rgtae” 。\n\t\trgtae\n   /    \\\n  rg    tae\n / \\    /  \\\nr   g  ta  e\n       / \\\n      t   a\n\n我们将 &quot;rgtae” 称作 “great” 的一个扰乱字符串。\n给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。\n示例 1:\n输入: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;输出: true\n示例 2:\n输入: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;输出: false\n\nclass Solution(object):    def isScramble(self, s1, s2):        &quot;&quot;&quot;        :type s1: str        :type s2: str        :rtype: bool        &quot;&quot;&quot;        if len(s1) != len(s2):            return False        if s1 == s2:            return True        if sorted(s1) != sorted(s2):            return False                for i in range(1, len(s1)):            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):                return True            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):                return True        return False        \n","tags":["leetcode","递归"]},{"title":"leetcode 86 分隔链表","url":"/article/leetcode-86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/","content":"给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。\n你应当保留两个分区中每个节点的初始相对位置。\n示例:\n输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3\n输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5\n\n# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution(object):    def partition(self, head, x):        &quot;&quot;&quot;        :type head: ListNode        :type x: int        :rtype: ListNode        &quot;&quot;&quot;        if not head:            return head                dump = ListNode(-1)        dump.next = head        p = head        pre = dump                outer = ListNode(-1)        outerPre = outer                while p:            if p.val &gt;= x:                pre.next = p.next                outerPre.next = p                p.next = None                outerPre = outerPre.next                p = pre.next            else:                p = p.next                pre = pre.next        pre.next = outer.next        return dump.next                                \n","tags":["leetcode","链表","双指针"]},{"title":"leetcode 88 合并两个有序数组","url":"/article/leetcode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。\n说明:\n初始化 nums1 和 nums2 的元素数量分别为 m 和 n。\n你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。\n示例:\n输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6],       n = 3输出: [1,2,2,3,5,6]\n\nclass Solution(object):    def merge(self, nums1, m, nums2, n):        &quot;&quot;&quot;        :type nums1: List[int]        :type m: int        :type nums2: List[int]        :type n: int        :rtype: None Do not return anything, modify nums1 in-place instead.        &quot;&quot;&quot;        k = m+n-1        i = m-1        j = n-1        while i &gt;= 0 and j &gt;= 0 and k &gt;=0:            if nums1[i] &gt; nums2[j]:                nums1[k] = nums1[i]                i -= 1                k -= 1            else:                nums1[k] = nums2[j]                j -= 1                k -= 1        if i == -1:            while k &gt;= 0:                nums1[k] = nums2[j]                k -= 1                j -= 1                        \n","tags":["leetcode","数组","双指针"]},{"title":"leetcode 91 解码方法","url":"/article/leetcode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/","content":"一条包含字母 A-Z 的消息通过以下方式进行了编码：\n&#x27;A&#x27; -&gt; 1&#x27;B&#x27; -&gt; 2...&#x27;Z&#x27; -&gt; 26\n给定一个只包含数字的非空字符串，请计算解码方法的总数。\n示例 1:\n输入: &quot;12&quot;输出: 2解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。\n示例 2:\n输入: &quot;226&quot;输出: 3解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。\n\nclass Solution(object):    def numDecodings(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: int        &quot;&quot;&quot;        cnt = 0        if not s:            return 0        dp = [0] * (len(s)+1)        dp[-1] = 1        for i in range(len(s)-1, -1, -1):            if s[i] == &#x27;0&#x27;:                continue            dp[i] = dp[i+1]            if s[i] != &#x27;0&#x27; and i+2 &lt;= len(s) and 10&lt;=int(s[i:i+2])&lt;= 26:                dp[i] += dp[i+2]        return dp[0]\n","tags":["leetcode","字符串","动态规划"]},{"title":"leetcode 92 反转链表 II","url":"/article/leetcode-92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II/","content":"反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。\n说明:\n1 ≤ m ≤ n ≤ 链表长度。\n示例:\n输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4\n输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL\n\n# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution(object):    def reverseBetween(self, head, m, n):        &quot;&quot;&quot;        :type head: ListNode        :type m: int        :type n: int        :rtype: ListNode        &quot;&quot;&quot;        if not head or m == n:            return head        dump = TreeNode(-1)        dump.next = head        pre = dump        for i in range(m-1):            pre = pre.next                p = pre.next        for i in range(n-m):            nex = p.next            p.next = nex.next            nex.next = pre.next            pre.next = nex                return dump.next\n\n\n逻辑上稍微有点绕\n1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4先找到开始反转位置的前一个节点  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL  * prev    1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL  *     * prev   nex      +-----+     |     V  1-&gt;2  3-&gt;4-&gt;5-&gt;NULL  *     * prev   nex      +-----+     |      V  1-&gt;2  3  4-&gt;5-&gt;NULL     ^  |     +--+       +-----+    |     |  |  +--|----+  |  |  v    v  1  2  3  4-&gt;5-&gt;NULL     ^  |     +--+\n\n","tags":["leetcode","链表"]},{"title":"leetcode 93 复原IP地址","url":"/article/leetcode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/","content":"给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。\n示例:\n输入: &quot;25525511135&quot;输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]\n\nclass Solution(object):    def restoreIpAddresses(self, s):        &quot;&quot;&quot;        :type s: str        :rtype: List[str]        &quot;&quot;&quot;                def dfs(ans, t, level, s):            if level &lt; 4 and not s:                return             if level &gt; 4 and s:                return             if level == 4 and not s:                ans.add(&#x27;.&#x27;.join(t))                return             for i in range(1, 4):                temp = s[:i]                if temp and int(temp) &lt;= 255:                    if len(temp) &gt;= 2 and temp[0] == &#x27;0&#x27;:                        continue                    t.append(temp)                    dfs(ans, t, level+1, s[i:])                    t.pop()        ans = set()        dfs(ans, [], 0, s)        return ans\n","tags":["leetcode","字符串","回溯"]},{"title":"leetcode 90 子集 II","url":"/article/leetcode-90-%E5%AD%90%E9%9B%86-II/","content":"给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n说明：解集不能包含重复的子集。\n示例:\n输入: [1,2,2]输出:[  [2],  [1],  [1,2,2],  [2,2],  [1,2],  []]\n\n\n\ndfs\nclass Solution(object):    def subsetsWithDup(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;         ans = []         nums.sort()         def dfs(ans, t, nums, start):             if  t not in ans:                 ans.append(copy.copy(t))                             for i in range(start, len(nums)):                 if i &gt; start and nums[i] == nums[i-1]:                     continue                     t.append(nums[i])                 dfs(ans, t, nums, i+1)                 t.pop()                     dfs(ans, [], nums, 0)         return ans\n\n\n不排序\nclass Solution(object):    def subsetsWithDup(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        counter = collections.Counter(nums)        ans = [[]]        for n in counter:            temp = copy.copy(ans)            for i in ans:                temp.extend(i + [n]* c for c in range(1, counter[n]+1))            ans = copy.copy(temp)        return ans\n\n\n","tags":["leetcode","数组","回溯"]},{"title":"leetcode 96 不同的二叉搜索树","url":"/article/leetcode-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？\n示例:\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n1         3     3      2      1  \\       /     /      / \\      \\   3     2     1      1   3      2  /     /       \\                 \\ 2     1         2                 3\n\nclass Solution(object):    def numTrees(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: int        &quot;&quot;&quot;        if n == 1:            return 1        if n == 2:            return 2        if n == 3:            return 5        dp = [0 for i in range(n)]        dp[0] = 1        dp[1] = 2        dp[2] = 5        for i in range(3, n):            for j in range(i+1):                if j == 0:                    dp[i] += dp[i-1]                elif j==i:                    dp[i] += dp[i-1]                else:                    dp[i] += dp[j-1] * dp[i-j-1]        return dp[-1]\n","tags":["leetcode","tree"]},{"title":"leetcode 99 恢复二叉搜索树","url":"/article/leetcode-99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"二叉搜索树中的两个节点被错误地交换。\n请在不改变其结构的情况下，恢复这棵树。\n示例 1:\n输入: [1,3,null,null,2]\t 1  / 3  \\   2   输出: [3,1,null,null,2]   3  / 1  \\   2\n示例 2:\n输入: [3,1,4,null,null,2]  3 / \\1   4   /  2输出: [2,1,4,null,null,3]  2 / \\1   4   /  3\n进阶:\n使用 O(n) 空间复杂度的解法很容易实现。\n你能想出一个只使用常数空间的解决方案吗？\n\n\n\nO(n)的时间复杂度\n正确的中序遍历得到的数组应该是升序的，因此，中序遍历后，将得到的数组排序即是正确的数值分配，再将每一个位置的数值赋值到对应的node中去即可\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def recoverTree(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: None Do not return anything, modify root in-place instead.        &quot;&quot;&quot;        def dfs(root, nodeList, valueList):            if not root:                return             if root.left:                dfs(root.left, nodeList, valueList)            nodeList.append(root)            valueList.append(root.val)            if root.right:                dfs(root.right, nodeList, valueList)                    nodeList = []        valueList = []        dfs(root, nodeList, valueList)        valueList.sort()        for i, n in enumerate(valueList):            nodeList[i].val = n\n\n\n\n\n\nO(1)时间复杂度\nO(n)的复杂度主要来自于存储中序遍历的结果以及对应的Node顺序，有没有什么方法能够不保存顺序，直接找出需要交换数值的两个节点。\n对给定的这棵树：\n 1 /3 \\  2\n中序遍历的结果是\n3, 2, 1\n需要交换的两个节点first 和last分别是：\nfirst: 相邻两个数中第一次出现 prev &gt; cur 时的 prev\nlast：在first出现之后，又一次出现 prev &gt; cur 中的 cur\n  \n\n\n","tags":["leetcode","tree"]},{"title":"leetcode 94 二叉树的中序遍历","url":"/article/leetcode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"给定一个二叉树，返回它的中序 遍历。\n示例:\n输入: [1,null,2,3]   1    \\     2    /   3输出: [1,3,2]\n\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def inorderTraversal(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        ans = []        l = []        l.append(root)        while l:            p = l.pop()            # 向l中一直添加左子树            while p:                l.append(p)                p = p.left            while l:                p = l.pop()                ans.append(p.val)                if p.right:                    l.append(p.right)                    break        return ans                #         def recuisive(root, ans):#             if not root:#                 return #             if root.left:#                 recuisive(root.left, ans)#             ans.append(root.val)#             if root.right:#                 recuisive(root.right, ans)        #         ans = []#         recuisive(root, ans)#         return ans                                            \n","tags":["leetcode","tree"]},{"title":"leetcode 306 Addictive Number","url":"/article/leetcode-AdditiveNumber/","content":"Additive number is a string whose digits can form additive sequence.\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\nGiven a string containing only digits '0'-'9', write a function to determine if it’s an additive number.\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\nExample 1:\nInput: &quot;112358&quot;Output: true Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8.              1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\nExample 2:\nInput: &quot;199100199&quot;Output: true Explanation: The additive sequence is: 1, 99, 100, 199.              1 + 99 = 100, 99 + 100 = 199\nFollow up:\nHow would you handle overflow for very large input integers?\n\nimport java.util.ArrayList;public class AdditiveNumber &#123;    public boolean isAdditiveNumber(String num) &#123;    int n = num.length();    for (int i=1; i&lt;n; i++)&#123;      for (int j=i+1; j&lt;n; j++) &#123;        long a = parse(num.substring(0, i));        long b = parse(num.substring(i, j));        if (a == -1 || b == -1) continue;        if (helper(num.substring(j), a, b)) &#123;          return true;        &#125;      &#125;    &#125;    return false;  &#125;  public boolean helper(String s, long a, long b)&#123;    for (int i=1; i&lt;=s.length(); i++)&#123;      long c = parse(s.substring(0, i));      if (c == -1) continue;      if (c == a + b &amp;&amp; helper(s.substring(i), b, c))        return true;    &#125;    return false;  &#125;  public long parse(String s)&#123;    if (!s.equals(&quot;0&quot;) &amp;&amp; s.startsWith(&quot;0&quot;)) return -1;    long res = 0;    try&#123;      res = Long.parseLong(s);    &#125;    catch (Exception e)&#123;      res = -1;    &#125;    return res;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 95 不同的二叉搜索树 II","url":"/article/leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II/","content":"给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。\n示例:\n输入: 3输出:[  [1,null,3,2],  [3,2,null,1],  [3,1,null,null,2],  [2,1,3],  [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树：   1         3     3      2      1    \\       /     /      / \\      \\     3     2     1      1   3      2    /     /       \\                 \\   2     1         2                 3\n\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def generateTrees(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: List[TreeNode]        &quot;&quot;&quot;                def helper(l):            if not l:                return [None]            elif len(l) == 1:                return [TreeNode(l[0])]            ans = []            for i, n in enumerate(l):                for left in helper(l[:i]):                    for right in helper(l[i+1:]):                        root = TreeNode(n)                        if left is not None:                            root.left = left                        if right is not None:                            root.right = right                        ans.append(root)            return ans                if n &lt;= 0:            return []                return helper([i for i in range(1, n+1)])\n","tags":["leetcode","tree"]},{"title":"leetcode 94 Binary Tree Inorder Traversal","url":"/article/leetcode-BinaryThreeInOrderTravel/","content":"Given a binary tree, return the inordertraversal of its nodes’ values.\nExample:\nInput: [1,null,2,3]   1    \\     2    /   3Output: [1,3,2]\nFollow up: Recursive solution is trivial, could you do it iteratively?\n\nimport utils.TreeNode;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class BinaryThreeInOrderTravel &#123;  public List&lt;Integer&gt; inorderTraversalI(TreeNode root) &#123;    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();    travel(root, ans);    return ans;  &#125;  public void travel(TreeNode root, List&lt;Integer&gt; ans) &#123;    if (root == null) return ;    travel(root.left, ans);    ans.add(root.val);    travel(root.right, ans);  &#125;  public List&lt;Integer&gt; inorderTraversalII(TreeNode root) &#123;    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();    Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();    TreeNode t = root;    while (t != null || !s.isEmpty()) &#123;      while (t!= null) &#123;        s.push(t);        t = t.left;      &#125;      t = s.pop();      ans.add(t.val);      t = t.right;    &#125;    return ans;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 188 Best Time to Buy and Sell Stock IV","url":"/article/leetcode-BestTimetoBuyandSellStockIV/","content":"Say you have an array for which the ithelement is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete at most ktransactions.\nNote:\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\nExample 1:\nInput: [2,4,1], k = 2Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\nExample 2:\nInput: [3,2,6,5,0,3], k = 2Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\npublic class BestTimetoBuyandSellStockIV &#123;  public int maxProfit(int k, int[] prices) &#123;    // quick ans if k &gt; len(price)/2    if (k &gt;= prices.length / 2) &#123;      int profit = 0;      for (int i=1; i&lt;prices.length; i++) &#123;        if (prices[i] &gt; prices[i-1]) &#123;          profit += prices[i] - prices[i-1];        &#125;      &#125;      return profit;    &#125;    // while k &lt; len(price)/ 2, we need using dp solutions to solve the question.    // profit[i][j], means the max profit we could get when we have i transactions up to the j-th price;    int profit[][] = new int[k+1][prices.length];    for (int i=1; i&lt;=k; i++) &#123;      int max = -prices[0];      for (int j=0; j&lt;prices.length; j++) &#123;        profit[i][j] = Math.max(profit[i][j-1], prices[j] + max);        max = Math.max(max, profit[i-1][j-1]-prices[j]);      &#125;    &#125;    return profit[k][prices.length-1];  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 98 验证二叉搜索树","url":"/article/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：\n\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\n示例 1:\n输入:                      2                     / \\                    1   3输出: true\n示例 2:\n输入:                        5                       / \\                      1   4                         / \\                        3   6输出: false\n\n\n","tags":["leetcode","tree"]},{"title":"leetcode 103 Binary Tree Zigzag Level Order Traversal","url":"/article/leetcode-BinaryTreeZigzagLevelOrderTraversa/","content":"Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n  3 / \\9  20  /  \\ 15   7\nreturn its zigzag level order traversal as:\n[  [3],  [20,9],  [15,7]]\n\nimport utils.TreeNode;import java.util.ArrayList;import java.util.List;public class BinaryTreeZigzagLevelOrderTraversa &#123;  public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    helper(ans, root, 0);    return ans;  &#125;  public void helper(List&lt;List&lt;Integer&gt;&gt; ans, TreeNode root, int level) &#123;    if (root == null) return ;    if (ans.size() == level) &#123;      ans.add(new ArrayList&lt;&gt;());    &#125;    List&lt;Integer&gt; t = ans.get(level);    if (level % 2 == 0) &#123;      t.add(root.val);    &#125;    else      t.add(t.size()-1, root.val);    helper(ans, root.left, level+1);    helper(ans, root.right, level+1);  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 319 Bulb Switcher","url":"/article/leetcode-BulbSwitcher/","content":"There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the i-th round, you toggle every ibulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\nExample:\nInput: 3Output: 1 Explanation: At first, the three bulbs are [off, off, off].After first round, the three bulbs are [on, on, on].After second round, the three bulbs are [on, off, on].After third round, the three bulbs are [on, off, off]. So you should return 1, because there is only one bulb is on.\n\npublic class BulbSwitcher &#123;  /**   * There are n bulbs that are initially off. You first turn on all the bulbs.   * Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it&#x27;s off or turning off if it&#x27;s on).   * For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds.   *   * Example:   *   * Input: 3   * Output: 1   * Explanation:   * At first, the three bulbs are [off, off, off].   * After first round, the three bulbs are [on, on, on].   * After second round, the three bulbs are [on, off, on].   * After third round, the three bulbs are [on, off, off].   *   * So you should return 1, because there is only one bulb is on.   */  public int bulbSwitch(int n) &#123;        return (int) Math.sqrt(n);    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 299 Bulls and Cows","url":"/article/leetcode-BullsandCows/","content":"You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.\nWrite a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows.\nPlease note that both secret number and friend’s guess may contain duplicate digits.\nExample 1:\nInput: secret = &quot;1807&quot;, guess = &quot;7810&quot;Output: &quot;1A3B&quot;Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.\nExample 2:\nInput: secret = &quot;1123&quot;, guess = &quot;0111&quot;Output: &quot;1A1B&quot;Explanation: The 1st 1 in friend&#x27;s guess is a bull, the 2nd or 3rd 1 is a cow.\nNote: You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.\n\nimport java.util.Hashtable;public class BullsandCows &#123;  public static String getHint(String secret, String guess) &#123;    int cows = 0;    int bulls = 0;    int count1[] = new int[10];    int count2[] = new int[10];    for (int i=0; i&lt;secret.length(); i++) &#123;      if (secret.charAt(i) == guess.charAt(i))        bulls ++;      else &#123;        count1[secret.charAt(i)-&#x27;0&#x27;] += 1;        count2[guess.charAt(i)-&#x27;0&#x27;] += 1;      &#125;    &#125;    for (int i=0; i&lt;10; i++)&#123;      cows += Math.min(count1[i], count2[i]);    &#125;    return bulls + &quot;A&quot; + cows + &quot;B&quot;;  &#125;  public static void main(String[] args) &#123;    System.out.println(getHint(&quot;1123&quot;, &quot;0111&quot;));    System.out.println(getHint(&quot;1807&quot;, &quot;7810&quot;));  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 312 Burst Balloons","url":"/article/leetcode-BurstBalloons/","content":"Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and rightthen becomes adjacent.\nFind the maximum coins you can collect by bursting the balloons wisely.\nNote:\n\nYou may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.\n0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100\n\nExample:\nInput: [3,1,5,8]Output: 167 Explanation: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []             coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n\npublic class BurstBalloons &#123;    public int maxScore(int[] nums) &#123;        int[] newNums = new int[nums.length+2];        newNums[0] = 1;        newNums[newNums.length-1] = 1;        for (int i=0; i&lt;nums.length; i++) &#123;            newNums[i+1] = nums[i];        &#125;        int[][] dp = new int[newNums.length][newNums.length];        for (int k=2; k&lt;newNums.length; k++) &#123;            for (int left = 0; left + k &lt; newNums.length; left ++) &#123;                int right = left + k;                for (int i=left+1; i&lt;right; i++) &#123;                    dp[left][right] = Math.max(dp[left][right], dp[left][i-1] + dp[i+1][right] + newNums[i]*newNums[i-1]*newNums[i+1]);                &#125;            &#125;        &#125;        return dp[0][newNums.length-1];    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 377 Combination Sum IV","url":"/article/leetcode-CombinationSumIV/","content":"Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\nExample:\nnums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7.\nFollow up:\nWhat if negative numbers are allowed in the given array?\nHow does it change the problem?\nWhat limitation we need to add to the question to allow negative numbers?\nCredits:\nSpecial thanks to @pbrother for adding this problem and creating all test cases.\n\nimport java.util.ArrayList;import java.util.Collections;import java.util.List;public class CombinationSumIV &#123;  /*  Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.  Example:  nums = [1, 2, 3]  target = 4  The possible combination ways are:  (1, 1, 1, 1)  (1, 1, 2)  (1, 2, 1)  (1, 3)  (2, 1, 1)  (2, 2)  (3, 1)  Note that different sequences are counted as different combinations.  Therefore the output is 7.   */  // 可以，但是太耗时了。  static int count = 0;  public static int combinationSum4(int[] nums, int target) &#123;    List&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;();    dfs(nums, target, temp, 0);    return count;  &#125;  public static void dfs(int[] nums, int target, ArrayList&lt;Integer&gt; temp, int k)&#123;    int sum = 0;    for (int i: temp)&#123;      sum += i;    &#125;    if (sum == target)&#123;      count ++;      return ;    &#125;    else if (sum &gt; target)&#123;      return ;    &#125;    else &#123;      for (int i=0; i&lt;nums.length; i++)&#123;        temp.add(nums[i]);        dfs(nums, target, temp, k+1);        temp.remove(temp.size()-1);      &#125;    &#125;  &#125;  public static int combinationSum4DP(int[] nums, int target)&#123;    if (target == 0)&#123;      return 1;    &#125;    int res = 0;    for (int i=0; i&lt;nums.length; i++)&#123;      if (target &gt; nums[i])        res += combinationSum4DP(nums, target-nums[i]);    &#125;    return res;  &#125;  public static int combinationSum4DPII(int[] nums, int target)&#123;    int[] dp = new int[target+1];    dp[0] = 1;    for (int sum=1; sum&lt;=target; sum++)&#123;      for (int i=0; i&lt;nums.length; i++)&#123;        if (sum - nums[i] &gt;=0)          dp[sum] += dp[sum-nums[i]];      &#125;    &#125;    return dp[target];  &#125;  public static void main(String[] args)&#123;    System.out.println(combinationSum4(new int[]&#123;1,2,3&#125;, 32));  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 322 Coin Change","url":"/article/leetcode-CoinChange/","content":"You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nExample 1:\nInput: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1\nExample 2:\nInput: coins = [2], amount = 3Output: -1\nNote:\nYou may assume that you have an infinite number of each kind of coin.\n\nimport java.util.Arrays;import java.util.LinkedList;import java.util.Stack;public class CoinChange &#123;  /**   * You are given coins of different denominations and a total amount of money amount.   * Write a function to compute the fewest number of coins that you need to make up that amount.   * If that amount of money cannot be made up by any combination of the coins, return -1.   *   * Example 1:   *   * Input: coins = [1, 2, 5], amount = 11   * Output: 3   * Explanation: 11 = 5 + 5 + 1   * Example 2:   *   * Input: coins = [2], amount = 3   * Output: -1   * Note:   * You may assume that you have an infinite number of each kind of coin.   */  public int coinChange(int[] coins, int amount) &#123;    int[] dp = new int[amount+1];    Arrays.sort(coins);    Arrays.fill(dp, amount+1);    dp[0] = 0;    for (int i=1; i&lt;=amount; i++)&#123;      for (int j=0; j&lt;coins.length; j++)        if (i-coins[j] &gt;= 0)          dp[i] = Math.min(dp[i], dp[i-coins[j]] + 1);      &#125;    return dp[amount]==amount+1?-1:dp[amount];  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 105 Construct Binary Tree from Preorder and Inorder Traversal","url":"/article/leetcode-ConstructBinaryTreefromPreorderandInorderTraversal/","content":"Given preorder and inorder traversal of a tree, construct the binary tree.\nNote:\nYou may assume that duplicates do not exist in the tree.\nFor example, given\npreorder = [3,9,20,15,7]inorder = [9,3,15,20,7]\nReturn the following binary tree:\n  3 / \\9  20  /  \\ 15   7\n\nimport utils.TreeNode;import java.util.Arrays;public class ConstructBinaryTreefromPreorderandInorderTraversal &#123;  public TreeNode buildTree(int[] preorder, int[] inorder) &#123;    return helper(preorder, inorder, 0, preorder.length, 0, inorder.length);  &#125;  public TreeNode helper(int[] preorder, int[] inorder, int prel, int prer, int inl ,int inr) &#123;    if (inl == inr) return new TreeNode(inorder[inl]);    TreeNode root = new TreeNode(preorder[prel]);    int i = inl;    for (i = inl; i&lt;inr; i++) &#123;      if (inorder[i] == root.val) &#123;        break;      &#125;    &#125;    root.left = helper(preorder, inorder, prel+1,prel+(i-inl), inl, i-1);    root.right = helper(preorder, inorder, prel+(i-inl)+1, prer, i+1, inr);    return root;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 138 Copy List with Random Pointer","url":"/article/leetcode-CopyListwithRandomPointer/","content":"A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\nReturn a deep copy of the list.\nExample 1:\n\nInput:&#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;Explanation:Node 1&#x27;s value is 1, both of its next and random pointer points to Node 2.Node 2&#x27;s value is 2, its next pointer points to null and its random pointer points to itself.\nNote:\n\nYou must return the copy of the given head as a reference to the cloned list.\n\n\nimport utils.Node;import java.util.HashSet;import java.util.Hashtable;public class CopyListwithRandomPointer &#123;  /**   * Copy List with Random Pointer   */  public static Node copyRandomList(Node head) &#123;    if (head == null) return null;    Hashtable&lt;Node, Node&gt; m = new Hashtable&lt;&gt;();    Node p = head;    // copy all the node, put it to the map    while (p != null) &#123;      Node t = new Node();      t.val = p.val;      m.put(p, t);      p = p.next;    &#125;    p = head;    while(p != null) &#123;      m.get(p).next = m.get(p.next);      m.get(p).random = m.get(p.random);      p = p.next;    &#125;    return m.get(head);  &#125;  public  static  void  main(String[] args) &#123;//    Node head = new Node();//    Node t1 = new Node();//    Node t2 = new Node();//    head.val=1;//    t1.val = 2;//    t2.val = 3;//    head.next = t1;//    t1.next = t2;//    t2.next = null;////    Node r = copyRandomList(head);//    while(r != null) &#123;//      System.out.println(r.val);//      r = r.next;      System.out.println(((double)94911150/(double)94911151) + &quot; &quot; + ( (double)94911151/(double)94911152));//    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 357 Count Numbers with Unique Digits","url":"/article/leetcode-CountNumberswithUniqueDigits/","content":"Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n.\nExample:\nInput: 2Output: 91 Explanation: The answer should be the total numbers in the range of 0 ≤ x &lt; 100,              excluding 11,22,33,44,55,66,77,88,99\n\npublic class CountNumberswithUniqueDigits &#123;  /*      Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10^n.      Example:      Input: 2      Output: 91      Explanation: The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding 11,22,33,44,55,66,77,88,99   */  public int countNumbersWithUniqueDigits(int n) &#123;    if (n&lt;1)&#123;      return 1;    &#125;    else if (n==1)&#123;      return 10;    &#125;    else if (n&gt;10)&#123;      n = 10;    &#125;    return countNumbersWithUniqueDigits(n-1) + (countNumbersWithUniqueDigits(n-1) - countNumbersWithUniqueDigits(n-2)) * (10-(n-1));  &#125;&#125;```","tags":["leetcode"]},{"title":"leetcode 338 Counting Bits","url":"/article/leetcode-CountingBits/","content":"Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.\nExample 1:\nInput: 2Output: [0,1,1]\nExample 2:\nInput: 5Output: [0,1,1,2,1,2]\nFollow up:\n\nIt is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?\nSpace complexity should be O(n).\nCan you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.\n\n\nimport java.util.ArrayList;public class CountingBits &#123;  /**   * Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&#x27;s in their binary representation and return them as an array.   *   * Example 1:   *   * Input: 2   * Output: [0,1,1]   * Example 2:   *   * Input: 5   * Output: [0,1,1,2,1,2]   * Follow up:   *   * It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?   * Space complexity should be O(n).   * Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.   */  public int[] countBits(int num) &#123;    int[] dp = new int[num + 1];    dp[0] = 0;    int width = 1;    for (int i=1; i&lt;=num; i++)&#123;      dp[i] = dp[i-width] + 1;      if (width == i)&#123;        width *= 2;      &#125;    &#125;    return dp;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 321 Create Maximum Number","url":"/article/leetcode-CreateMaximumNumber/","content":"Given two arrays of length m and n with digits 0-9representing two numbers. Create the maximum number of length k &lt;= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits.\nNote: You should try to optimize your time and space complexity.\nExample 1:\nInput:nums1 = [3, 4, 6, 5]nums2 = [9, 1, 2, 5, 8, 3]k = 5Output:[9, 8, 6, 5, 3]\nExample 2:\nInput:nums1 = [6, 7]nums2 = [6, 0, 4]k = 5Output:[6, 7, 6, 0, 4]\nExample 3:\nInput:nums1 = [3, 9]nums2 = [8, 9]k = 3Output:[9, 8, 9]\n\npublic class CreateMaximumNumber &#123;    public int[] maxNumber(int[] nums1, int[] nums2, int k) &#123;        int m = nums1.length;        int n = nums2.length;        int[] result = new int[k];        if (m + n &lt; k) return result;        else if (m+n == k) &#123;            result = merge(nums1, nums2);            return result;        &#125;        else &#123;            for (int i=1; i&lt;=k; i++) &#123;                if (i&lt;nums1.length &amp;&amp; k-i &lt; nums2.length) &#123;                    int[] l1 = largestK(nums1, i);                    int[] l2 = largestK(nums2, k-i);                    int[] total = merge(l1, l2);                    if (isLarger(total, result))                        result = total;                &#125;            &#125;        &#125;        return result;    &#125;    public boolean isLarger(int[] current, int[] old) &#123;        for(int i=0; i&lt;current.length; i++) &#123;            if (current[i] &gt; old[i])                return true;        &#125;        return false;    &#125;    public int[] largestK(int[] nums, int k) &#123;        int t = 0;        int[] ans = new int[k];        for (int i=0; i&lt;nums.length; i++) &#123;            int remain = nums.length - i - 1;            while (remain + (t+1) &gt; k &amp;&amp; t &gt; 0 &amp;&amp; nums[i] &gt; ans[t-1]) &#123;                t --;            &#125;            if (t &lt; k)                ans[t++] = nums[i];        &#125;        return  ans;    &#125;    public int[] merge(int[] nums1, int[] nums2) &#123;        int i=0;        int j=0;        int t=0;        int [] result = new int[nums1.length + nums2.length];        while (i &lt; nums1.length || j &lt; nums2.length) &#123;            if (i &gt;= nums1.length) &#123;                result[t++] = nums2[j++];            &#125;            else if (j &gt;= nums2.length) &#123;                result[t++] = nums1[i++];            &#125;            else if (nums1[i] &lt; nums2[j]) &#123;                result[t++] = nums2[j++];            &#125;            else &#123;                result[t++] = nums1[i++];            &#125;        &#125;        return result;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode DecodeString","url":"/article/leetcode-DecodeString/","content":"import java.util.Stack;public class DecodeString &#123;  /**   * Given an encoded string, return it&#x27;s decoded string.   *   * The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times.   * Note that k is guaranteed to be a positive integer.   *   * You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.   *   * Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.   * For example, there won&#x27;t be input like 3a or 2[4].   *   * Examples:   *   * s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.   * s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.   * s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;.   */  public String decodeString(String s) &#123;    Stack&lt;String&gt; stringStack = new Stack&lt;&gt;();    Stack&lt;Integer&gt; numStack = new Stack&lt;&gt;();    String temp = &quot;&quot;;    for (int i=0; i&lt;s.length(); i++)&#123;      if (Character.isDigit(s.charAt(i)))&#123;        int count = s.charAt(i) - &#x27;0&#x27;;        while(Character.isDigit(s.charAt(i+1)))&#123;          count = count*10+ s.charAt(i) - &#x27;0&#x27;;          i = i+1;        &#125;        numStack.push(count);      &#125;      else if (s.charAt(i) == &#x27;[&#x27;)&#123;        stringStack.push(temp);        temp = &quot;&quot;;      &#125;      else if (s.charAt(i) == &#x27;]&#x27;)&#123;        StringBuilder sb = new StringBuilder(stringStack.pop());        int repeatTime = numStack.pop();        for (int j=0; j&lt;repeatTime; j++)&#123;          sb.append(temp);        &#125;        temp = sb.toString();      &#125;      else&#123;        temp = temp + s.charAt(i);      &#125;    &#125;    return temp;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  DecodeWays","url":"/article/leetcode-DecodeWays/","content":"public class DecodeWays &#123;    public int numDecodings(String s) &#123;        if (s.length() == 0) &#123;            return 0;        &#125;        int[] dp = new int[s.length()+1];        dp[s.length()] = 1;        dp[s.length()-1] = s.charAt(s.length()-1) == 0? 0: 1;        for (int i=s.length()-2; i&gt;=0; i--) &#123;            if (s.charAt(i) == &#x27;0&#x27;) continue;            if (Integer.parseInt(s.substring(i, i+2))&lt;=26)                dp[i] = dp[i+1] + dp[i+2];            else                dp[i] = dp[i+1];        &#125;        return dp[0];    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  EditDistance","url":"/article/leetcode-EditDistance/","content":"public class EditDistance &#123;    /*    Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.    You have the following 3 operations permitted on a word:    Insert a character    Delete a character    Replace a character    &quot;zoologicoarchaeologist&quot;    &quot;zoo  g        eologist&quot;     */    public static void main(String[] args)&#123;        System.out.print(editDistance(&quot;zoo&quot;, &quot;zo&quot;));    &#125;    public static int editDistance(String a, String b)&#123;        int m = a.length();        int n = b.length();        int[][] matrix = new int[m+1][n+1];        for (int i=0; i&lt;=n; i++)&#123;            matrix[0][i] = i;        &#125;        for (int i=0; i&lt;=m; i++)&#123;            matrix[i][0] = i;        &#125;        for (int i=1; i&lt;=m; i++)&#123;            for(int j=1; j&lt;=n; j++)&#123;                if (a.charAt(i-1) == b.charAt(j-1))&#123;                    matrix[i][j] = Math.min(Math.min(matrix[i-1][j-1], matrix[i][j-1]+1), matrix[i-1][j]+1);                &#125;                else &#123;                    matrix[i][j] = Math.min(Math.min(matrix[i-1][j-1], matrix[i][j-1]), matrix[i-1][j]) + 1;                &#125;            &#125;        &#125;        for (int i=0; i&lt;=m; i++)&#123;            for (int j=0; j&lt;=n; j++)&#123;                System.out.print(matrix[i][j] + &quot;\\t&quot;);            &#125;            System.out.println();        &#125;        return matrix[m][n];    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  EliminationGame","url":"/article/leetcode-EliminationGame/","content":"public class EliminationGame &#123;  /**   * There is a list of sorted integers from 1 to n. Starting from left to right,   * remove the first number and every other number afterward until you reach the end of the list.   *   * Repeat the previous step again, but this time from right to left,   * remove the right most number and every other number from the remaining numbers.   *   * We keep repeating the steps again, alternating left to right and right to left,   * until a single number remains.   *   * Find the last number that remains starting with a list of length n.   *   * Example:   *   * Input:   * n = 9,   * 1 2 3 4 5 6 7 8 9   * 2 4 6 8   * 2 6   * 6   *   * Output:   * 6   */  public int lastRemaining(int n) &#123;    boolean left = true;    int head = 1;    int step = 1;    int remain = n;    while(remain !=1)&#123;      if (left || remain%2 == 1)&#123;        head = head + step;      &#125;      remain = remain/2;      step = step * 2;      left = !left;    &#125;    return head;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  DifferentWaystoAddParentheses","url":"/article/leetcode-DifferentWaystoAddParentheses/","content":"import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class DifferentWaystoAddParentheses &#123;  /**   * Given a string of numbers and operators, return all possible results from computing all the different possible ways   * to group numbers and operators. The valid operators are +, - and *.   *   * Example 1:   *   * Input: &quot;2-1-1&quot;   * Output: [0, 2]   * Explanation:   * ((2-1)-1) = 0   * (2-(1-1)) = 2   * Example 2:   *   * Input: &quot;2*3-4*5&quot;   * Output: [-34, -14, -10, -10, 10]   * Explanation:   * (2*(3-(4*5))) = -34   * ((2*3)-(4*5)) = -14   * ((2*(3-4))*5) = -10   * (2*((3-4)*5)) = -10   * (((2*3)-4)*5) = 10   * @param input   * @return   */  public List&lt;Integer&gt; diffWaysToCompute(String input) &#123;    if (isDigital(input)) return Arrays.asList(Integer.parseInt(input));    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();    for (int i=0; i&lt;input.length(); i++) &#123;      if (input.charAt(i) == &#x27;-&#x27; || input.charAt(i) == &#x27;+&#x27; || input.charAt(i) == &#x27;*&#x27;) &#123;        List&lt;Integer&gt; left = diffWaysToCompute(input.substring(0, i));        List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i+1));        for (int l: left) &#123;          for (int r: right) &#123;            ans.add(cal(l, r, input.charAt(i)));          &#125;        &#125;      &#125;    &#125;    return ans;  &#125;  boolean isDigital(String s) &#123;    int i = 0;    if (s.charAt(0) == &#x27;-&#x27;) &#123;      i++;    &#125;    while(i&lt;s.length()) &#123;      if (Character.isDigit(s.charAt(i))) &#123;        i++;      &#125;      else return false;    &#125;    return true;  &#125;  int cal(int l, int r, char op) &#123;    if (op == &#x27;-&#x27;) return l-r;    if (op == &#x27;+&#x27;) return l+r;    if (op == &#x27;*&#x27;) return l*r;    return 0;  &#125;  public static void main(String[] args) &#123;    String s = &quot;2*3-4*5&quot;;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  FindKPairswithSmallestSums","url":"/article/leetcode-FindKPairswithSmallestSums/","content":"import java.util.ArrayList;import java.util.List;import java.util.PriorityQueue;public class FindKPairswithSmallestSums &#123;  /**   * You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.   *   * Define a pair (u,v) which consists of one element from the first array and one element from the second array.   *   * Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.   *   * Example 1:   *   * Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3   * Output: [[1,2],[1,4],[1,6]]   * Explanation: The first 3 pairs are returned from the sequence:   *              [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]   * Example 2:   *   * Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2   * Output: [1,1],[1,1]   * Explanation: The first 2 pairs are returned from the sequence:   *              [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]   * Example 3:   *   * Input: nums1 = [1,2], nums2 = [3], k = 3   * Output: [1,3],[2,3]   * Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]   */  public List&lt;int[]&gt; solution(int[] nums1, int[] nums2, int k)&#123;    PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0]+a[1]-b[0]-b[1]);    List&lt;int[]&gt; ans = new ArrayList&lt;&gt;();    for (int i=0; i&lt;nums1.length &amp;&amp; i&lt;k; i++)&#123;      pq.offer(new int[]&#123;nums1[i], nums2[0], 0&#125;);    &#125;    while(k &gt; 0 &amp;&amp; !pq.isEmpty())&#123;      int[] t = pq.poll();      ans.add(t);      if (t[2] == nums2.length)        continue;      pq.offer(new int[]&#123;t[0], nums2[t[3]+1], t[3]+1&#125;);      k--;    &#125;    return ans;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  FindPeakElement","url":"/article/leetcode-FindPeakElement/","content":"public class FindPeakElement &#123;    /**     * A peak element is an element that is greater than its neighbors.     *     * Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.     *     * The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.     *     * You may imagine that nums[-1] = nums[n] = -∞.     *     * Example 1:     *     * Input: nums = [1,2,3,1]     * Output: 2     * Explanation: 3 is a peak element and your function should return the index number 2.     * Example 2:     *     * Input: nums = [1,2,1,3,5,6,4]     * Output: 1 or 5     * Explanation: Your function can return either index number 1 where the peak element is 2,     *              or index number 5 where the peak element is 6.     * Note:     *     * Your solution should be in logarithmic complexity.     */    public int findPeakElement(int[] nums) &#123;        int left = 0;        int right = nums.length-1;        while (left &lt; right) &#123;            int mid = (left + right)/2;            if ( !((mid-1&gt;=0 &amp;&amp; nums[mid]&lt;nums[mid-1]) || (mid+1&lt;nums.length &amp;&amp; nums[mid] &lt; nums[mid+1]))) &#123;                return mid;            &#125;            if (mid-1&gt;=0 &amp;&amp; nums[mid-1] &gt; nums[mid])&#123;                right = mid-1;            &#125;            else if (mid+1&gt;nums.length &amp;&amp; nums[mid+1]&gt;nums[mid]) &#123;                left = mid+1;            &#125;        &#125;        return left;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  FirstUniqueCharacterinaString","url":"/article/leetcode-FirstUniqueCharacterinaString/","content":"import java.util.HashMap;public class FirstUniqueCharacterinaString &#123;  /**   * Given a string, find the first non-repeating character in it and return it&#x27;s index. If it doesn&#x27;t exist, return -1.   *   * Examples:   *   * s = &quot;leetcode&quot;   * return 0.   *   * s = &quot;loveleetcode&quot;,   * return 2.   * Note: You may assume the string contain only lowercase letters.   *   * @param s   * @return   */  public int firstUniqChar(String s)&#123;    int[] l = new int[26];    for (char c: s.toCharArray())&#123;      l[c-&#x27;a&#x27;] ++;    &#125;    for (int i=0; i&lt;s.length(); i++)&#123;      if (l[s.charAt(i)-&#x27;a&#x27;] == 1)&#123;        return i;      &#125;    &#125;    return -1;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  FindDifference","url":"/article/leetcode-FindDifference/","content":"public class FindDifference &#123;  /**   * Given two strings s and t which consist of only lowercase letters.   *   * String t is generated by random shuffling string s and then add one more letter at a random position.   *   * Find the letter that was added in t.   *   * Example:   *   * Input:   * s = &quot;abcd&quot;   * t = &quot;abcde&quot;   *   * Output:   * e   *   * Explanation:   * &#x27;e&#x27; is the letter that was added.   */  public static char findTheDiffence(String s, String t)&#123;    int[] l = new int[26];    for (char i: s.toCharArray())      l[i-&#x27;a&#x27;]++;    for (char j: t.toCharArray())      if (--l[j-&#x27;a&#x27;] &lt; 0)        return j;    return &#x27;a&#x27;;  &#125;  public static void main(String[] s)&#123;    String a = &quot;abce&quot;;    String b = &quot;dabce&quot;;    System.out.println(findTheDiffence(a, b));  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  GameOfLife","url":"/article/leetcode-GameOfLife/","content":"public class GameOfLife &#123;  /**   * According to the Wikipedia&#x27;s article:   * &quot;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&quot;   *   * Given a board with m by n cells, each cell has an initial state live (1) or dead (0).   * Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules   * (taken from the above Wikipedia article):   *   * Any live cell with fewer than two live neighbors dies, as if caused by under-population.   * Any live cell with two or three live neighbors lives on to the next generation.   * Any live cell with more than three live neighbors dies, as if by over-population..   * Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.   * Write a function to compute the next state (after one update) of the board given its current state.   * The next state is created by applying the above rules simultaneously to every cell in the current state,   * where births and deaths occur simultaneously.   *   * Example:   *   * Input:   * [   *   [0,1,0],   *   [0,0,1],   *   [1,1,1],   *   [0,0,0]   * ]   * Output:   * [   *   [0,0,0],   *   [1,0,1],   *   [0,1,1],   *   [0,1,0]   * ]   *   * Follow up:   *   * Could you solve it in-place? Remember that the board needs to be updated at the same time:   * You cannot update some cells first and then use their updated values to update other cells.   * In this question, we represent the board using a 2D array. In principle,   * the board is infinite, which would cause problems when the active area encroaches the border of the array.   * How would you address these problems?   */  public void solution(int[][] matrix)&#123;    if (matrix == null || matrix.length == 0)      return ;    int index[][] = &#123;&#123;1,-1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;-1,1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;;    for (int i=0; i&lt;matrix.length; i++)&#123;      for (int j=0; j&lt;matrix[0].length; j++)&#123;        int live = 0;        for (int[]ind: index)&#123;          if (i+ind[0]&lt;0 || i+ind[0]&gt;=matrix.length || j+ind[1]&lt;0 || j+ind[1]&gt;=matrix[0].length) continue;          else if (matrix[i+ind[0]][j+ind[1]] == 1 || matrix[i+ind[0]][j+ind[1]] == 2 ) live ++;        &#125;        if (matrix[i][j] == 0 &amp;&amp; live == 3) matrix[i][j] = 3;        if (matrix[i][j] == 1 &amp;&amp; (live&lt;2 || live&gt;3)) matrix[i][j] = 2;      &#125;    &#125;    for (int i=0; i&lt;matrix.length; i++)&#123;      for (int j=0; j&lt;matrix[0].length; j++) &#123;      matrix[i][j] = matrix[i][j] % 2;      &#125;    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  GroupAnagrams","url":"/article/leetcode-GroupAnagrams/","content":"import java.util.Arrays;import java.util.HashMap;import java.util.LinkedList;import java.util.List;public class GroupAnagrams &#123;  public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;    HashMap&lt;Integer, LinkedList&lt;String&gt;&gt; m = new HashMap&lt;Integer, LinkedList&lt;String&gt;&gt;();    for (String s: strs) &#123;      int key = 0;      char[] cs = s.toCharArray();      for (char c: cs) &#123;        key |= 1 &lt;&lt; c - &#x27;a&#x27;;      &#125;      if (!m.containsKey(key)) &#123;        m.put(key, new LinkedList&lt;&gt;());      &#125;      m.get(key).add(s);    &#125;    List&lt;List&lt;String&gt;&gt; ans = new LinkedList&lt;&gt;();    for (LinkedList l : m.values()) &#123;      ans.add(l);    &#125;    return ans;  &#125;  public static void main(String[] args) &#123;    String s = &quot;fdasf&quot;;    char[] c = s.toCharArray();    Arrays.sort(c);    System.out.println(String.valueOf(c));  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  GuessNumberHigherorLowerII","url":"/article/leetcode-GuessNumberHigherorLowerII/","content":"public class GuessNumberHigherorLowerII &#123;  /**   * We are playing the Guess Game. The game is as follows:   *   * I pick a number from 1 to n. You have to guess which number I picked.   *   * Every time you guess wrong, I&#x27;ll tell you whether the number I picked is higher or lower.   *   * However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.   *   * Example:   *   * n = 10, I pick 8.   *   * First round:  You guess 5, I tell you that it&#x27;s higher. You pay $5.   * Second round: You guess 7, I tell you that it&#x27;s higher. You pay $7.   * Third round:  You guess 9, I tell you that it&#x27;s lower. You pay $9.   *   * Game over. 8 is the number I picked.   *   * You end up paying $5 + $7 + $9 = $21.   * Given a particular n ≥ 1, find out how much money you need to have to guarantee a win.   */  public  int getMoneyAmount(int n) &#123;    int[][] dp = new int[n+1][n+1];    int ans = Integer.MAX_VALUE;    return helper(dp, 1, n);  &#125;  public  int helper(int[][] dp, int left, int right)&#123;    if (dp[left][right] != 0) return dp[left][right];    if (left &gt;= right) return 0;    int min = Integer.MAX_VALUE;    for (int i=left; i&lt;=right; i++)&#123;      int temp = i + Math.max(helper(dp, left, i-1), helper(dp, i+1, right));      min = Math.min(temp, min);    &#125;    dp[left][right] = min;    return min;  &#125;  public static void main(String[] args)&#123;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  HIndex","url":"/article/leetcode-HIndex/","content":"public class HIndex &#123;  public static int solution(int[] citations)&#123;    /**     *  citations: sorted arrays     *     * Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&#x27;s h-index.     *     * According to the definition of h-index on Wikipedia: &quot;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.&quot;     *     * Example:     *     * Input: citations = [0,1,3,5,6]     * Output: 3     * Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had     *              received 0, 1, 3, 5, 6 citations respectively.     *              Since the researcher has 3 papers with at least 3 citations each and the remaining     *              two with no more than 3 citations each, her h-index is 3.     * Note:     *     * If there are several possible values for h, the maximum one is taken as the h-index.     *     * Follow up:     *     * This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order.     * Could you solve it in logarithmic time complexity?     */    int n = citations.length;    int left = 0;    int right = n;    while(left &lt;= right)&#123;      int mid = (left+right) &gt;&gt; 1;      if (citations[mid] == n-mid)&#123;        return citations[mid];      &#125;      else if (citations[mid] &lt; n-mid)&#123;        left = mid+1;      &#125;      else        right = mid-1;    &#125;    return n-(right+1);  &#125;  public static void main(String[] args)&#123;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  IncreasingTripletSubsequence","url":"/article/leetcode-IncreasingTripletSubsequence/","content":"public class IncreasingTripletSubsequence &#123;  /**   * Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.   *   * Formally the function should:   *   * Return true if there exists i, j, k   * such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.   * Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.   *   * Example 1:   *   * Input: [1,2,3,4,5]   * Output: true   * Example 2:   *   * Input: [5,4,3,2,1]   * Output: false   */  public boolean increasingTriplet(int[] nums) &#123;    int[] t = new int[3];    t[0] = Integer.MIN_VALUE;    int idx = -1;    for (int i=0; i&lt;nums.length; i++)&#123;      if (idx == -1)        t[++idx] = nums[i];      else&#123;        if (nums[i] &gt; t[idx])&#123;          t[++idx] = nums[i];        &#125;        else if (nums[i] &lt; t[idx])&#123;          if (idx == 1 || nums[i] &lt; t[0])&#123;            t[0] = nums[i];          &#125;          else if (nums[i] &gt; t[0] &amp;&amp; nums[i] &lt; t[1])&#123;            t[i] = nums[i];          &#125;        &#125;        else&#123;          continue;        &#125;      &#125;      if (idx == 2)&#123;        return true;      &#125;    &#125;    return false;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  HouseRobberIII","url":"/article/leetcode-HouseRobberIII/","content":"import utils.TreeNode;public class HouseRobberIII &#123;  /**   * The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &quot;root.&quot; Besides the root, each house has one and only one parent house.   * After a tour, the smart thief realized that &quot;all houses in this place forms a binary tree&quot;.   * It will automatically contact the police if two directly-linked houses were broken into on the same night.   *   * Determine the maximum amount of money the thief can rob tonight without alerting the police.   *   * Example 1:   *   * Input: [3,2,3,null,3,null,1]   *   *      3   *     / \\   *    2   3   *     \\   \\   *      3   1   *   * Output: 7   * Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.   * Example 2:   *   * Input: [3,4,5,1,3,null,1]   *   *      3   *     / \\   *    4   5   *   / \\   \\   *  1   3   1   *   * Output: 9   * Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.   */  public int rob(TreeNode root) &#123;    if (root == null) return 0;    TreeNode left = root.left;    TreeNode right = root.right;    if (left == null &amp;&amp; right == null) return root.val;    if (left == null)      return Math.max(rob(left)+rob(right), root.val + rob(right.left) + rob(left.left));    if (right == null)      return Math.max(rob(left)+rob(right), root.val + rob(left.left) + rob(left.right));    return Math.max(rob(left)+rob(right), root.val + rob(left.left) + rob(left.right) + rob(right.left) + rob(left.left));  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  InsertionSortList","url":"/article/leetcode-InsertionSortList/","content":"import utils.ListNode;public class InsertionSortList &#123;    /*    Sort a linked list using insertion sort.    A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.    With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list    Algorithm of Insertion Sort:    Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.    At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.    It repeats until no input elements remain.     */    public static ListNode insertionSortList(ListNode head) &#123;        if (head == null) return null;        ListNode p = head;        ListNode start = new ListNode(0);        start.next = head;        while(p.next != null)&#123;            ListNode next = p.next;            if (next.val &lt;= start.next.val)&#123;                p.next = next.next;                next.next = start.next;                start.next = next;            &#125;            else if (next.val &gt;= p.val)&#123;                p = next.next;            &#125;            else&#123;                p.next = next.next;                ListNode low = start.next;                while(low.val &lt; next.val)&#123;                    low = low.next;                &#125;                ListNode one = start.next;                while(one.next != low)&#123;                    one = one.next;                &#125;                next.next = one.next;                one.next = next;            &#125;        &#125;        return start.next;    &#125;    public static void main(String[] args)&#123;        ListNode a = new ListNode(0);    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  IntegerBreak","url":"/article/leetcode-IntegerBreak/","content":"import java.util.ArrayList;public class IntegerBreak &#123;  /**   * Integer Break   * Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.   *   * Example 1:   *   * Input: 2   * Output: 1   * Explanation: 2 = 1 + 1, 1 × 1 = 1.   * Example 2:   *   * Input: 10   * Output: 36   * Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.   * Note: You may assume that n is not less than 2 and not larger than 58.   */  // this solution may couse time execeeding.  public int integerBreak(int n) &#123;    ArrayList&lt;Integer&gt; t = new ArrayList&lt;&gt;();    ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();    dfs(1, n-1, t, n, ans);    int max = 0;    for (int i: ans)&#123;      max = Math.max(max, i);    &#125;    return max;  &#125;  public void dfs(int start, int end, ArrayList&lt;Integer&gt; t, int sum, ArrayList&lt;Integer&gt; last)&#123;    if (sum == 0)&#123;      int ans = 1;      for (int num: t)&#123;        ans *= num;      &#125;      last.add(ans);      return ;    &#125;    if (sum &lt; 0) return ;    for (int i=start; i&lt;=end; i++)&#123;      t.add(i);      dfs(start, end, t, sum-i, last);      t.remove(t.size()-1);    &#125;  &#125;  // math solution.  public int intetBreakerII(int n)&#123;    if (n == 1 || n == 2) return 1;    int max = 0;    for (int i=2; i&lt;n; i++)&#123;      max = Math.max(max, helper(n, i));    &#125;    return max;  &#125;  public int helper(int n, int i)&#123;    // i: stands for there&#x27;re i numbers that sums up to n, we want distribute numbers near equally to each number.    int base = n/i;    int left = n%i;    int production = 1;    for (int j=0; j&lt;i; j++)&#123;      if (left-- &gt; 0)&#123;        production *= (base + 1);      &#125;      else&#123;        production *= base;      &#125;    &#125;    return production;  &#125;  // dp solution. dp[i] = max(j*dp[i-j]) for 1&lt;= j&lt;= i;  public int intetBreakerIII(int n)&#123;    int[] dp = new int[n];    int max = 0;    dp[1] = 1;    dp[2] = 1;    for (int i=2; i&lt;=n; i++)&#123;      for (int j=1; j&lt;i; j++)&#123;        max = Math.max(max, j*dp[i-j]);      &#125;    &#125;    return max;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  IntegerReplacement","url":"/article/leetcode-IntegerReplacement/","content":"import java.util.Hashtable;public class IntegerReplacement &#123;  /**   * Given a positive integer n and you can do operations as follow:   *   * If n is even, replace n with n/2.   * If n is odd, you can replace n with either n + 1 or n - 1.   * What is the minimum number of replacements needed for n to become 1?   *   * Example 1:   *   * Input:   * 8   * Output:   * 3   * Explanation:   * 8 -&gt; 4 -&gt; 2 -&gt; 1   *   * Example 2:   * Input:   * 7   * Output:   * 4   * Explanation:   * 7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1   * or   * 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1   */  // dp methods may get a correct answer but will get a memory exceed  public int solutionDP(int n)&#123;    int[] dp = new int[n+1];    dp[1] = 0;    dp[2] = 1;    for (int i=3; i&lt;n; i++)&#123;      if (i%2 == 0)&#123;        dp[i] = dp[i/2] + 1;      &#125;      else&#123;        dp[i] = Math.min(dp[(i-1)/2]+1, dp[(i+1)/2]+2);      &#125;    &#125;    return dp[n];  &#125;  // 用递归的方式  public int solutionRecuitive(int n)&#123;    if (n == 1) return 0;    if (n == 2) return 1;    else&#123;      if (n%2 == 0)&#123;        return solutionRecuitive(n/2) + 1;      &#125;      else &#123;        return Math.min(solutionRecuitive(n - 1) + 1, solutionRecuitive((n + 1) / 2) + 2); // 这里n+1可能会造成溢出，应该换成1 +（n-1）/2      &#125;    &#125;  &#125;  // 进一步优化，可以使用哈希表来存储已经计算过的中间变量  public int solutionHashTable(int n)&#123;    Hashtable&lt;Integer, Integer&gt; ht = new Hashtable&lt;&gt;();    ht.put(1, 0);    ht.put(2, 1);    helper(n, ht);    return ht.get(n);  &#125;  public int helper(int n, Hashtable&lt;Integer, Integer&gt; ht)&#123;    if (ht.containsKey(n)) return ht.get(n);    int step;    if (n%2 == 0)&#123;      step = helper(n/2, ht) + 1;    &#125;    else      step = Math.min(helper(n-1, ht)+1, helper((n+1)/2, ht)+2);    ht.put(n, step);    return step;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  IntersectionofTwoArraysII","url":"/article/leetcode-IntersectionofTwoArraysII/","content":"import java.util.Arrays;import java.util.HashSet;import java.util.LinkedList;public class IntersectionofTwoArraysII &#123;  /**   * Given two arrays, write a function to compute their intersection.   *   * Example 1:   *   * Input: nums1 = [1,2,2,1], nums2 = [2,2]   * Output: [2,2]   * Example 2:   *   * Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]   * Output: [4,9]   * Note:   *   * Each element in the result should appear as many times as it shows in both arrays.   * The result can be in any order.   * Follow up:   *   * What if the given array is already sorted? How would you optimize your algorithm?   * What if nums1&#x27;s size is small compared to nums2&#x27;s size? Which algorithm is better?   * What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?   */  // sort version  public int[] intersect(int[] nums1, int[] nums2) &#123;    Arrays.sort(nums1);    Arrays.sort(nums2);    int i=0;    int j=0;    LinkedList&lt;Integer&gt; l = new LinkedList&lt;&gt;();    while(i&lt;nums1.length &amp;&amp; j&lt;nums2.length)&#123;      if (nums1[i] == nums2[j])&#123;        l.add(nums1[i]);        while(i+1&lt;nums1.length &amp;&amp; nums1[i+1] == nums2[i])          i++;        while(j+1&lt;nums2.length &amp;&amp; nums2[j+1] == nums2[j])          j++;      &#125;      else if (nums1[i] &lt; nums2[j])&#123;        i++;      &#125;      else        j++;    &#125;    int[] res = new int[l.size()];    for (int k=0; k&lt;l.size(); k++)&#123;      res[k] = l.get(k);    &#125;    return res;  &#125;  // there is a non-sort version, using a  public int[] intesectII(int[] nums1, int[] nums2)&#123;    LinkedList&lt;Integer&gt; dic = new LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();    for (int i=0; i&lt;nums1.length; i++)&#123;      dic.add(nums1[i]);    &#125;    for (int i=0; i&lt;nums2.length; i++)&#123;      boolean success = dic.remove(new Integer(nums2[i]));      if (!success)&#123;        res.add(nums2[i]);      &#125;    &#125;    int[] r = new int[res.size()];    for (int i=0; i&lt;res.size(); i++)&#123;      r[i] = res.get(i);    &#125;    return r;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  IntersectionofTwoLinkedLists","url":"/article/leetcode-IntersectionofTwoLinkedLists/","content":"import utils.ListNode;public class IntersectionofTwoLinkedLists &#123;  public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    ListNode a = headA;    ListNode b = headB;    while (a.next != null &amp;&amp; b.next != null) &#123;      a = a.next;      b = b.next;      if (a == b) return a;      if (a.next == null) a = headB;      if (b.next == null) b = headA;    &#125;    return null;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  IsSubsequence","url":"/article/leetcode-IsSubsequence/","content":"import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.List;public class IsSubsequence &#123;  /**   * Given a string s and a string t, check if s is subsequence of t.   *   * You may assume that there is only lower case English letters in both s and t.   * t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100).   *   * A subsequence of a string is a new string which is formed from the original string   * by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.   * (ie, &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not).   *   * Example 1:   * s = &quot;abc&quot;, t = &quot;ahbgdc&quot;   *   * Return true.   *   * Example 2:   * s = &quot;axc&quot;, t = &quot;ahbgdc&quot;   *   * Return false.   *   * Follow up:   * If there are lots of incoming S, say S1, S2, ... , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence.   * In this scenario, how would you change your code?   */  // first edition  public boolean isSubsequence(String s, String t) &#123;    int i=0;    int j=0;    while(i&lt;s.length() &amp;&amp; j&lt;t.length())&#123;      if (s.charAt(i) == t.charAt(j))&#123;        i++;        j++;      &#125;      else&#123;        j++;      &#125;    &#125;    if (i==s.length())      return true;    else      return false;  &#125;  // second edition  public boolean isSubsequence2(String s, String t) &#123;    int index = -1;    for (char c : s.toCharArray()) &#123;      index = t.indexOf(c, index + 1);      if (index == -1) return false;    &#125;    return true;  &#125;  // consider the follow ups. when there is a large number of s, it&#x27;s expensive to loop t over and over again,  // therefore, a pre-calculate should be performed to find every letter in t and then, using their&#x27;s positions to determine  // if s is a substring.  public boolean isSubsequence3(String s, String t)&#123;    List&lt;Integer&gt;[] l = new List[28];    for (int i=0; i&lt;t.length(); i++)&#123;      if (l[t.charAt(i)-&#x27;a&#x27;] == null)        l[t.charAt(i)-&#x27;a&#x27;] = new ArrayList&lt;&gt;();      l[t.charAt(i)-&#x27;a&#x27;].add(i);    &#125;    int min = -1;      for (int i = 0; i &lt; s.length(); i++) &#123;        if (l[s.charAt(i)] == null) return false; // Note: char of S does NOT exist in T causing NPE        int j = Collections.binarySearch(l[s.charAt(i)], min);        if (j &lt; 0) j = -j - 1;        if (j == l[s.charAt(i)].size()) return false;        min = l[s.charAt(i)].get(j) + 1;      &#125;      return true;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  KthLargestElementinanArray","url":"/article/leetcode-KthLargestElementinanArray/","content":"import java.util.Arrays;import java.util.PriorityQueue;public class KthLargestElementinanArray &#123;    /**     * Find the kth largest element in an unsorted array.     * Note that it is the kth largest element in the sorted order,     * not the kth distinct element.     *     * Example 1:     *     * Input: [3,2,1,5,6,4] and k = 2     * Output: 5     * Example 2:     *     * Input: [3,2,3,1,2,4,5,5,6] and k = 4     * Output: 4     * Note:     * You may assume k is always valid, 1 ≤ k ≤ array&#x27;s length.     */    public int findKthLargest(int[] nums, int k) &#123;        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();        for (int i=0; i&lt;nums.length; i++) &#123;            if (pq.size() &lt; k) &#123;                pq.offer(nums[i]);            &#125;            else &#123;                if (nums[i] &gt; pq.peek()) &#123;                    pq.poll();                    pq.offer(nums[i]);                &#125;            &#125;        &#125;        return pq.poll();    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode LargestDivisibleSubset","url":"/article/leetcode-KthSmallestElementinaSortedMatrix/","content":"public class LargestDivisibleSubset &#123;  /**   * Given a n x n matrix where each of the rows and columns are sorted in ascending order,   * find the kth smallest element in the matrix.   *   * Note that it is the kth smallest element in the sorted order, not the kth distinct element.   *   * Example:   *   * matrix = [   *    [ 1,  5,  9],   *    [10, 11, 13],   *    [12, 13, 15]   * ],   * k = 8,   *   * return 13.   * Note:   * You may assume k is always valid, 1 ≤ k ≤ n2.   */  public int kthSmallest(int[][] matrix, int k) &#123;    int n = matrix.length;    int left = matrix[0][0];    int right  = matrix[n-1][n-1];    while(left &lt; right)&#123;      int mid = left + (right - left) &gt;&gt; 1;      int count = getCount(matrix, mid);      if (count &lt; k)&#123;        right = mid + 1;      &#125;      else&#123;        left = mid;      &#125;    &#125;    return left;  &#125;  public int getCount(int[][] matrix, int mid)&#123;    int i = matrix.length;    int j = 0;    int count = 0;    while(j&lt;matrix.length &amp;&amp; i &gt; 0)&#123;      if (matrix[i][j] &gt; mid)&#123;        i --;      &#125;      else &#123;        count += i +1;        j ++;      &#125;    &#125;    return count;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  KthSmallestElementinaBST","url":"/article/leetcode-KthSmallestElementinaBST/","content":"import utils.TreeNode;import java.util.ArrayList;public class KthSmallestElementinaBST &#123;    public int kthSmallest(TreeNode root, int k) &#123;        ArrayList&lt;Integer&gt; l  = new ArrayList&lt;&gt;();        helper(l, root);        return l.get(k-1);    &#125;    public void helper(ArrayList&lt;Integer&gt; l, TreeNode root) &#123;        if (root == null)            return ;        helper(l, root.left);        l.add(root.val);        helper(l, root.right);    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LargestDivisibleSubset","url":"/article/leetcode-LargestDivisibleSubset/","content":"import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class LargestDivisibleSubset &#123;  /**   * Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies:   *   * Si % Sj = 0 or Sj % Si = 0.   *   * If there are multiple solutions, return any subset is fine.   *   * Example 1:   *   * Input: [1,2,3]   * Output: [1,2] (of course, [1,3] will also be ok)   * Example 2:   *   * Input: [1,2,4,8]   * Output: [1,2,4,8]   */  public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) &#123;    int n = nums.length;    int dp[] = new int[n];    int ptr[] = new int[n];    for (int i=0; i&lt;ptr.length; i++)&#123;      ptr[i] = -1;    &#125;    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    int idx=0;    Arrays.sort(nums);    for (int i=1; i&lt;nums.length; i++)&#123;      for (int j=0; j&lt;i; j++)&#123;        if (nums[i] % nums[j]==0)&#123;          dp[i] = dp[j] + 1;          ptr[i] = j;          if (dp[i] &gt; dp[idx])&#123;            idx = i;          &#125;        &#125;      &#125;    &#125;    while(idx != -1)&#123;      res.add(nums[idx]);      idx = ptr[idx];    &#125;    return res;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  KthlargestNumber","url":"/article/leetcode-KthlargestNumber/","content":"public class KthlargestNumber &#123;  /**   * Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.   *   * Example 1:   *   * Input: [3,2,1,5,6,4] and k = 2   * Output: 5   * Example 2:   *   * Input: [3,2,3,1,2,4,5,5,6] and k = 4   * Output: 4   * Note:   * You may assume k is always valid, 1 ≤ k ≤ array&#x27;s length.   */  public static int findKthLargest(int[] nums, int k) &#123;    int left = 0;    int right = nums.length-1;    while(true)&#123;      if (left == right)&#123;        return nums[right];      &#125;      int pivotIndex = left + (right - left)/2;      pivotIndex = partition(nums, left, right, pivotIndex);      if (pivotIndex == k )&#123;        return nums[pivotIndex];      &#125;      else if (pivotIndex &gt; k)&#123;        right = pivotIndex - 1;      &#125;      else        left = pivotIndex + 1;    &#125;  &#125;  public static int partition(int[] nums, int left, int right, int pivotIndex)&#123;    int index = left;    int pivotValue = nums[pivotIndex];    swap(nums, right, pivotIndex);    for (int i=left; i&lt; right; i++)&#123;      if (nums[i] &gt; pivotValue)&#123;        swap(nums, i, index);      &#125;      index ++;    &#125;    swap(nums, index, right);    return index;  &#125;  // swap two values.  public static void swap(int[] nums, int left, int right)&#123;    int temp = nums[left];    nums[left] = nums[right];    nums[right] = temp;  &#125;  public static void main(String[] args)&#123;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LargestNumber","url":"/article/leetcode-LargestNumber/","content":"import java.util.Comparator;import static java.util.Arrays.sort;public class LargestNumber &#123;  /*  Given a list of non negative integers, arrange them such that they form the largest number.  Example 1:  Input: [10,2]  Output: &quot;210&quot;  Example 2:  Input: [3,30,34,5,9]  Output: &quot;9534330&quot;  Note: The result may be very large, so you need to return a string instead of an integer.*/  public static String largestNumber(int[] nums) &#123;    int n = nums.length;    String[] s = new String[n];    for (int i=0; i&lt;n; i++)&#123;      s[i] = String.valueOf(nums[i]);    &#125;    Comparator&lt;String&gt; c = new Comparator&lt;String&gt;() &#123;      @Override      public int compare(String o1, String o2) &#123;        return (o2+o1).compareTo(o1+o2);      &#125;    &#125;;    sort(s, c);    String result = String.join(&quot;&quot;, s);    return result;  &#125;  public static void main(String[] args)&#123;    int[] test = new int[]&#123;3,30,34,5,9&#125;;    System.out.println(largestNumber(test));  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LetterCombinationsofaPhoneNumber","url":"/article/leetcode-LetterCombinationsofaPhoneNumber/","content":"import java.util.Arrays;import java.util.HashMap;import java.util.LinkedList;import java.util.List;public class LetterCombinationsofaPhoneNumber &#123;    public List&lt;String&gt; letterCombinations(String digits) &#123;        HashMap&lt;Character, char[]&gt; m = new HashMap&lt;&gt;();        m.put(&#x27;2&#x27;, new char[] &#123;&#x27;a&#x27;, &#x27;b&#x27;,&#x27;c&#x27;&#125;);        m.put(&#x27;3&#x27;, new char[] &#123;&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;);        m.put(&#x27;4&#x27;, new char[] &#123;&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;&#125;);        m.put(&#x27;5&#x27;, new char[] &#123;&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;&#125;);        m.put(&#x27;6&#x27;, new char[] &#123;&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;&#125;);        m.put(&#x27;7&#x27;, new char[] &#123;&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;&#125;);        m.put(&#x27;8&#x27;, new char[] &#123;&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;&#125;);        m.put(&#x27;9&#x27;, new char[] &#123;&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;&#125;);        List&lt;String&gt; ans = new LinkedList&lt;&gt;();        dfs(ans, digits, &quot;&quot;, m);        return ans;    &#125;    public void dfs(List&lt;String&gt; ans, String digits, String t, HashMap&lt;Character, char[]&gt; m) &#123;        if (digits.isEmpty()) &#123;            ans.add(t);        &#125;        for (char i: m.get(digits.charAt(0))) &#123;            dfs(ans, digits.substring(1), t+i, m);        &#125;    &#125;    public static void main(String[] args) &#123;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LexicographicalNumbers","url":"/article/leetcode-LexicographicalNumbers/","content":"import java.util.LinkedList;import java.util.List;public class LexicographicalNumbers &#123;  /**   * Given an integer n, return 1 - n in lexicographical order.   *   * For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].   *   * Please optimize your algorithm to use less time and space.   * The input size may be as large as 5,000,000.   *   * @param n   * @return   */  public static List&lt;Integer&gt; lexicalOrder(int n) &#123;    List&lt;Integer&gt; res = new LinkedList&lt;Integer&gt;();    for (int i=1; i&lt;10; i++)&#123;      dfs(res, n, i);    &#125;    return res;  &#125;  public static void dfs(List&lt;Integer&gt; res, int n, int cur)&#123;    if (cur &gt; n) return ;    res.add(cur);    for (int i=cur*10; i&lt;cur*10+10; i++)&#123;      dfs(res, n, i);    &#125;    return ;  &#125;  public static void  main(String[] args)&#123;    for (int c: lexicalOrder(19))&#123;      System.out.println(c);    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LinkedListCycle","url":"/article/leetcode-LinkedListCycle/","content":"import utils.ListNode;public class LinkedListCycle &#123;    /*        Given a linked list, return the node where the cycle begins. If there is no cycle, return null.        Note: Do not modify the linked list.     */    public ListNode detectCycle(ListNode head) &#123;        if (head == null)            return null;        ListNode slow = head;        ListNode fast = head;        while(true) &#123;            if (fast != null &amp;&amp; fast.next!= null )&#123;                fast = fast.next.next;                slow = slow.next;            &#125;            else &#123;                return null;            &#125;            if (fast == slow)&#123;                while(head != slow)&#123;                    head = head.next;                    slow = slow.next;                &#125;                return slow;            &#125;        &#125;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LinkedListCycleII","url":"/article/leetcode-LinkedListCycleII/","content":"import utils.ListNode;public class LinkedListCycleII &#123;  /**   * Given a linked list, return the node where the cycle begins.   * If there is no cycle, return null.   *   * To represent a cycle in the given linked list,   * we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to.   * If pos is -1, then there is no cycle in the linked list.   *   * Note: Do not modify the linked list.   */  public ListNode detectCycle(ListNode head) &#123;    if (head == null || head.next == null) return null;    ListNode slow = head;    ListNode fast = head;    while(fast!= null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;      if (slow == fast) &#123;        fast = head;        while(slow != fast) &#123;          slow = slow.next;          fast = fast.next;        &#125;        return slow;      &#125;    &#125;    return null;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LinkedListRandomNode","url":"/article/leetcode-LinkedListRandomNode/","content":"import utils.ListNode;public class LinkedListRandomNode &#123;  /**   * Given a singly linked list, return a random node&#x27;s value from the linked list.   * Each node must have the same probability of being chosen.   *   * Follow up:   * What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?   *   * Example:   *   * // Init a singly linked list [1,2,3].   * ListNode head = new ListNode(1);   * head.next = new ListNode(2);   * head.next.next = new ListNode(3);   * Solution solution = new Solution(head);   *   * // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.   * solution.getRandom();   */  /** @param head The linked list&#x27;s head.  Note that the head is guaranteed to be not null, so it contains at least one node. */  public LinkedListRandomNode(ListNode head) &#123;  &#125;  /** Returns a random node&#x27;s value. */  public int getRandom() &#123;    return 0;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LongestAbsoluteFilePath","url":"/article/leetcode-LongestAbsoluteFilePath/","content":"import java.util.List;import java.util.Stack;public class LongestAbsoluteFilePath &#123;  /**   * Suppose we abstract our file system by a string in the following manner:   *   * The string &quot;dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext&quot; represents:   *   * dir   *     subdir1   *     subdir2   *         file.ext   * The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.   *   * The string &quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot; represents:   *   * dir   *     subdir1   *         file1.ext   *         subsubdir1   *     subdir2   *         subsubdir2   *             file2.ext   * The directory dir contains two sub-directories subdir1 and subdir2.   * subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1.   * subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.   *   * We are interested in finding the longest (number of characters) absolute path to a file within our file system.   * For example, in the second example above, the longest absolute path is &quot;dir/subdir2/subsubdir2/file2.ext&quot;,   * and its length is 32 (not including the double quotes).   *   * Given a string representing the file system in the above format,   * return the length of the longest absolute path to file in the abstracted file system.   * If there is no file in the system, return 0.   *   * Note:   * The name of a file contains at least a . and an extension.   * The name of a directory or sub-directory will not contain a ..   * Time complexity required: O(n) where n is the size of the input string.   *   * Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.   */  public static int lengthLongestPath(String input) &#123;    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    String[] l = input.split(&quot;\\\\n&quot;);    stack.push(0);    int maxLength = 0;    int temp = 0;    for (String s: l)&#123;      int inx = s.lastIndexOf(&quot;\\\\t&quot;)+1;      while (inx+1 &lt; stack.size())&#123;        stack.pop();      &#125;      temp = stack.peek() + s.length() - inx + 1; // 后面的+1是针对dir时，后面需要再添加上一个&#x27;/&#x27;      stack.push(temp);      if (s.contains(&quot;.&quot;))        maxLength = Math.max(maxLength, temp-1); // 对于文件，把之前添加上的&#x27;/&#x27;去掉，所以要-1    &#125;    return maxLength;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LongestIncreasingSubsequence","url":"/article/leetcode-LongestIncreasingSubsequence/","content":"import java.util.Arrays;import java.util.HashMap;public class LongestIncreasingSubsequence &#123;  /**   * Given an unsorted array of integers, find the length of longest increasing subsequence.   *   * Example:   *   * Input: [10,9,2,5,3,7,101,18]   * Output: 4   * Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   * Note:   *   * There may be more than one LIS combination, it is only necessary for you to return the length.   * Your algorithm should run in O(n2) complexity.   * Follow up: Could you improve it to O(n log n) time complexity?   *   * @param nums   * @return   */  public int lengthOfLIS(int[] nums) &#123;    HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;();    int n = nums.length;    int[] dp = new int[n];    Arrays.fill(dp, Integer.MAX_VALUE);    int t = 0;    for (int i = 0; i &lt; n; i++) &#123;      int idx = binarySearch(dp, 0, i, nums[i]);      dp[idx] = nums[i];      if (idx == t) &#123;        t++;      &#125;    &#125;    return t;  &#125;  public int binarySearch(int[] nums, int left, int right, int target)&#123;    while(left &lt;= right)&#123;      int mid = left + ((right - left) &gt;&gt; 1);      if (nums[mid] == target) return mid;      else if (nums[mid] &gt; target) left = mid -1;      else right = mid + 1;    &#125;    return left;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LongestSubstringAtLeastKRepeating","url":"/article/leetcode-LongestSubstringAtLeastKRepeating/","content":"public class LongestSubstringAtLeastKRepeating &#123;  public int longestSubstring(String s, int k) &#123;    /**     * Find the length of the longest substring T of a given string (consists of lowercase letters only)     * such that every character in T appears no less than k times.     *     * Example 1:     *     * Input:     * s = &quot;aaabb&quot;, k = 3     *     * Output:     * 3     *     * The longest substring is &quot;aaa&quot;, as &#x27;a&#x27; is repeated 3 times.     * Example 2:     *     * Input:     * s = &quot;ababbc&quot;, k = 2     *     * Output:     * 5     *     * The longest substring is &quot;ababb&quot;, as &#x27;a&#x27; is repeated 2 times and &#x27;b&#x27; is repeated 3 times.     */    char[] as = s.toCharArray();    return help(as, k, 0, s.length());  &#125;  public int help(char[] a, int k, int start, int end)&#123;    if (end - start &lt; k) return 0;    int[] count = new int[26];    for (int i=start; i&lt;end; i++)&#123;      count[a[i]-&#x27;a&#x27;] += 1;    &#125;    for (int i=0; i&lt;count.length; i++)&#123;      if (count[i]&gt;0 &amp;&amp; count[i]&lt;k)&#123;        for (int j=start; j&lt;end; j++)&#123;          if (a[j] == i+&#x27;a&#x27;)&#123;            int left = help(a, k, start, j);            int right = help(a, k, j+1, end);            return Math.max(left, right);          &#125;        &#125;      &#125;    &#125;    return end-start;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode LongestPalindromicSubstring","url":"/article/leetcode-LongestPalindromicSubstring/","content":"public class LongestPalindromicSubstring &#123;  public String longestPalindrome(String s) &#123;    String ans = &quot;&quot;;    boolean[][] dp = new boolean[s.length()][s.length()];    for (int j=0; j&lt;s.length(); j++) &#123;      for (int i=0; i&lt;=j; i++) &#123;        if (((j&gt;i+1 &amp;&amp; dp[i+1][j-1]) || j &lt;= i+1 ) &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;          dp[i][j] = true;          if (j-i+1 &gt; ans.length()) &#123;            ans = s.substring(i, j+1);          &#125;        &#125;      &#125;    &#125;    return ans;  &#125;  public boolean isPalindrome(String s, int i, int j) &#123;    int left = i;    int right = j;    while (left &lt; right) &#123;      if (s.charAt(left) != s.charAt(right) )&#123;        return false;      &#125;      left ++;      right --;    &#125;    return true;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  LongestSubstringWithoutRepeatingCharacters","url":"/article/leetcode-LongestSubstringWithoutRepeatingCharacters/","content":"import java.util.HashMap;public class LongestSubstringWithoutRepeatingCharacters &#123;  public int lengthOfLongestSubstring(String s) &#123;    int ans = 0;    int start = 0;    HashMap&lt;Character, Integer&gt; m = new HashMap&lt;&gt;();    for (int i=0; i&lt;s.length(); i++) &#123;      if (m.containsKey(s.charAt(i))) &#123;        start = Math.max(start, m.get(s.charAt(i))+1);      &#125;      m.put(s.charAt(i), i);      ans = Math.max(ans, i-start+1);    &#125;    return ans;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  MaxPointsonaLine","url":"/article/leetcode-MaxPointsonaLine/","content":"import utils.Point;public class MaxPointsonaLine &#123;    public int maxPoints(Point[] points) &#123;        return 0;    &#125;    public static void main(String[] args) &#123;        System.out.println((double) 94911150/ (double)94911151 + &quot; &quot; + (double)94911151/94911152);    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  MaximumGap","url":"/article/leetcode-MaximumGap/","content":"public class MaximumGap &#123;  /**   * Given an unsorted array, find the maximum difference between the successive elements in its sorted form.   *   * Return 0 if the array contains less than 2 elements.   *   * Example 1:   *   * Input: [3,6,9,1]   * Output: 3   * Explanation: The sorted form of the array is [1,3,6,9], either   *              (3,6) or (6,9) has the maximum difference 3.   * Example 2:   *   * Input: [10]   * Output: 0   * Explanation: The array contains less than 2 elements, therefore return 0.   * Note:   *   * You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.   * Try to solve it in linear time/space.   */  public static int solution(int[] nums)&#123;    if (nums.length &lt;2)&#123;      return 0;    &#125;    int base = 10;    int r = 1;    int maxNumber = nums[0];    // find the max number.    for (int i=1; i&lt;nums.length; i++)&#123;      maxNumber = Math.max(maxNumber, nums[i]);    &#125;    int[] sorted = new int[nums.length];    while(maxNumber/r &gt; 0)&#123;      int[] count = new int[base];      for (int i=0; i&lt;nums.length; i++)&#123;        count[(nums[i]/r) % 10] += 1;      &#125;      for (int i=1; i&lt;count.length; i++)&#123;        count[i] += count[i-1];      &#125;      for (int i=nums.length-1; i&gt;=0; i--)&#123;        sorted[--count[(nums[i]/r) % 10]] = nums[i];      &#125;      for (int i=0; i&lt;nums.length; i++)&#123;        nums[i] = sorted[i];      &#125;      r *= 10;    &#125;    maxNumber = 0;    // find the max number.    for (int i=1; i&lt;nums.length; i++)&#123;      maxNumber = Math.max(maxNumber, nums[i]-nums[i-1]);    &#125;    return maxNumber;  &#125;  public static void main(String args[])&#123;    int[] test = new int[]&#123;4,3,9,0&#125;;    System.out.println(solution(test));  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  MaximumProductofWordLengths","url":"/article/leetcode-MaximumProductofWordLengths/","content":"import java.util.HashMap;public class MaximumProductofWordLengths &#123;  /**   * Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters.   * You may assume that each word will contain only lower case letters.   * If no such two words exist, return 0.   *   * Example 1:   *   * Input: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]   * Output: 16   * Explanation: The two words can be &quot;abcw&quot;, &quot;xtfn&quot;.   * Example 2:   *   * Input: [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]   * Output: 4   * Explanation: The two words can be &quot;ab&quot;, &quot;cd&quot;.   * Example 3:   *   * Input: [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]   * Output: 0   * Explanation: No such pair of words.   */  public int maxProduct(String[] words) &#123;    int[] masks = getMask(words);    int max = 0;    for (int i=1; i&lt;words.length; i++)&#123;      for (int j=0; j&lt;i; j++)&#123;        if ((masks[i] &amp; masks[j]) == 0)&#123;          max = Math.max(max, words[i].length()+words[j].length());        &#125;      &#125;    &#125;    return max;  &#125;  public HashMap&lt;Character, Integer&gt; getBinaryMapping()&#123;    HashMap&lt;Character, Integer&gt; mapping = new HashMap&lt;&gt;();    for (int i=0; i&lt;26; i++)&#123;      mapping.put((char) (&#x27;a&#x27;+i), (1 &lt;&lt; i));    &#125;    return mapping;  &#125;  public int[] getMask(String[] words)&#123;    int[] masks = new int[words.length];    HashMap&lt;Character, Integer&gt; mapping = getBinaryMapping();    for (int i=0; i&lt;words.length; i++)&#123;      int mask = 0;      for (char c: words[i].toCharArray())&#123;        mask |= mapping.get(c);      &#125;      masks[i] = mask;    &#125;    return masks;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  MergeIntervals","url":"/article/leetcode-MergeIntervals/","content":"import utils.Interval;import java.util.*;public class MergeIntervals &#123;    /**     * Given a collection of intervals, merge all overlapping intervals.     *     * Example 1:     *     * Input: [[1,3],[2,6],[8,10],[15,18]]     * Output: [[1,6],[8,10],[15,18]]     * Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].     * Example 2:     *     * Input: [[1,4],[4,5]]     * Output: [[1,5]]     * Explanation: Intervals [1,4] and [4,5] are considered overlapping.     */    public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123;        List&lt;Interval&gt; ans = new ArrayList&lt;&gt;();        Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123;            @Override            public int compare(Interval o1, Interval o2) &#123;                return o1.start &gt;= o2.start ? -1: 1;            &#125;        &#125;);        boolean startIsNull = true;        int start = 0;        int end = 0;        for (int i=0; i&lt;intervals.size(); i++) &#123;            if (startIsNull) &#123;                start = intervals.get(i).start;                end = intervals.get(i).end;                startIsNull = false;            &#125;            if (intervals.get(i).start &lt;= end) &#123;                end = Math.max(end, intervals.get(i).end);            &#125;            else &#123;                ans.add(new Interval(start, end));                startIsNull = true;            &#125;        &#125;        if (startIsNull) &#123;            ans.add(new Interval(start, end));        &#125;        return ans;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode MiniParser","url":"/article/leetcode-MiniParser/","content":"import utils.NestedInteger;import java.util.Stack;public class MiniParser &#123;  /*  Given a nested list of integers represented as a string, implement a parser to deserialize it.  Each element is either an integer, or a list -- whose elements may also be integers or other lists.  Note: You may assume that the string is well-formed:  String is non-empty.  String does not contain white spaces.  String contains only digits 0-9, [, - ,, ].  Example 1:  Given s = &quot;324&quot;,  You should return a NestedInteger object which contains a single integer 324.  Example 2:  Given s = &quot;[123,[456,[789]]]&quot;,  Return a NestedInteger object containing a nested list with 2 elements:  1. An integer containing value 123.  2. A nested list containing two elements:      i.  An integer containing value 456.      ii. A nested list with one element:           a. An integer containing value 789.     * // This is the interface that allows for creating nested lists.     * // You should not implement it, or speculate about its implementation     *     * public interface NestedInteger &#123;     *     // Constructor initializes an empty nested list.     *     public NestedInteger();     *     *     // Constructor initializes a single integer.     *     public NestedInteger(int value);     *     *     // @return true if this NestedInteger holds a single integer, rather than a nested list.     *     public boolean isInteger();     *     *     // @return the single integer that this NestedInteger holds, if it holds a single integer     *     // Return null if this NestedInteger holds a nested list     *     public Integer getInteger();     *     *     // Set this NestedInteger to hold a single integer.     *     public void setInteger(int value);     *     *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.     *     public void add(NestedInteger ni);     *     *     // @return the nested list that this NestedInteger holds, if it holds a nested list     *     // Return null if this NestedInteger holds a single integer     *     public List&lt;NestedInteger&gt; getList();     *     *     public NestedInteger deserialize(String s) &#123;        if (s.charAt(0) != &#x27;[&#x27;) return new NestedInteger(Integer.parseInt(s));        Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;();        NestedInteger result = null;        for (int i = 0; i &lt; s.length(); i++) &#123;            char ch = s.charAt(i);            if (ch == &#x27;[&#x27;) &#123;            // Create a list, add it to outer list and push it to the top of stack anyway                NestedInteger curr = new NestedInteger();                if (!stack.empty()) &#123;                    stack.peek().add(curr);                &#125;                stack.push(curr);            &#125;            else if (ch == &#x27;]&#x27;)&#123;            // pop the inner list                if (!stack.empty()) result = stack.pop();            &#125;            else if (Character.isDigit(ch) || ch == &#x27;-&#x27;) &#123;            // Fetch the number and add to the list on the top.                String num = &quot;&quot; + ch;                while (i &lt; s.length() - 1 &amp;&amp; Character.isDigit(s.charAt(i + 1))) &#123;                    num = num + s.charAt(++i);                &#125;                stack.peek().add(new NestedInteger(Integer.parseInt(num)));            &#125;        &#125;        return result;    &#125;       */  public NestedInteger deserialize(String s) &#123;    if(s==null &amp;&amp; s.length() == 0)      return new NestedInteger();    if (!s.startsWith(&quot;[&quot;))&#123;      return new NestedInteger(Integer.valueOf(s));    &#125;    Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;();    NestedInteger res = null;    for (int i=0; i&lt;s.length(); i++)&#123;      char c = s.charAt(i);      if (c == &#x27;[&#x27;)&#123;        NestedInteger n = new NestedInteger();        if (!stack.isEmpty())&#123;          stack.peek().add(n);        &#125;        stack.push(n);      &#125;      else if (c == &#x27;]&#x27;)&#123;        res = stack.pop();      &#125;      else&#123;        if (Character.isDigit(c) || c == &#x27;-&#x27;)&#123;          int num = 0;          int sign = 1;          if (c == &#x27;-&#x27;)            sign = -1;          else            num = c - &#x27;0&#x27;;          while(i+1 &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i+1)) )&#123;            num = num * 10 + s.charAt(i+1) - &#x27;0&#x27;;            i++;          &#125;          stack.peek().add(new NestedInteger(num*sign));        &#125;      &#125;    &#125;    return res;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  MinimumHeightTrees","url":"/article/leetcode-MinimumHeightTrees/","content":"import java.util.*;public class MinimumHeightTrees &#123;  /**   * For an undirected graph with tree characteristics,   * we can choose any node as the root. The result graph is then a rooted tree.   * Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs).   * Given such a graph, write a function to find all the MHTs and return a list of their root labels.   *   * Format   * The graph contains n nodes which are labeled from 0 to n - 1.   * You will be given the number n and a list of undirected edges (each edge is a pair of labels).   *   * You can assume that no duplicate edges will appear in edges.   * Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.   *   * Example 1 :   *   * Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]   *   *         0   *         |   *         1   *        / \\   *       2   3   *   * Output: [1]   * Example 2 :   *   * Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]   *   *      0  1  2   *       \\ | /   *         3   *         |   *         4   *         |   *         5   *   * Output: [3, 4]   * Note:   *   * According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”   * The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.   */  public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123;    if (n == 1) &#123;      return Arrays.asList(0);    &#125;    // get adjust neighbor    HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; adj = new HashMap&lt;&gt;(); // adj    int[] indegree = new int[n];    for (int i=0; i&lt;n; i++)      adj.put(i, new LinkedList&lt;&gt;());    for (int[] e: edges)&#123;      adj.get(e[0]).add(e[1]);      adj.get(e[1]).add(e[0]);      indegree[e[1]] ++;      indegree[e[0]] ++;    &#125;    // get leave nodes    ArrayList&lt;Integer&gt; leaves = new ArrayList&lt;&gt;();    for (int i=0; i&lt;n; i++)&#123;      if (indegree[i] == 1)&#123;        leaves.add(i);      &#125;    &#125;    while(n&gt;2)&#123;      ArrayList&lt;Integer&gt; nextLeave = new ArrayList&lt;&gt;();      for (int leave: leaves)&#123;        for (int node: adj.get(leave))&#123;          if (--indegree[node] == 0)            nextLeave.add(node);        &#125;      &#125;      n -= leaves.size();      leaves = nextLeave;    &#125;    return leaves;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode NimGame","url":"/article/leetcode-NimGame/","content":"public class NimGame &#123;  /**   * You are playing the following Nim Game with your friend:   * There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones.   * The one who removes the last stone will be the winner. You will take the first turn to remove the stones.   *   * Both of you are very clever and have optimal strategies for the game.   * Write a function to determine whether you can win the game given the number of stones in the heap.   *   * Example:   *   * Input: 4   * Output: false   * Explanation: If there are 4 stones in the heap, then you will never win the game;   *              No matter 1, 2, or 3 stones you remove, the last stone will always be   *              removed by your friend.   */  public boolean canWinNim(int n) &#123;    return !(n%4 == 0);  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  findNthDigit","url":"/article/leetcode-NthDigit/","content":"public class NthDigit &#123;  public int findNthDigit(int n) &#123;    /**     * Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...     * Note:     * n is positive and will fit within the range of a 32-bit signed integer (n &lt; 231).     * Example 1:     * Input:     * 3     * Output:     * 3     * Example 2:     *     * Input:     * 11     *     * Output:     * 0     *     * Explanation:     * The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.     *     * \t\t\twidth count     * \t\t  1-9:  1     9     * \t    10-99:  2    90     *      100-999:  3   900     *     *      w, c = 1, 9 // width and count of numbers (of each level)     *      while n &gt; w*c:     *         n -= w*c     *         w += 1     *         c *= 10     *      num, d = (c/9) + (n-1)/w, (n-1)%w       // c/9 is equals to 10**w, means the base number     *      return int(str(num)[d])     */    if (n &lt; 10) &#123;      return n;    &#125; else if (n &lt; 100) &#123;      if (n % 2 == 0) &#123;        return n;      &#125;    &#125;    return n;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  NumMatrix","url":"/article/leetcode-NumMatrix/","content":"import java.util.ArrayList;public class NumMatrix &#123;  /*      Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).      Range Sum Query 2D      The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.      Example:      Given matrix = [        [3, 0, 1, 4, 2],        [5, 6, 3, 2, 1],        [1, 2, 0, 1, 5],        [4, 1, 0, 1, 7],        [1, 0, 3, 0, 5]      ]      sumRegion(2, 1, 4, 3) -&gt; 8      sumRegion(1, 1, 2, 2) -&gt; 11      sumRegion(1, 2, 2, 4) -&gt; 12   */  int[][] matrix;  public NumMatrix(int[][] matrix) &#123;    int n = matrix.length;    int m = matrix[0].length;    if (matrix == null || matrix.length == 0)&#123;      return ;    &#125;    this.matrix = new int[n][m];    for(int i=0; i&lt;n; i++)&#123;      for (int j=0; j&lt;m; j++)&#123;        if (i==0 &amp;&amp; j==0)&#123;          this.matrix[i][j] = matrix[i][j];        &#125;        else if (i == 0)&#123;          this.matrix[i][j] = matrix[i][j] + this.matrix[i][j-1];        &#125;        else if (j == 0)&#123;          this.matrix[i][j] = matrix[i][j] + this.matrix[i-1][j];        &#125;        else&#123;          this.matrix[i][j] = matrix[i][j] + this.matrix[i-1][j] + this.matrix[i][j-1] - this.matrix[i-1][j-1];        &#125;      &#125;    &#125;  &#125;  public int sumRegion(int row1, int col1, int row2, int col2) &#123;    if (col1 == 0 &amp;&amp; row1 == 0)&#123;      return matrix[row2][col2];    &#125;    else if (col1 == 0)&#123;      return matrix[row2][col2] - matrix[row1-1][col2];    &#125;    else if (row1 == 0)&#123;      return matrix[row2][col2] - matrix[row2][col1-1];    &#125;    else      return matrix[row2][col2] - matrix[row2][col1-1] - matrix[row1-1][col2] + matrix[row1-1][col1-1];  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  NumArray","url":"/article/leetcode-NumArray/","content":"import java.util.ArrayList;/*303. Range Sum Query - ImmutableGiven an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.Example:Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3Note:You may assume that the array does not change.There are many calls to sumRange function. */public class NumArray &#123;  ArrayList&lt;Integer&gt; sums = new ArrayList&lt;&gt;();  public NumArray(int[] nums)&#123;    sums.add(0);    int sum = 0;    for(int i: nums)&#123;      sum += i;      sums.add(sum);    &#125;  &#125;  public  int sumRange(int i, int j) &#123;    return sums.get(j)-sums.get(i);  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  NumberOfDigitOne","url":"/article/leetcode-NumberOfDigitOne/","content":"public class NumberOfDigitOne &#123;  /**   * Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.   *   * Example:   *   * Input: 13   * Output: 6   * Explanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.   *   */  public static int countDigitOne(int n) &#123;    int count = 0;    for (int i = 0; i&lt;=n; i=i*10)&#123;      int p = n/i;      int q = n%i;      count += p*10 ;    &#125;    return count;  &#125;  public static void main(String[] argg)&#123;    System.out.println(countDigitOne(91));  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  NumberofIslands","url":"/article/leetcode-NumberofIslands/","content":"public class NumberofIslands &#123;    public int numIslands(char[][] grid) &#123;        if (grid.length == 0) return 0;        int m = grid.length-1;        if (grid[0].length == 0) return 0;        int n = grid[0].length-1;        int count = 0;        for(int i=0; i&lt;=m; i++) &#123;            for (int j=0; j&lt;=n; j++) &#123;                if (grid[i][j] == &#x27;1&#x27;) &#123;                    removeIsland(grid, i, j);                    count ++;                &#125;            &#125;        &#125;        return count;    &#125;    public void removeIsland(char[][] grid, int i, int j) &#123;        if (i&lt;0 || j&lt;0 || i&gt;grid.length-1 || j&gt;grid[0].length-1) return ;        if (grid[i][j] == &#x27;0&#x27;) return;        grid[i][j] = &#x27;0&#x27;;        removeIsland(grid, i-1,j);        removeIsland(grid, i+1, j);        removeIsland(grid, i, j-1);        removeIsland(grid, i, j+1);    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  OddEvenLinkedList","url":"/article/leetcode-OddEvenLinkedList/","content":"import utils.ListNode;public class OddEvenLinkedList &#123;  /**   * Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.   *   * You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.   *   * Example 1:   *   * Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL   * Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL   * Example 2:   *   * Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL   * Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL   * Note:   *   * The relative order inside both the even and odd groups should remain as it was in the input.   * The first node is considered odd, the second node even and so on ...   */  public ListNode oddEvenList(ListNode head) &#123;    if (head == null || head.next == null) return head;    ListNode dump = new ListNode(0);    dump.next = head;    ListNode odd = head;    ListNode even = head.next;    ListNode p = even.next;    while(p!=null)&#123;      //insert(odd.next, p);      even.next = p.next;      ListNode temp = odd.next;      odd.next = p;      p.next = temp;      odd = odd.next;      even = even.next;      if (even == null) break;      p = even.next;    &#125;    return dump.next;  &#125;  public ListNode oddEvenListII(ListNode head) &#123;    if (head == null || head.next == null) return head;    ListNode headOdd = head;    ListNode headEven = head.next;    ListNode tailOdd = head;    ListNode taillEven = head.next;    while (taillEven.next != null) &#123;      ListNode t = taillEven.next;      tailOdd.next = t;      taillEven.next = t.next;      t.next = headEven;      taillEven = taillEven.next;      tailOdd = tailOdd.next;    &#125;    return headOdd;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  PascalsTriangle","url":"/article/leetcode-PascalsTriangle/","content":"import java.util.ArrayList;import java.util.List;public class PascalsTriangle &#123;  public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;    List&lt;Integer&gt; t = new ArrayList&lt;&gt;();    t.add(1);    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    ans.add(t);    for (int i=1; i&lt;numRows; i++) &#123;      List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();      for (int j=0; j&lt;=i; j++) &#123;        if (j==0 || j == i) &#123;          temp.add(1);        &#125;        else &#123;          temp.add(ans.get(ans.size()-1).get(j) + ans.get(ans.size()-1).get(j-1));        &#125;      &#125;      ans.add(temp);    &#125;    return ans;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode PopulatingNextRightPointersinEachNode","url":"/article/leetcode-PopulatingNextRightPointersinEachNode/","content":"import utils.NodeNext;public class PopulatingNextRightPointersinEachNode &#123;  public NodeNext connect(NodeNext root) &#123;    NodeNext levelStart = root;    while(levelStart != null) &#123;      NodeNext cur = levelStart;      while (cur != null) &#123;        cur.left.next = cur.right;        if(cur.next != null) &#123;          cur.right.next = cur.next.left;        &#125;        cur = cur.next;      &#125;      levelStart = levelStart.left;    &#125;    return root;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  PowerofFour","url":"/article/leetcode-PowerofFour/","content":"public class PowerofFour &#123;  /**   * Given an integer (signed 32 bits), write a function to check whether it is a power of 4.   * 判断一个数是否是4的幂， 4 ^ x = num;   *   * Example 1:   *   * Input: 16   * Output: true   * Example 2:   *   * Input: 5   * Output: false   * Follow up: Could you solve it without loops/recursion?   */  public boolean isPowerOfFour(int num) &#123;    if (num == 1) return true;    if (num % 2 == 1) return false;  while(num % 4 == 0)&#123;    num = num/4;  &#125;  if (num != 1)&#123;    return false;  &#125;  return true;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode PowerofThree","url":"/article/leetcode-PowerofThree/","content":"public class PowerofThree &#123;  /**   * Given an integer, write a function to determine if it is a power of three.   *   * Example 1:   *   * Input: 27   * Output: true   * Example 2:   *   * Input: 0   * Output: false   * Example 3:   *   * Input: 9   * Output: true   * Example 4:   *   * Input: 45   * Output: false   * Follow up:   * Could you do it without using any loop / recursion?   */  public boolean isPowerOfThree(int n) &#123;    return true;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  PreorderTravel","url":"/article/leetcode-PreorderTravel/","content":"import utils.ListNode;import utils.TreeNode;import java.util.LinkedList;import java.util.List;import java.util.Stack;public class PreorderTravel &#123;    /*        Input: [1,null,2,3]           1            \\             2            /           3        Output: [1,2,3]        better not recurritive but iterative     */    public static void main(String[] args)&#123;    &#125;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();        List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();        if (root != null)&#123;            s.push(root);        &#125;        while(!s.isEmpty()) &#123;            root = s.pop();            ans.add(root.val);            TreeNode left = root.left;            TreeNode right = root.right;            if (right != null) &#123;                s.push(right);            &#125;            if (left != null)&#123;                s.push(left);            &#125;        &#125;        return ans;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  RansomNote","url":"/article/leetcode-RansomNote/","content":"public class RansomNote &#123;  /**   * Given an arbitrary ransom note string and another string containing letters from all the magazines,   * write a function that will return true if the ransom note can be constructed from the magazines ;   * otherwise, it will return false.   *   * Each letter in the magazine string can only be used once in your ransom note.   *   * Note:   * You may assume that both strings contain only lowercase letters.   *   * canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false   * canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false   * canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true   */  public boolean canConstruct(String ransomNote, String magazine) &#123;    int[] l = new int[26];    for (char c: magazine.toCharArray())&#123;      l[c-&#x27;a&#x27;] ++;    &#125;    for (char c: ransomNote.toCharArray())&#123;      if (--l[c-&#x27;a&#x27;]&lt;0)        return false;    &#125;    return true;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  ReconstructItinerary","url":"/article/leetcode-ReconstructItinerary/","content":"import java.util.*;public class ReconstructItinerary &#123;  /**   * Given a list of airline tickets represented by pairs of departure and arrival airports [from, to],   * reconstruct the itinerary in order.   * All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.   *   * Note:   *   * If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.   * For example, the itinerary [&quot;JFK&quot;, &quot;LGA&quot;] has a smaller lexical order than [&quot;JFK&quot;, &quot;LGB&quot;].   * All airports are represented by three capital letters (IATA code).   * You may assume all tickets form at least one valid itinerary.   * Example 1:   *   * Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]   * Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]   * Example 2:   *   * Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]   * Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]   * Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;].   *              But it is larger in lexical order.   */    public static List&lt;String&gt; findItinerary(String[][] tickets) &#123;      LinkedList&lt;String&gt; res = new LinkedList&lt;&gt;();      if (tickets.length == 0) return res;      Map&lt;String, PriorityQueue&lt;String&gt;&gt; map = new HashMap&lt;&gt;();      for (String[] ticket : tickets) &#123;        if (!map.containsKey(ticket[0])) &#123;          map.put(ticket[0], new PriorityQueue&lt;&gt;());        &#125;        map.get(ticket[0]).offer(ticket[1]);      &#125;      Stack&lt;String&gt; stack = new Stack&lt;&gt;();      stack.push(&quot;a&quot;);      while (!stack.isEmpty()) &#123;        String top = stack.peek();        if (!map.containsKey(top) || map.get(top).isEmpty()) &#123;          res.addFirst(stack.pop());        &#125; else &#123;          stack.push(map.get(top).poll());        &#125;      &#125;      return res;    &#125;    public static void main(String[] args) &#123;      String[][] tickets = new String[][]&#123;&#123;&quot;a&quot;,&quot;b&quot;&#125;,&#123;&quot;b&quot;, &quot;c&quot;&#125;,&#123;&quot;c&quot;, &quot;d&quot;&#125;,&#123;&quot;c&quot;,&quot;a&quot;&#125;&#125;;      for (String s: findItinerary(tickets))&#123;        System.out.println(s);      &#125;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  RectangleArea","url":"/article/leetcode-RectangleArea/","content":"import java.util.Arrays;public class RectangleArea &#123;  /**   * Rectangle Area   * Find the total area covered by two rectilinear rectangles in a 2D plane.   *   * Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.   *   * Rectangle Area   * -------   *|       |   *|     --+---   *|    |  |   |   * ----+--    |   *     |      |   *      ------   * Example:   *   * Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2   * Output: 45   */  public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123;    int total = (G - E) * (H - F) + (C - A) * (D - B);    if (B &gt;= H || D &lt;= F || C &lt;= E || A&gt;= G)&#123;      return total;    &#125;    int x[] = &#123;A, C, E, G&#125;;    int y[] = &#123;B, D, F, H&#125;;    Arrays.sort(x);    Arrays.sort(y);    int overlaping = (x[2]-x[1]) * (y[2]-y[1]);    return total - overlaping;  &#125;  public static void main(String[] args)&#123;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  ReorderList","url":"/article/leetcode-ReorderList/","content":"import utils.ListNode;public class ReorderList &#123;    /*        Given a singly linked list L: L0→L1→…→Ln-1→Ln,        reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…        You may not modify the values in the list&#x27;s nodes, only nodes itself may be changed.        Example 1:        Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.        Example 2:        Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.     */    public static void main(String[] args)&#123;        ListNode a = new ListNode(1);        ListNode b = new ListNode(2);        ListNode c = new ListNode(3);        ListNode d = new ListNode(4);        a.next = null;//        reorderList(a);        a.next = b;//        reorderList(a);//        b.next = c;//        reorderList(a);//        c.next = d;        reorderList(a);    &#125;    public static void reorderList(ListNode head) &#123;            ListNode dump = head;            ListNode slow = head;            ListNode fast = head;            while(fast!=null &amp;&amp; fast.next != null)&#123;                slow = slow.next;                fast = fast.next.next;            &#125;            ListNode mid = slow.next;            ListNode l1 = head;            ListNode l2 = mid;            while(head.next != l2)&#123;                head = head.next;            &#125;            head.next = null;            // reverse            ListNode p = l2;            ListNode q = p.next;            boolean first = true;            while(q!= null)&#123;                ListNode t = q.next;                q.next = p;                if (first)&#123;                    p.next = null;                    first = false;                &#125;                p = q;                q = t;            &#125;            l2 = p;            p = l1;            q = l2;            print(l1);            print(l2);            // merge            while(l2 != null)&#123;                p = p.next;                q = q.next;                l1.next = l2;                l2.next = p;                l2 = q;                l1 = p;            &#125;            print(dump);        &#125;        public static void print(ListNode head)&#123;            ListNode t = head;            while(t!= null)&#123;                System.out.print(t.val+&quot; &quot;);                t = t.next;            &#125;            System.out.println();        &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  RemoveInvalidParentheses","url":"/article/leetcode-RemoveInvalidParentheses/","content":"import java.util.HashSet;import java.util.LinkedList;import java.util.List;import java.util.Queue;public class RemoveInvalidParentheses &#123;  /**   * Remove the minimum number of invalid parentheses in order to make the input string valid.   * Return all possible results.   *   * Note: The input string may contain letters other than the parentheses ( and ).   *   * Example 1:   *   * Input: &quot;()())()&quot;   * Output: [&quot;()()()&quot;, &quot;(())()&quot;]   * Example 2:   *   * Input: &quot;(a)())()&quot;   * Output: [&quot;(a)()()&quot;, &quot;(a())()&quot;]   * Example 3:   *   * Input: &quot;)(&quot;   * Output: [&quot;&quot;]   */  public static List&lt;String&gt; removeInvalidParentheses(String s) &#123;    HashSet&lt;String&gt; visited = new HashSet&lt;&gt;();    Queue&lt;String&gt; q = new LinkedList&lt;&gt;();    List&lt;String&gt; res = new LinkedList&lt;&gt;();    boolean found = false;    q.offer(s);    while(!q.isEmpty())&#123;      s = q.poll();      if (isValid(s))&#123;        found = true;        res.add(s);      &#125;      if (found) continue;      for (int i=0; i&lt;s.length(); i++)&#123;        if (s.charAt(i) == &#x27;(&#x27; || s.charAt(i) == &#x27;)&#x27;) &#123;          String t = s.substring(0, i) + s.substring(i+1);          if (!visited.contains(t))&#123;            q.offer(t);            visited.add(t);          &#125;        &#125;      &#125;    &#125;    return res;  &#125;  public static void main(String[] args) &#123;    String s = &quot;(())())&quot;;    for (String ss: removeInvalidParentheses(s))&#123;      System.out.println(ss);    &#125;  &#125;  public static boolean isValid(String s)&#123;    int count = 0;    for (int i=0; i&lt;s.length(); i++) &#123;      if (s.charAt(i) == &#x27;(&#x27;) count ++;      if (s.charAt(i) == &#x27;)&#x27;) &#123;        if (--count &lt; 0)          return false;      &#125;    &#125;    return count == 0;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  ReverseString","url":"/article/leetcode-ReverseString/","content":"public class ReverseString &#123;  /**   * Write a function that reverses a string. The input string is given as an array of characters char[].   *   * Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.   *   * You may assume all the characters consist of printable ascii characters.   *   *   *   * Example 1:   *   * Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]   * Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]   * Example 2:   *   * Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]   * Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]   */  public static  void reverseString(char[] s) &#123;    int n = s.length;    int left = 0;    int right = s.length-1;    while(left &lt; right)&#123;      char t = s[left];      s[left] = s[right];      s[right] = t;      left ++;      right --;    &#125;    return ;  &#125;  public static void main(String[] args)&#123;    char[] s = new char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;0&#x27;&#125;;    reverseString(s);    for (char c: s)&#123;      System.out.println(c);    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 309 Best Time to Buy and Sell Stock with Cooldown","url":"/article/leetcode-BestTimetoBuyandSellStockwithCooldown/","content":"Say you have an array for which the ithelement is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\n\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\nAfter you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\n\nExample:\nInput: [1,2,3,0,2]Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell]\n\npublic class BestTimetoBuyandSellStockwithCooldown &#123;  public int maxProfit(int[] prices)&#123;    int[] sell = new int[prices.length];    int[] buy = new int[prices.length];    int[] cooldown = new int[prices.length];    buy[0] = -prices[0];    for (int i=1; i&lt;prices.length; i++)&#123;      buy[i] = Math.max(buy[i-1], cooldown[i-1] - prices[i]);      sell[i] = Math.max(sell[i-1], buy[i-1]+prices[i]);      cooldown[i] = Math.max(cooldown[i-1], sell[i-1]);    &#125;    return Math.max(sell[prices.length-1], cooldown[prices.length-1]);  &#125;  public int maxProfitII(int[] prices)&#123;    if (prices.length == 0 || prices == null)      return 0;    int buy = -prices[0];    int sell = 0;    int cooldown = 0;    for (int price: prices) &#123;      int preBuy = buy;      int preSell = sell;      int preCool = cooldown;      buy = Math.max(preBuy, cooldown-price);      sell = Math.max(preSell, preBuy+price);      cooldown = Math.max(preCool, preSell);    &#125;    return Math.max(cooldown, sell);  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode ReverseVowelsofaString","url":"/article/leetcode-ReverseVowelsofaString/","content":"import java.util.HashMap;import java.util.HashSet;public class ReverseVowelsofaString &#123;  /**   * Write a function that takes a string as input and reverse only the vowels of a string.   * &lt;p&gt;   * Example 1:   * &lt;p&gt;   * Input: &quot;hello&quot;   * Output: &quot;holle&quot;   * Example 2:   * &lt;p&gt;   * Input: &quot;leetcode&quot;   * Output: &quot;leotcede&quot;   */  public String reverseVowels(String s) &#123;    HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;();    char[] sc = s.toCharArray();    vowels.add(&#x27;a&#x27;);    vowels.add(&#x27;e&#x27;);    vowels.add(&#x27;i&#x27;);    vowels.add(&#x27;o&#x27;);    vowels.add(&#x27;u&#x27;);    int left = 0;    int right = s.length() - 1;    while (left &lt; right) &#123;      if (vowels.contains(sc[left]) &amp;&amp; vowels.contains(sc[right])) &#123;        char t = sc[left];        sc[left] = sc[right];        sc[right] = t;      &#125;      if (!vowels.contains(sc[left])) left++;      if (!vowels.contains(sc[right])) right--;    &#125;    StringBuilder sb = new StringBuilder();    for (char c: sc)&#123;      sb.append(c);    &#125;    return sb.toString();  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode ReverseWordsInString","url":"/article/leetcode-ReverseWordsInString/","content":"public class ReverseWordsInString &#123;  /*      Given an input string, reverse the string word by word.      Example:      Input: &quot;the sky is blue&quot;,      Output: &quot;blue is sky the&quot;.      Note:      A word is defined as a sequence of non-space characters.      Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.      You need to reduce multiple spaces between two words to a single space in the reversed string.      Follow up: For C programmers, try to solve it in-place in O(1) space.   */  public static String reverseWords(String s) &#123;    char[] line = s.toCharArray();    int n = line.length;    if (n==0) return null;    //1. reverse the whole string    reverse(line, 0, n-1);    //2. reverse everywords    reverseWord(line, n-1);//    return new String(line);    //3. cleanSpace    return cleanSpace(line, n-1);  &#125;  public static String cleanSpace(char[] array, int n)&#123;    int i=0;    int j=0;    while(j&lt;n) &#123;      while (j &lt;= n &amp;&amp; array[j] == &#x27; &#x27;) j++;      while (j &lt;= n &amp;&amp; array[j] != &#x27; &#x27;) array[i++] = array[j++];      while (j &lt;= n &amp;&amp; array[j] == &#x27; &#x27;) j++;      System.out.println(i);      System.out.println(j);      if (j&lt;n)&#123;        array[i++]=&#x27; &#x27;;      &#125;    &#125;    return new String(array).substring(0, i)+&#x27;;&#x27;;  &#125;  public static void reverseWord(char[] array, int n)&#123;    int i=0;    int j=0;    while(i&lt;n)&#123;      while(i&lt;n &amp;&amp; array[i]==&#x27; &#x27;) i++;      while(j&lt;i || (j&lt;n &amp;&amp; array[j]!=&#x27; &#x27;) ) j++;      System.out.println(i);      System.out.println(j);      if (j==n)&#123;        reverse(array, i, j);        i=j;      &#125;      else&#123;        reverse(array, i, j-1);        i=j;      &#125;    &#125;  &#125;  public static void reverse(char[] array, int i, int j)&#123;    while(i&lt;j)&#123;      char temp = array[j];      array[j] = array[i];      array[i] = temp;      i++;      j--;    &#125;  &#125;  public static void main(String[] args)&#123;    String s = &quot;    the  sky is blue     &quot;;    System.out.println(reverseWords(s));  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  RussianDollEnvelopes","url":"/article/leetcode-RussianDollEnvelopes/","content":"import java.util.Collections;public class RussianDollEnvelopes &#123;  /**   * You have a number of envelopes with widths and heights given as a pair of integers (w, h).   * One envelope can fit into another if and only if both the width and height of one envelope is greater   * than the width and height of the other envelope.   *   * What is the maximum number of envelopes can you Russian doll? (put one inside other)   *   * Note:   * Rotation is not allowed.   *   * Example:   *   * Input: [[5,4],[6,4],[6,7],[2,3]]   * Output: 3   * Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7])   */  public int maxEnvelopes(int[][] envelopes) &#123;    if (envelopes.length == 0 || envelopes == null) return 0;    int n = envelopes.length;    int[] dp = new int[envelopes.length];    sort(envelopes);    int max_count=0;    int max_idx = 0;    for (int i=1; i&lt;envelopes.length; i++)&#123;      for (int j=0; j&lt;i; j++)&#123;        if (envelopes[i][0]&gt;envelopes[j][0] &amp;&amp; envelopes[i][1]&gt;envelopes[j][1])&#123;          dp[i] = Math.max(dp[i], dp[j] + 1);          if (dp[i] &gt; max_count)&#123;            max_count = dp[i];            max_idx = i;          &#125;        &#125;      &#125;    &#125;    return dp[max_idx]+1;  &#125;  public static void sort(int[][] envelopes)&#123;    for (int i=1; i&lt;envelopes.length; i++)&#123;      for (int j=0; j&lt;i; j++)&#123;        if (envelopes[i][0]&lt;envelopes[j][0])&#123;          int[] temp = envelopes[i];          envelopes[i] = envelopes[j];          envelopes[j] = temp;        &#125;        else if (envelopes[i][1]==envelopes[j][1])&#123;          if (envelopes[i][1] &lt; envelopes[j][1])&#123;            int[] temp = envelopes[i];            envelopes[i] = envelopes[j];            envelopes[j] = temp;          &#125;        &#125;      &#125;    &#125;  &#125;  public static void main(String[] args)&#123;    int[][] test = new int[][]&#123;&#123;5,4&#125;,&#123;6,4&#125;,&#123;6,7&#125;,&#123;2,3&#125;&#125;;    sort(test);    for (int[] a: test)&#123;      System.out.println(a[0] + &quot; &quot; + a[1]);    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  RotateFunction","url":"/article/leetcode-RotateFunction/","content":"public class RotateFunction &#123;  public int maxRotateFunction(int[] A) &#123;    int sum=0;    int b = 0;    int f=0;    for (int i: A)&#123;      sum += i;      f += i * b;      b += 1;    &#125;    int max = f;    for (int i=1; i&lt;A.length; i++)&#123;      int ff = f + sum - A.length * A[A.length-i];      f = ff;      max = Math.max(max, ff);    &#125;    return max;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  Searcha2DMatrixII","url":"/article/leetcode-Searcha2DMatrixII/","content":"public class Searcha2DMatrixII &#123;    /**     * Write an efficient algorithm that searches for a value in an m x n matrix.     * This matrix has the following properties:     *     * Integers in each row are sorted in ascending from left to right.     * Integers in each column are sorted in ascending from top to bottom.     * Example:     *     * Consider the following matrix:     *     * [     *   [1,   4,  7, 11, 15],     *   [2,   5,  8, 12, 19],     *   [3,   6,  9, 16, 22],     *   [10, 13, 14, 17, 24],     *   [18, 21, 23, 26, 30]     * ]     * [     * [3, 5,  9,  9, 14],     * [7, 8, 11, 15, 15],     * [8,10, 16, 16, 17]]     * 12     * Given target = 5, return true.     *     * Given target = 20, return false.     */    public boolean searchMatrix(int[][] matrix, int target) &#123;        int lx = 0;        int ly = 0;        int rx = matrix[0].length-1;        int ry = matrix.length-1;        while (lx &lt; rx &amp;&amp; ly &lt; ry) &#123;            int midx = (lx + rx) / 2;            int midy = (ly + ry) / 2;            if ( matrix[midx][midy] == target) return true;            else if (matrix[midx][midy] &lt; target) &#123;                lx = midx + 1;                ly = midy + 1;            &#125;            else &#123;                rx = midx;                ry = midy;            &#125;        &#125;        int l = 0;        int r = lx;        while (l &lt;= r) &#123;            int mid = (l + r) / 2;            if (matrix[ly][mid] == target) return true;            else if (matrix[ly][mid] &lt; target) l = mid + 1;            else r = mid - 1;        &#125;        l = 0;        r = ly;        while (l &lt;= r) &#123;            int mid = (l + r) /2;            if (matrix[mid][lx] == target) return true;            if (matrix[mid][lx] &lt; target) l = mid + 1;            else r = mid - 1;        &#125;        return false;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  ShortestPalindrome","url":"/article/leetcode-ShortestPalindrome/","content":"public class ShortestPalindrome &#123;  /**   * Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.   *   * Example 1:   *   * Input: &quot;aacecaaa&quot;   * Output: &quot;aaacecaaa&quot;   * Example 2:   *   * Input: &quot;abcd&quot;   * Output: &quot;dcbabcd&quot;   */  public static void main(String[] args)&#123;    String[] test = &#123;&quot;hello&quot;, &quot;aaa&quot;, &quot;a&quot;, &quot;de&quot;&#125;;    for (String s: test)&#123;//      System.out.println(isPalidrome(s));      System.out.println(shortestPalindrome(s));    &#125;  &#125;  public static String shortestPalindrome(String s) &#123;    if (isPalidrome(s))      return s;    s =  new StringBuffer(s).reverse().toString();    String ss = s;    int length = 1;    while(!isPalidrome(ss))&#123;      ss = s + new StringBuffer(s.substring(0, length)).reverse().toString();      length ++;    &#125;    return ss;  &#125;  public static boolean isPalidrome(String s)&#123;    char[] l = s.toCharArray();    if (l.length == 1 || (l.length == 2 &amp;&amp; l[0] == l[1]))&#123;      return true;    &#125;    else if (l.length &gt; 2 &amp;&amp; isPalidrome(s.substring(1, s.length()-1)) &amp;&amp; l[0] == l[l.length-1])&#123;      return true;    &#125;    else&#123;      return false;    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode SearchinRotatedSortedArray","url":"/article/leetcode-SearchinRotatedSortedArray/","content":"public class SearchinRotatedSortedArray &#123;    /**     * Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.     *     * (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).     *     * You are given a target value to search. If found in the array return its index, otherwise return -1.     *     * You may assume no duplicate exists in the array.     *     * Your algorithm&#x27;s runtime complexity must be in the order of O(log n).     *     * Example 1:     *     * Input: nums = [4,5,6,7,0,1,2], target = 0     * Output: 4     * Example 2:     *     * Input: nums = [4,5,6,7,0,1,2], target = 3     * Output: -1     */    public static int search(int[] nums, int target) &#123;        int left = 0;        int right = nums.length-1;        while (left &lt; right) &#123;            int mid = (left + right) / 2;            if (nums[mid] &gt; nums[0]) &#123;                left = mid + 1;            &#125;            else &#123;                right = mid;            &#125;        &#125;        int min = left;        if (target == nums[0]) return 0;        if (min == 0 || target &lt; nums[0]) &#123;            left = min;            right = nums.length-1;        &#125;        else  &#123;            left = 1;            right = min-1;        &#125;        System.out.println(left + &quot; &quot;+ right);        while (left &lt;= right) &#123;            int mid = (left + right) / 2;            if (nums[mid] == target) return mid;            else if (nums[mid] &lt; target) &#123;                left = mid + 1;            &#125;            else &#123;                right = mid - 1;            &#125;        &#125;        return -1;    &#125;    public static void main(String[] args) &#123;        search(new int[]&#123;4,3,2,1,0&#125;, 3);    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  SelfCrossing","url":"/article/leetcode-SelfCrossing/","content":"public class SelfCrossing &#123;  /**   * You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north,   * then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words,   * after each move your direction changes counter-clockwise.   *   * Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not.   */  public boolean isSelfCrossing(int[] x) &#123;    int n = x.length;    if (n &lt; 4)      return false;    for (int i=3; i&lt;n; i++)&#123;      if (i==4)&#123;        if ((x[0] &lt; x[2]) || ((x[0] &gt; x[2]) &amp;&amp; (x[1] &gt; x[3])))          return true;      &#125;    &#125;    return false;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode SearchforaRange","url":"/article/leetcode-SearchforaRange/","content":"public class SearchforaRange &#123;    /**     * Given an array of integers nums sorted in ascending order,     * find the starting and ending position of a given target value.     *     * Your algorithm&#x27;s runtime complexity must be in the order of O(log n).     *     * If the target is not found in the array, return [-1, -1].     *     * Example 1:     *     * Input: nums = [5,7,7,8,8,10], target = 8     * Output: [3,4]     * Example 2:     *     * Input: nums = [5,7,7,8,8,10], target = 6     * Output: [-1,-1]     */    public int[] searchRange(int[] nums, int target) &#123;        int left = 0;        int right = nums.length-1;        while (left &lt; right) &#123;            int mid = (left + right) / 2;            if (nums[mid] &gt;= target) &#123;                right = mid;            &#125;            else &#123;                left = mid+1;            &#125;        &#125;        if (right != target) return new int[]&#123;-1, -1&#125;;        left = 0;        right = nums.length-1;        int a = right;        while (left &lt; right) &#123;            int mid = (left + right + 1) / 2;            if (nums[mid] &lt;= target) &#123;                left = mid;            &#125;            else &#123;                right = mid - 1;            &#125;        &#125;        return new int[]&#123;&#125;;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  ShuffleanArray","url":"/article/leetcode-ShuffleanArray/","content":"public class ShuffleanArray &#123;  /**   * Shuffle a set of numbers without duplicates.   *   * Example:   *   * // Init an array with set 1, 2, and 3.   * int[] nums = &#123;1,2,3&#125;;   * Solution solution = new Solution(nums);   *   * // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.   * solution.shuffle();   *   * // Resets the array back to its original configuration [1,2,3].   * solution.reset();   *   * // Returns the random shuffling of array [1,2,3].   * solution.shuffle();   */  int [] OriginalNums;  public ShuffleanArray(int[] nums) &#123;    this.OriginalNums = nums;  &#125;  /** Resets the array to its original configuration and return it. */  public int[] reset() &#123;    return this.OriginalNums;  &#125;  /** Returns a random shuffling of the array. */  public int[] shuffle() &#123;    return this.OriginalNums;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 260 Single Number III","url":"/article/leetcode-SingleNumberIII/","content":"Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\nExample:\nInput:  [1,2,1,3,2,5]Output: [3,5]\nNote:\n\nThe order of the result is not important. So in the above example, [5, 3] is also correct.\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?\n\n\npublic class SingleNumberIII &#123;  public static void main(String[] args)&#123;    System.out.println(6&amp;(-6));  &#125;  public static int[] singleNumber(int[] nums) &#123;    //1. get the xor of a,b    int xor = 0;    for (int i: nums)&#123;      xor ^= i;    &#125;    //2. find the last different bits of the xor ans,    //    note that -xor means opposite all bits of xor and then add 1.    //    xor &amp; -xor preserves the last &#x27;1&#x27; bit of xor of a and b    int diff = xor &amp; -xor;    //3. for every num, put it into the first group when the diff bit is &#x27;1&#x27; and put it into the second group when is &#x27;0&#x27;    int ans[] = &#123;0,0&#125;;    for (int i: nums)&#123;      if ((i &amp; diff) == 0)&#123;        ans[0] ^= i;      &#125;      else&#123;        ans[1] ^= i;      &#125;    &#125;    return ans;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  SingleNumberII","url":"/article/leetcode-SingleNumberII/","content":"public class SingleNumberII &#123;  /**   * Given a non-empty array of integers, every element appears three times except for one,   * which appears exactly once. Find that single one.   *   * Note:   *   * Your algorithm should have a linear runtime complexity.   * Could you implement it without using extra memory?   *   * Example 1:   *   * Input: [2,2,3,2]   * Output: 3   * Example 2:   *   * Input: [0,1,0,1,0,1,99]   * Output: 99   */  public static int singleNumber(int[] nums) &#123;    int ans = 0;    int mask;    for (int i=0; i&lt;32; i++) &#123;      mask = 1 &lt;&lt; i;      int t = 0;      for (int n: nums) &#123;        t += mask &amp; n;      &#125;      if (t%3 == 1)&#123;        ans |= mask;      &#125;    &#125;    return ans;  &#125;  public static void main(String[] args) &#123;    int[] test = new int[]&#123;1,1,1,2,2,2,3,3,3,4&#125;;    System.out.println(singleNumber(test));  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode SingleNumber","url":"/article/leetcode-SingleNumber/","content":"public class SingleNumber &#123;  public static void main(String[] args)&#123;    int i = 9; // 1001    int x = 1; //    1    System.out.println(i^x);    System.out.println(i|x);    System.out.println(i&amp;x);  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  SortColors","url":"/article/leetcode-SortColors/","content":"public class SortColors &#123;    public void sortColors(int[] nums) &#123;        /**         * Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent,         * with the colors in the order red, white and blue.         *         * Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.         *         * Note: You are not suppose to use the library&#x27;s sort function for this problem.         *         * Example:         *         * Input: [2,0,2,1,1,0]         * Output: [0,0,1,1,2,2]         * Follow up:         *         * A rather straight forward solution is a two-pass algorithm using counting sort.         * First, iterate the array counting number of 0&#x27;s, 1&#x27;s, and 2&#x27;s, then overwrite array with total number of 0&#x27;s,         * then 1&#x27;s and followed by 2&#x27;s.         * Could you come up with a one-pass algorithm using only constant space?         */        int left = 0;        int right = nums.length-1;        int i = 0;        while (i&lt;=right) &#123;            if (nums[i] == 2) &#123;                swap(nums, i, right);                right --;            &#125;            else if (nums[i] == 0) &#123;                swap(nums, i, left);                left ++;            &#125;            else                i ++;        &#125;    &#125;    public void swap(int[] nums, int i, int j) &#123;        int t= nums[i];        nums[i] = nums[j];        nums[j] = t;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  Subset","url":"/article/leetcode-Subset/","content":"import java.util.ArrayList;import java.util.List;public class Subset &#123;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        if (nums.length == 0) return ans;        for (int k=0; k&lt;=nums.length; k++) &#123;            List&lt;Integer&gt; t = new ArrayList&lt;&gt;();            helper(ans, nums, t, 0, k);        &#125;        return ans;    &#125;    public void helper(List&lt;List&lt;Integer&gt;&gt; ans, int[] nums,List&lt;Integer&gt; t , int k, int width) &#123;        if (t.size() == width) &#123;            ans.add(new ArrayList&lt;&gt;());            return ;        &#125;        for (int i=k; i&lt;nums.length; i++) &#123;            t.add(i);            helper(ans, nums, t, k+1, width);            t.remove(t.size()-1);        &#125;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  SumofTwoIntegers","url":"/article/leetcode-SumofTwoIntegers/","content":"public class SumofTwoIntegers &#123;  /*    Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.    Example 1:    Input: a = 1, b = 2    Output: 3    Example 2:    Input: a = -2, b = 3    Output: 1   */  public int getSum(int a, int b) &#123;    int sum = (a ^ b);    int carry = ( a &amp; b ) &lt;&lt; 1;    if (carry == 0)&#123;      return sum;    &#125;    return getSum(sum, carry);  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode SuperPow","url":"/article/leetcode-SuperPow/","content":"public class SuperPow &#123;  /**   * Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer   * given in the form of an array.   *   * Example 1:   *   * Input: a = 2, b = [3]   * Output: 8   * Example 2:   *   * Input: a = 2, b = [1,0]   * Output: 1024   */&#125;\n","tags":["leetcode"]},{"title":"leetcode  ThreeSums","url":"/article/leetcode-ThreeSum/","content":"import java.util.*;public class ThreeSum &#123;  /**   * Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0?   * Find all unique triplets in the array which gives the sum of zero.   *   * Note:   *   * The solution set must not contain duplicate triplets.   *   * Example:   *   * Given array nums = [-1, 0, 1, 2, -1, -4],   *   * A solution set is:   * [   *   [-1, 0, 1],   *   [-1, -1, 2]   * ]   */  public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    if (nums.length &lt; 3) return ans;    Arrays.sort(nums);    for (int i=0; i&lt;nums.length; i++) &#123;      int left = nums[i+1];      int right = nums[nums.length-1];      while (left &lt; right) &#123;        if (nums[i] + nums[left] + nums[right] == 0) &#123;          ans.add(Arrays.asList(nums[i], nums[left], nums[right]));        &#125;      &#125;    &#125;    return ans;  &#125;  public static void main(String[] args) &#123;    for (List&lt;Integer&gt; l : threeSum(new int[]&#123;-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6&#125;)) &#123;      for (int i: l) &#123;        System.out.print(i + &quot; &quot;);      &#125;      System.out.println();    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  TopKFrequentElements","url":"/article/leetcode-TopKFrequentElements/","content":"import java.util.*;public class TopKFrequentElements &#123;  /**   * Top K Frequent Elements   * Given a non-empty array of integers, return the k most frequent elements.   *   * Example 1:   *   * Input: nums = [1,1,1,2,2,3], k = 2   * Output: [1,2]   * Example 2:   *   * Input: nums = [1], k = 1   * Output: [1]   * Note:   *   * You may assume k is always valid, 1 ≤ k ≤ number of unique elements.   * Your algorithm&#x27;s time complexity must be better than O(n log n), where n is the array&#x27;s size.   */  public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123;    HashMap&lt;Integer, Integer&gt; frequency = new HashMap&lt;&gt;();    PriorityQueue&lt;int[]&gt; res = new PriorityQueue&lt;int[]&gt;((a, b)-&gt; a[1] - b[1]);    for (int i: nums)&#123;      if (!frequency.containsKey(i))&#123;        int count = frequency.get(i);        frequency.replace(i, count + 1);      &#125;      else &#123;        frequency.put(i, 1);      &#125;    &#125;    for (int key: frequency.keySet())&#123;      int f = frequency.get(key);      if (res.size()!= k)&#123;        res.offer(new int[]&#123;key, f&#125;);      &#125;      else &#123;        int[] t = res.poll();        if (t[1] &gt; f)&#123;          res.remove();          res.offer(new int[]&#123;key, f&#125;);        &#125;      &#125;    &#125;    List&lt;Integer&gt; r = new LinkedList&lt;&gt;();    for (int f: frequency.keySet())&#123;      r.add(f);    &#125;    return r;  &#125;  public List&lt;Integer&gt; topKFrequentII(int[] nums, int k) &#123;    HashMap&lt;Integer, Integer&gt; frequency = new HashMap&lt;&gt;();    for (int i: nums) &#123;      if (!frequency.containsKey(i)) &#123;        frequency.put(i, 0);      &#125;      frequency.put(i, frequency.get(i)+1);    &#125;    List&lt;Integer&gt;[] bucket = new List[nums.length];    for (int key: frequency.keySet()) &#123;      int f = frequency.get(key);      if (bucket[f] == null) &#123;        bucket[f] = new ArrayList&lt;&gt;();      &#125;      bucket[f].add(key);    &#125;    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();    for (int i=nums.length-1; i&gt;=0 &amp;&amp; k&gt;0; i--) &#123;      if (bucket[i] != null) &#123;        for (int num: bucket[i])&#123;          ans.add(num);        &#125;        k -= bucket[i].size();      &#125;    &#125;    return ans;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  SuperUglyNumber","url":"/article/leetcode-SuperUglyNumber/","content":"import java.util.HashMap;public class SuperUglyNumber &#123;  /**   * Write a program to find the nth super ugly number.   *   * Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k.   *   * Example:   *   * Input: n = 12, primes = [2,7,13,19]   * Output: 32   * Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12   *              super ugly numbers given primes = [2,7,13,19] of size 4.   * Note:   *   * 1 is a super ugly number for any given primes.   * The given numbers in primes are in ascending order.   * 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000.   * The nth super ugly number is guaranteed to fit in a 32-bit signed integer.   */  public int nthSuperUglyNumber(int n, int[] primes) &#123;    HashMap&lt;Integer, Integer&gt; idxs = new HashMap&lt;&gt;();    for (int i: primes)&#123;      idxs.put(i, 0);    &#125;    int dp[] = new int[n];    for (int i=0; i&lt;n; i++)&#123;      int min = Integer.MAX_VALUE;//      int minPrime = 0;      for (int idx : idxs.keySet())&#123;        if (min &gt; dp[idx] * idx)&#123;          min = dp[idx]*idx;//          minPrime = idx;        &#125;      &#125;      dp[i] = min;//      idxs.put(minPrime, idxs.get(minPrime)+1);      for (int idx: idxs.keySet())&#123;        if (dp[i] == idx*dp[idxs.get(idx)])&#123;          idxs.put(idx, idxs.get(idx)+1);        &#125;      &#125;    &#125;    return dp[primes.length-1];  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  UniqueBST","url":"/article/leetcode-UniqueBST/","content":"import apple.laf.JRSUIUtils;import utils.TreeNode;import java.util.LinkedList;import java.util.List;public class UniqueBST &#123;    /*    Given an integer n, generate all structurally unique BST&#x27;s (binary search trees) that store values 1 ... n.    Example:    Input: 3    Output:    [      [1,null,3,2],      [3,2,null,1],      [3,1,null,null,2],      [2,1,3],      [1,null,2,null,3]    ]    Explanation:    The above output corresponds to the 5 unique BST&#x27;s shown below:       1         3     3      2      1        \\       /     /      / \\      \\         3     2     1      1   3      2        /     /       \\                 \\       2     1         2                 3     */    public static void main(String[] args)&#123;        List&lt;TreeNode&gt; ans = uniqueBST(5);        for (int i=0; i&lt;ans.size(); i++)&#123;            System.out.println(ans.get(i));        &#125;    &#125;    public static List&lt;TreeNode&gt; generate_trees(int start, int end)&#123;        List&lt;TreeNode&gt; ans = new LinkedList&lt;&gt;();        if (start &gt; end)&#123;            return null;        &#125;        if (start == end)&#123;            ans.add(new TreeNode(start));        &#125;        for (int i=start; i&lt;=end; i++)&#123;            TreeNode root = new TreeNode(i);            List&lt;TreeNode&gt; left = generate_trees(start, i-1);            List&lt;TreeNode&gt; right = generate_trees(i+1, end);            for (TreeNode l: left)&#123;                for(TreeNode r: right)&#123;                    root.left = l;                    root.right = r;                &#125;            &#125;            ans.add(root);        &#125;        return ans;    &#125;    public static List&lt;TreeNode&gt; uniqueBST(int n)&#123;        List&lt;TreeNode&gt; ans = new LinkedList&lt;&gt;();        ans = generate_trees(1, n);        return ans;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode VerifyPreorderSerializationofaBinaryTree","url":"/article/leetcode-VerifyPreorderSerializationofaBinaryTree/","content":"import java.util.Stack;public class VerifyPreorderSerializationofaBinaryTree &#123;  /**   * One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node,   * we record the node&#x27;s value. If it is a null node, we record using a sentinel value such as #.   *   *      _9_   *     /   \\   *    3     2   *   / \\   / \\   *  4   1  #  6   * / \\ / \\   / \\   * # # # #   # #   * For example, the above binary tree can be serialized to the string &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;, where # represents a null node.   *   * Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree.   * Find an algorithm without reconstructing the tree.   *   * Each comma separated value in the string must be either an integer or a character &#x27;#&#x27; representing null pointer.   *   * You may assume that the input format is always valid, for example it could never contain two consecutive commas such as &quot;1,,3&quot;.   *   * Example 1:   *   * Input: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;   * Output: true   * Example 2:   *   * Input: &quot;1,#&quot;   * Output: false   * Example 3:   *   * Input: &quot;9,#,#,1&quot;   * Output: false   */  public static boolean isValidSerialization(String preorder) &#123;    Stack&lt;String&gt; stack = new Stack&lt;String&gt;();    String[] sc = preorder.split(&quot;,&quot;);    if (sc.length &lt; 3) return false;    for (String c: sc)&#123;      if (&quot;#&quot;.equals(c))&#123;        if (stack.size() == 0) return false;        if (!&quot;#&quot;.equals(stack.peek()))&#123;          stack.push(c);        &#125;        else&#123;          if (stack.size() &lt; 2) return false;          String a = stack.pop();          String b = stack.pop();          while (&quot;#&quot;.equals(a) &amp;&amp; !&quot;#&quot;.equals(b) &amp;&amp; stack.size()&gt;=2)&#123;            a = stack.pop();            b = stack.pop();          &#125;          if (! (&quot;#&quot;.equals(a)&amp;&amp;!&quot;#&quot;.equals(b)))&#123;            stack.push(b);            stack.push(a);            stack.push(c);          &#125;          else&#123;            stack.push(c);          &#125;        &#125;      &#125;      else&#123;        stack.push(c);      &#125;      for (String i: stack)&#123;        System.out.print(&quot;stack: &quot; + i + &quot; &quot;);      &#125;      System.out.println();    &#125;    if (stack.size() == 1 &amp;&amp; &quot;#&quot;.equals(stack.pop()))&#123;      return true;    &#125;    return false;  &#125;  public static void main(String[] args)&#123;    String[] test = new String[]&#123;&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;,&quot;1,#&quot;,&quot;9,#,#,1&quot;&#125;;    for (String s : test)&#123;      System.out.println(isValidSerialization(s));    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode WaterandJugProblem","url":"/article/leetcode-WaterandJugProblem/","content":"public class WaterandJugProblem &#123;  /*      You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available.      You need to determine whether it is possible to measure exactly z litres using these two jugs.      If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.      Operations allowed:      `Fill any of the jugs completely with water.      `Empty any of the jugs.      `Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.      Example 1: (From the famous &quot;Die Hard&quot; example)      Input: x = 3, y = 5, z = 4      Output: True      Example 2:      Input: x = 2, y = 6, z = 5      Output: False   */  public boolean waterJug(int x, int y, int z)&#123;    if (x+y &lt; z) return false;    if (z == x || z == y || z == x + y) return true;    return z%gcd(x, y)==0;  &#125;  public int gcd(int x, int y)&#123;    while(y!= 0)&#123;      int t = x % y;      x = y;      y = t;    &#125;    return x;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  ValidPerfectSquare","url":"/article/leetcode-ValidPerfectSquare/","content":"public class ValidPerfectSquare &#123;  /*      Given a positive integer num, write a function which returns True if num is a perfect square else False.      Note: Do not use any built-in library function such as sqrt.      Example 1:      Input: 16      Output: true      Example 2:      Input: 14      Output: false   */  public boolean isPerfectSquare(int num) &#123;    // 时间代价太高，可以使用二分搜索    int i=num/2;    if (num &lt; 0)&#123;      return false;    &#125;    for (int n = 0; n&lt;=i; n++)&#123;      if (n*n == num)        return true;    &#125;    return false;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode WiggleSortII","url":"/article/leetcode-WiggleSortII/","content":"import java.util.Arrays;public class WiggleSortII &#123;  /**   * Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]....   *   * Example 1:   *   * Input: nums = [1, 5, 1, 1, 6, 4]   * Output: One possible answer is [1, 4, 1, 5, 1, 6].   * Example 2:   *   * Input: nums = [1, 3, 2, 2, 3, 1]   * Output: One possible answer is [2, 3, 1, 3, 1, 2].   * Note:   * You may assume all input has valid answer.   *   * Follow Up:   * Can you do it in O(n) time and/or in-place with O(1) extra space?   */  public void wiggleSort(int[] nums) &#123;    Arrays.sort(nums);    int start = 0;    int n = nums.length;    int end = nums.length;    for (int i=1; i&lt;n; i+=2)&#123;    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode WiggleSubsequence","url":"/article/leetcode-WiggleSubsequence/","content":"public class WiggleSubsequence &#123;  /**   * Wiggle Subsequence   * A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative.   * The first difference (if one exists) may be either positive or negative.   * A sequence with fewer than two elements is trivially a wiggle sequence.   *   * For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative.   * In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences,   * the first because its first two differences are positive and the second because its last difference is zero.   *   * Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence.   * A subsequence is obtained by deleting some number of elements (eventually, also zero)   * from the original sequence, leaving the remaining elements in their original order.   *   * Example 1:   *   * Input: [1,7,4,9,2,5]   * Output: 6   * Explanation: The entire sequence is a wiggle sequence.   * Example 2:   *   * Input: [1,17,5,10,13,15,10,5,16,8]   * Output: 7   * Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].   * Example 3:   *   * Input: [1,2,3,4,5,6,7,8,9]   * Output: 2   * Follow up:   * Can you do it in O(n) time?   */  public int wiggleMaxLength(int[] nums) &#123;    if (nums.length==0 || nums== null)&#123;      return 0;    &#125;    else if (nums.length &lt;=2)&#123;      return nums.length;    &#125;    Boolean isIncreasing = null;    int count = 1;    for (int i=1; i&lt;nums.length; i++)&#123;      if (nums[i] &gt; nums[i-1])&#123;        if (isIncreasing == null || !isIncreasing)&#123;          count++;        &#125;        isIncreasing = true;      &#125;      else if (nums[i] &lt; nums[i-1])&#123;        if (isIncreasing== null || isIncreasing)&#123;          count ++;        &#125;        isIncreasing = false;      &#125;    &#125;    return count;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode Wiggle Sort II","url":"/article/leetcode-Wiggle-Sort-II/","content":"Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]....\nExample 1:\nInput: nums = [1, 5, 1, 1, 6, 4]Output: One possible answer is [1, 4, 1, 5, 1, 6].\nExample 2:\nInput: nums = [1, 3, 2, 2, 3, 1]Output: One possible answer is [2, 3, 1, 3, 1, 2].\nNote:\nYou may assume all input has valid answer.\nFollow Up:\nCan you do it in O(n) time and/or in-place with O(1) extra space?\n\n\n可以对nums进行排序，之后，后半部分的肯定比前半部分的数值要打，因此，后半部分的可以放在偶数位置上面。\n确定后半部分放在偶数位置上之后，需要确定应该正序方还是倒叙放。\n\n考虑4 5 5 6的情况\n\n如果前半部分正序，后半部分倒序，结果是4 6 5 5\n如果前半部分正序，后半部分正序，结果是4 5 5 6\n如果前半部分倒序，后半部分正序，结果是5 5 4 6\n如果前半部分倒序，后半部分倒序，结果是5 6 4 5\n\n\n\n\n\nclass Solution &#123;    public void wiggleSort(int[] nums) &#123;        int [] copy = new int[nums.length];        for (int i=0; i&lt;nums.length; i++) &#123;            copy[i] = nums[i];        &#125;                Arrays.sort(copy);        int i = (nums.length-1)/2;         int j = nums.length-1;        int idx = 0;        while (idx &lt; nums.length) &#123;            if (idx % 2 == 0) &#123;                nums[idx] = copy[i];                i-=1;            &#125;            else &#123;                nums[idx] = copy[j];                j-=1;            &#125;            idx ++;        &#125;            &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode WordBreak","url":"/article/leetcode-WordBreak/","content":"import java.util.HashMap;import java.util.HashSet;import java.util.List;public class WordBreak &#123;  /**   * Given a non-empty string s and a dictionary wordDict containing a list of non-empty words,   * determine if s can be segmented into a space-separated sequence of one or more dictionary words.   *   * Note:   *   * The same word in the dictionary may be reused multiple times in the segmentation.   * You may assume the dictionary does not contain duplicate words.   * Example 1:   *   * Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]   * Output: true   * Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.   * Example 2:   *   * Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]   * Output: true   * Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.   *              Note that you are allowed to reuse a dictionary word.   * Example 3:   *   * Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]   * Output: false   */  public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;    boolean[] dp = new boolean[s.length()+1];    HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();    dp[0] = true;    hs.addAll(wordDict);    for (int i=1; i&lt;=wordDict.size(); i++) &#123;      for (int j=0; j&lt;i; i++) &#123;        if (dp[j] &amp;&amp; hs.contains(s.substring(j+1, i)))          dp[i] = true;      &#125;    &#125;    return dp[s.length()];  &#125;  public static void mian(String[] args) &#123;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode WordBreakII","url":"/article/leetcode-WordBreakII/","content":"import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.List;public class WordBreakII &#123;  /**   * Given a non-empty string s and a dictionary wordDict containing a list of non-empty words,   * add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.   *   * Note:   *   * The same word in the dictionary may be reused multiple times in the segmentation.   * You may assume the dictionary does not contain duplicate words.   * Example 1:   *   * Input:   * s = &quot;catsanddog&quot;   * wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]   * Output:   * [   *   &quot;cats and dog&quot;,   *   &quot;cat sand dog&quot;   * ]   * Example 2:   *   * Input:   * s = &quot;pineapplepenapple&quot;   * wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]   * Output:   * [   *   &quot;pine apple pen apple&quot;,   *   &quot;pineapple pen apple&quot;,   *   &quot;pine applepen apple&quot;   * ]   * Explanation: Note that you are allowed to reuse a dictionary word.   * Example 3:   *   * Input:   * s = &quot;catsandog&quot;   * wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]   * Output:   * []   */  public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;    HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();    bfs( s, map, wordDict);    return map.get(s);  &#125;  public List&lt;String&gt; bfs(String s, HashMap&lt;String, List&lt;String&gt;&gt; map, List&lt;String&gt; wordDick) &#123;    if (map.containsKey(s)) &#123;      return map.get(s);    &#125;    List&lt;String&gt; t = new ArrayList&lt;&gt;();    if (s.isEmpty()) &#123;      t.add(&quot;&quot;);    &#125;    for (String word: wordDick) &#123;      if (s.startsWith(word)) &#123;        List&lt;String&gt; left = bfs( s.substring(word.length()), map, wordDick);        if (! left.isEmpty()) &#123;          for (String l: left) &#123;            t.add(word + (l.isEmpty()?&quot;&quot;:&quot; &quot;) + l);          &#125;        &#125;      &#125;    &#125;    map.put(s, t);    return t;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode #107 Binary Tree Level Order Traversal II","url":"/leetcode/leetcode-solution-107/","content":"107. Binary Tree Level Order Traversal II\n\nGiven a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n  3 / \\9  20  /  \\ 15   7\nreturn its bottom-up level order traversal as:\n[  [15,7],  [9,20],  [3]]\n\n树的遍历，深度优先算法\n加了一个小trick\n在每进入新的一层后，如果当前层大于result中的LinkedList数目，则为result创建一个新的LinkedList，创建的位置不是在最后，而是在最前面创建\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;();        if(root != null)            levelAdd(result, root, 0);        return result;    &#125;    public void levelAdd(List&lt;List&lt;Integer&gt;&gt; result,TreeNode root, int level)&#123;        if (result.size()&lt;=level)            result.add(0, new LinkedList&lt;Integer&gt;());        if(root.left == (null) &amp;&amp; root.right == (null))             ;        else if(root.right == null)              levelAdd(result, root.left, level+1);        else if(root.left ==null)              levelAdd(result, root.right, level+1);        else&#123;            levelAdd(result, root.left, level+1);            levelAdd(result, root.right, level+1);        &#125;        result.get(result.size()- level-1).add(root.val);    &#125;    &#125;\n\n上面版本有些累赘，可以参考下面的版本：\npublic class Solution &#123;        public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;            List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;();            levelMaker(wrapList, root, 0);            return wrapList;        &#125;                public void levelMaker(List&lt;List&lt;Integer&gt;&gt; list, TreeNode root, int level) &#123;            if(root == null) return;            if(level &gt;= list.size()) &#123;                list.add(0, new LinkedList&lt;Integer&gt;());            &#125;            levelMaker(list, root.left, level+1);            levelMaker(list, root.right, level+1);            list.get(list.size()-level-1).add(root.val);        &#125;    &#125;\n","categories":["leetcode"]},{"title":"leetcode solution 106. Construct Binary Tree from Inorder and Postorder Traversal","url":"/leetcode/leetcode-solution-106/","content":"Given inorder and postorder traversal of a tree, construct the binary tree.\nNote:\nYou may assume that duplicates do not exist in the tree.\nFor example, given\ninorder = [9,3,15,20,7]postorder = [9,15,7,20,3]\nReturn the following binary tree:\n  3 / \\9  20  /  \\ 15   7\n\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;        if(inorder.length == 0 || postorder.length == 0)            return null;        return build(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1);    &#125;    public TreeNode build(int[] inorder, int instart, int inend, int[] postorder, int poststart, int postend)&#123;        if(instart&gt;inend || poststart &gt; postend)            return null;        TreeNode root = new TreeNode(postorder[postend]);        int cur = -1;        for(int i=instart; i&lt;= inend; i++)&#123;            if(root.val == inorder[i])&#123;                cur = i;                break;            &#125;        &#125;        root.left = build(inorder, instart, cur-1, postorder, poststart, postend-(inend - cur)-1);        root.right = build(inorder, cur+1, inend, postorder, postend-(inend - cur), postend-1);        return root;    &#125;&#125;\n\n注意start end 的取值\n\n","categories":["leetcode"]},{"title":"leetocde solution 11 Container　with Most Water","url":"/leetcode/leetcode-solution-11/","content":"Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\nNote: You may not slant the container and n is at least 2.\n\nclass Solution &#123;    public int maxArea(int[] height) &#123;        int left = 0;        int right = height.length -1;        int maxArea = 0;        while(left &lt; right)&#123;            maxArea = Math.max(maxArea, (right - left)*Math.min(height[left], height[right]));            if(height[left]&gt;height[right])&#123;                right --;            &#125;            else                left ++;        &#125;        return maxArea;    &#125;&#125;\n\nof couse we can go through all the possible solution to find the largest area. However that might be time comsumming. In order to improve the time compacity, we use a smart way to find the largest eara.\nAs you can see, the width of the container is an important factor as the eara is width * min(h1, h2) . we set the first height and  the last height to be the start two lines. At every time, we move the lower lines to the next inner line as the width becomming shorter. In this way , we can filter out some lines which is not useful.\n\n","categories":["leetcode"]},{"title":"leetcode solution 105 Construct Binary Tree from Preorder and Inorder Traversal","url":"/leetcode/leetcode-solution-105/","content":"\nGiven preorder and inorder traversal of a tree, construct the binary tree.\nNote:\nYou may assume that duplicates do not exist in the tree.\nFor example, given\npreorder = [3,9,20,15,7]inorder = [9,3,15,20,7]\nReturn the following binary tree:\n  3 / \\9  20  /  \\ 15   7\n\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        if(preorder == null || inorder == null) return null;        if(preorder.length != inorder.length) return null;        return build(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);    &#125;    public TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd)&#123;        if(preStart &gt; preEnd || inStart &gt; inEnd)            return null;                TreeNode root = new TreeNode(preorder[preStart]);        int cur = -1;        for(int i=inStart; i&lt;=inEnd; i++)&#123;            if(inorder[i] == root.val)&#123;                cur = i;                break;            &#125;        &#125;                root.left = build(preorder, preStart+1, preStart+cur-inStart, inorder, inStart, cur-1);        root.right = build(preorder, preStart+cur-inStart+1, preEnd, inorder, cur+1, inEnd);        return root;    &#125;&#125;\n\n注意递归时两个数组的start 和 end的位置\n\n","categories":["leetcode"]},{"title":"leetcode solution 120 Triangle","url":"/leetcode/leetcode-solution-120/","content":"Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\nFor example, given the following triangle\n[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]\nThe minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).\nNote:\nBonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.\n\nclass Solution &#123;    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; trangle) &#123;        int[] dp = new int[trangle.size()+1];        for(int i = trangle.size()-1; i&gt;=0; i--)&#123;            for(int j=0; j&lt;=i; j++)&#123;                dp[j] = trangle.get(i).get(j) + Math.min(dp[j], dp[j+1]);            &#125;        &#125;        return dp[0];    &#125;&#125;\n\ndp[i] = min(dp[i+1] , dp[i]) + triangle[j][i]\n\n","categories":["leetcode"]},{"title":"leetcode #136 Single Number","url":"/leetcode/leetcode-solution-136/","content":"136 Single Number\n\nGiven an array of integers, every element appears twice except for one. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n数组中，题目给定了一定至少存在一个数，所以不考虑特殊输入的情况\n成对出现的数，要考虑使用^操作\nclass Solution &#123;    public int singleNumber(int[] nums) &#123;        for(int i=1; i&lt;nums.length; i++)&#123;            nums[0] = nums[0]^nums[i];        &#125;        return nums[0];    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode solution 125 Valid Palindromw","url":"/leetcode/leetcode-solution-125/","content":"Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\nFor example,\n&quot;A man, a plan, a canal: Panama&quot; is a palindrome.\n&quot;race a car&quot; is not a palindrome.\nNote:\nHave you consider that the string might be empty? This is a good question to ask during an interview.\nFor the purpose of this problem, we define empty string as valid palindrome.\n\nclass Solution &#123;    public boolean isPalindrome(String s) &#123;        int i = 0;        int j = s.length()-1;        while(i&lt;j) &#123;            if(!Character.isLetterOrDigit(s.charAt(i))) i++;            else if(!Character.isLetterOrDigit(s.charAt(j))) j--;            else if(Character.toUpperCase(s.charAt(i))!=Character.toUpperCase(s.charAt(j)))                return false;            else&#123;                i++;                j--;            &#125;        &#125;        return true;    &#125;&#125;\n\nplease pay attention to the code inside while loop, where if-else clause should be used to avoid OutOfIndex error.\n\n","categories":["leetcode"]},{"title":"leetcode solution Gas Station","url":"/leetcode/leetcode-solution-134/","content":"There are N gas stations along a circular route, where the amount of gas at station i is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\nReturn the starting gas station’s index if you can travel around the circuit once, otherwise return -1.\nNote:\nThe solution is guaranteed to be unique.\n\nclass Solution &#123;    public int canCompleteCircuit(int[] gas, int[] cost) &#123;        int currentGas = 0;        int balance = 0;        int start = 0;        for(int i=0; i&lt;gas.length; i++)&#123;            currentGas +=  gas[i] - cost[i];            if(currentGas &lt; 0)&#123;                balance += currentGas;                currentGas = 0;                start = i+1;            &#125;        &#125;        balance += currentGas;        if(balance &lt; 0)&#123;            return -1;        &#125;        else&#123;            return start;        &#125;    &#125;&#125;\n\n遍历一遍数组，currentGas 保存从start 点开始到当前第i-1个点剩下的gas.如果小于0，则说明从start 点开始能到达 i-1 但是不能到达i 。即说明start 到i 中的任意一个节点都不能作为起始点。\n\n可以利用反证法。假设start到i中存在一个点c，使得c能作为起始点，那么c一定能到达i，又由于start能到达c（因为start能到达i-1），start就能到达i，矛盾。\n\n\nbalance 中保存从0开始到最后一个起始点位置gas-cost之和。在循环外再加上一个currentGas，即可得到从0到n中，gas和和cost和。balance小于0，即说明不存在这样一个start point。\n\n","categories":["leetcode"]},{"title":"leetcode 14 Longest Common Prefix","url":"/leetcode/leetcode-solution-14/","content":"###14. Longest Common Prefix\n\nWrite a function to find the longest common prefix string amongst an array of strings.\n\n\n最初始的想法是，取第一个string出来，和之后的每一个进行比较，得到第一个String 和之后的String 的common Prefix substring的index，取最小值。在这种情况下，需要考虑一下几点\n\n当输入没有string时，return “”\n当输入只有一个string时，return string[0], 或者将第一个for语句从i=0开始。\n\n\n\nclass Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        int n = strs.length; // 获得总共的string数目        if ( n == 0)&#123; // 输入特例，当没有输入string时            return &quot;&quot;;        &#125;        if (n == 1)&#123; // 输入特例，当输入只有一个string时            return strs[0];        &#125;        int index = 0; // 记录每次strs[i]和strs[0]比较时的index        int min = Integer.MAX_VALUE;// 用于得到所有比较中最小的那个                        for (int i=1;i&lt;n;i++)&#123; // 从第二个string开始比较            for (int j=0; j&lt; Math.min(strs[0].length(),strs[i].length());j++)&#123; //考虑j的范围，应该小于第一个和当前比较的第i个的最短                if(strs[0].charAt(j) != strs[i].charAt(j))&#123;// 不等时，结束当前比较                    // index = j 不能放在这里，当比较下来没有进入这个if时，index得不到赋值。                    break;                &#125;                index ++;// 相等时，index++            &#125;            min = Math.min(min, index); // 保存当前比较得到的最小值            index = 0;// 记得将index归零        &#125;        return strs[0].substring(0, min);    &#125;&#125;\n\n记录下另外一种解法：\n\n先对strs进行排序，在这种情况下，只需要比较第一个String和最后一个string\n这种方法相对于上面的方法，要更快一些(11ms)上面的大概是15、16ms。\n\nclass Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        if (strs.length == 0)&#123; // 特例输入长度为0的情况            return &quot;&quot;;        &#125;        Arrays.sort(strs);// 对strs进行排序，小的在前，大的在后        String first = strs[0];        String last = strs[strs.length-1];        for(int i=0; i&lt;first.length(); i++)&#123;            if (first.charAt(i) != last.charAt(i))&#123;                return last.substring(0, i);            &#125;        &#125;        return first;// 如果完全一样，返回排序后的第一个就好    &#125;&#125;\n\n\nArrays.sort()实现的是并归排序，时间复杂度为O(nlogn)\n排序后是按生序排列的，因此最小的数在第一个，所以这里for循环只需要去i&lt;firs.length()\n注意： 对于String[] a，想要获得a中string的个数，使用a.length,其中想要获得第i个String，使用a[i],对于第i个String，想要获得其字符个数，使用a[i].length().\n\n","categories":["leetcode"]},{"title":"leetcode  148 Sort List","url":"/leetcode/leetcode-solution-148/","content":"Sort a linked list in O(n log n) time using constant space complexity.\n\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode sortList(ListNode head) &#123;        if(head == null || head.next == null)            return head;        ListNode slow = head;        ListNode fast = head;        ListNode mid = null;        while(fast!= null &amp;&amp; fast.next != null)&#123;            mid = slow;            slow = slow.next;            fast = fast.next.next;        &#125;        mid.next = null;                ListNode p = sortList(head);        ListNode q = sortList(slow);        ListNode ans = merge(p,q);        return ans;    &#125;        public ListNode merge(ListNode p, ListNode q)&#123;        ListNode t = new ListNode(0);        ListNode dummy = t;        while(p!=null &amp;&amp; q != null)&#123;            if(p.val &lt; q.val)&#123;                t.next = p;                p = p.next;            &#125;            else&#123;                t.next = q;                q = q.next;            &#125;            t = t.next;        &#125;        if(p!=null) t.next = p;        if(q!=null) t.next = q;                return dummy.next;    &#125;&#125;\n\n利用并归排序实现的。\n严格意义上来说，空间复杂度并不是O(1)， 因为递归调用时，栈中同样消耗了空间。\n\n","categories":["leetcode"]},{"title":"leetcode  150 Evaluate Reverse Polish Notation","url":"/leetcode/leetcode-solution-150/","content":"Evaluate the value of an arithmetic expression in Reverse Polish Notation.\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\nNote:\n\nDivision between two integers should truncate toward zero.\nThe given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.\n\nExample 1:\nInput: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]Output: 9Explanation: ((2 + 1) * 3) = 9\nExample 2:\nInput: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]Output: 6Explanation: (4 + (13 / 5)) = 6\nExample 3:\nInput: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]Output: 22Explanation:   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22\n\n\n使用栈能够简单的实现\n\nclass Solution &#123;    public int evalRPN(String[] tokens) &#123;        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();        for (String t: tokens)&#123;            if (&quot;+&quot;.equals(t))&#123;                int b = s.pop();                int a = s.pop();                int ans = a + b;                s.push(ans);            &#125;            else if (&quot;-&quot;.equals(t))&#123;                int b = s.pop();                int a = s.pop();                int ans = a - b;                s.push(ans);            &#125;            else if (&quot;*&quot;.equals(t))&#123;                int b = s.pop();                int a = s.pop();                int ans = a * b;                s.push(ans);            &#125;            else if (&quot;/&quot;.equals(t))&#123;                int b = s.pop();                int a = s.pop();                int ans = a / b;                s.push(ans);            &#125;            else&#123;                int num = Integer.parseInt(t);                s.push(num);            &#125;        &#125;        return s.peek();    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode  152 Maximun Product Subarray","url":"/leetcode/leetcode-solution-152/","content":"\nFind the contiguous subarray within an array (containing at least one number) which has the largest product.\nFor example, given the array [2,3,-2,4],\nthe contiguous subarray [2,3] has the largest product = 6.\n\nclass Solution &#123;    public int maxProduct(int[] nums) &#123;        int n = nums.length;        if(n == 0) return 0;        int max = nums[0];        int min = nums[0];        int ans = max;        for(int i=1; i&lt;n; i++)&#123;            int t = max;            max = Math.max(Math.max(max*nums[i], min*nums[i]), nums[i]);            min = Math.min(Math.min(t*nums[i], min*nums[i]), nums[i]);            ans = Math.max(max, ans);        &#125;        return ans;            &#125;&#125;\n\n遍历一遍数组，设定一个max和min，保存当前存到的最大值和最小值，每次更新最大值。\n\n","categories":["leetcode"]},{"title":"leetcode 152&153 Find Minimum in Rotated Sorted Array","url":"/leetcode/leetcode-solution-153/","content":"Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\nFind the minimum element.\nYou may assume no duplicate exists in the array.\n\nclass Solution &#123;    public int findMin(int[] nums) &#123;        int start = 0;        int end = nums.length-1;        while(start &lt; end)&#123;            int mid = start + ((end - start)&gt;&gt;1);            if(nums[mid] &gt; nums[end])&#123;                start = mid + 1;            &#125;            else                end = mid;        &#125;        return nums[start];    &#125;&#125;\n\n每次和最后一个元素比较。\n\n1 2 3  -&gt; s 1, e 3, m 2 -&gt; s 1, e 1\n3 2 1  -&gt; s 3, e 1, m 2 -&gt; s 2, e 1 -&gt; s 2 e 1 m 2 -&gt; s 1 e 1\n\n\n\n\nwhat if there is duplicate items,\nclass Solution &#123;    public int findMin(int[] nums) &#123;        int start = 0;        int end = nums.length-1;        while(start &lt; end)&#123;            int mid = start + ((end - start)&gt;&gt;1);            if(nums[mid] &gt; nums[end])&#123;                start = mid + 1;            &#125;            else if(nums[mid] &lt; nums[end])                end = mid;            else                end --;        &#125;        return nums[start];    &#125;&#125;\n\nexample: 3, 3, 1, 3\n\n当出现这种情况时，mid == end, 需要end–\n\n\n\n","categories":["leetcode"]},{"title":"leetcode solution 16 3Sum closest","url":"/leetcode/leetcode-solution-16/","content":"Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\nFor example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\nclass Solution &#123;    public int threeSumClosest(int[] nums, int target) &#123;        Arrays.sort(nums);        int ans = nums[0] +nums[1] + nums[nums.length-1];                for(int i = 0; i&lt;nums.length-2; i++)&#123;            int first = i+1;            int last = nums.length - 1;            while(first &lt; last)&#123;                if(Math.abs(nums[first] + nums[last] + nums[i] - target) &lt; Math.abs(target- ans))&#123;                    ans = nums[first] + nums[last] + nums[i];                &#125;                if(nums[first] + nums[last] + nums[i] &gt; target)&#123;                    last --;                &#125;                else&#123;                    first ++;                &#125;                            &#125;        &#125;        return ans;            &#125;&#125;\n\nusing three pointer i first last , each time compare sum(i, first, last). if sum &gt; target, moving first to the next, otherwise, moving last to the left next one.\nEach time, we keep the closest sum to ans\n\n","categories":["leetcode"]},{"title":"leetcode  160 Intersection of Two Linked Lists","url":"/leetcode/leetcode-solution-160/","content":"Write a program to find the node at which the intersection of two singly linked lists begins.\nFor example, the following two linked lists:\nA:          a1 → a2                   ↘                     c1 → c2 → c3                   ↗            B:     b1 → b2 → b3\nbegin to intersect at node c1.\nNotes:\n\nIf the two linked lists have no intersection at all, return null.\nThe linked lists must retain their original structure after the function returns.\nYou may assume there are no cycles anywhere in the entire linked structure.\nYour code should preferably run in O(n) time and use only O(1) memory.\n\n\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; *         val = x; *         next = null; *     &#125; * &#125; */public class Solution &#123;    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;        ListNode a = headA;        ListNode b = headB;        int lengthA = 0;        int lengthB = 0;        int start = 0;        while(a!=null)&#123;            a = a.next;            lengthA ++;        &#125;        while(b!=null)&#123;            b = b.next;            lengthB ++;        &#125;        if(lengthA &gt; lengthB)&#123;            b = headB;            a = headA;            int i = 0;            while(i &lt; lengthA - lengthB)&#123;                a = a.next;                i ++;            &#125;        &#125;        if(lengthB &gt;= lengthA)&#123;            a = headA;            b = headB;            int i = 0;            while(i &lt; lengthB - lengthA)&#123;                b = b.next;                i++;            &#125;        &#125;        while(a != null &amp;&amp; b != null)&#123;            if(a.val != b.val)&#123;                a = a.next;                b = b.next;            &#125;            else&#123;                return a;            &#125;        &#125;        return null;            &#125;&#125;\n\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    //boundary check    if(headA == null || headB == null) return null;        ListNode a = headA;    ListNode b = headB;        //if a &amp; b have different len, then we will stop the loop after second iteration    while( a != b)&#123;    \t//for the end of first iteration, we just reset the pointer to the head of another linkedlist        a = a == null? headB : a.next;        b = b == null? headA : b.next;        &#125;        return a;&#125;\n","categories":["leetcode"]},{"title":"leetcode  162 Find Peak Element","url":"/leetcode/leetcode-solution-162/","content":"A peak element is an element that is greater than its neighbors.\nGiven an input array where num[i] ≠ num[i+1], find a peak element and return its index.\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\nYou may imagine that num[-1] = num[n] = -∞.\nFor example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.\n\nclass Solution &#123;    public int findPeakElement(int[] nums) &#123;        int n = nums.length;        if(n == 0) return -1;        int start = 0;        int end = n-1;        while(start &lt;= end)&#123;            int mid = start + ((end - start)&gt;&gt;1);            if(mid-1&gt;=0 &amp;&amp; mid+1 &lt;=n-1 &amp;&amp; nums[mid-1]&lt;nums[mid] &amp;&amp; nums[mid+1]&lt;nums[mid])                return mid;            else if(mid-1&gt;=0 &amp;&amp; nums[mid-1]&gt;nums[mid])                end = mid-1;            else if(mid+1&lt;=n-1 &amp;&amp; nums[mid+1]&gt;nums[mid])                start = mid+1;            else                return mid;        &#125;        return -1;    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode 167 Two Sum II - Input array is sorted","url":"/leetcode/leetcode-solution-167/","content":"\n167. Two Sum II - Input array is sorted\n\nGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\nYou may assume that each input would have exactly one solution and you may not use the same element twice.\nInput: numbers={2, 7, 11, 15}, target=9\nOutput: index1=1, index2=2\n\n第一想到的方法是之前two sum 1中的方法，使用一个hashmap\nclass Solution &#123;    public int[] twoSum(int[] numbers, int target) &#123;        HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;();        int[] result = new int[2];        for(int i=0;i&lt;numbers.length;i++)&#123;            if(m.containsKey(target-numbers[i]))&#123;                result[0] = m.get(target-numbers[i])+1;                result[1] = i+1;            &#125;            else&#123;                m.put(numbers[i], i);            &#125;        &#125;        return result;    &#125;&#125;\n\n但是这里考虑到输入已经排序，而且一定存在一个解，那么可以直接比较：\nclass Solution &#123;    public int[] twoSum(int[] numbers, int target) &#123;        int lo = 0;        int hi = numbers.length - 1;        int[] result = new int[2];        while (lo &lt; hi)&#123;            if (numbers[lo] + numbers[hi] == target)&#123;                result[0] = lo+1;                result[1] = hi+1;                break;            &#125;            else if(numbers[lo] + numbers[hi] &lt; target)&#123;                lo++;            &#125;            else&#123;                hi--;            &#125;        &#125;        return result;    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode 168 Excel Sheet Column Title","url":"/leetcode/leetcode-solution-168/","content":"Given a positive integer, return its corresponding column title as appear in an Excel sheet.\nFor example:\n1 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB \n\nclass Solution &#123;    public String convertToTitle(int n) &#123;        String result = &quot;&quot;;        while(n&gt;0)&#123;            result = (char) (&#x27;A&#x27; + (n-1)%26 ) + result;            n = (n-1)/26;        &#125;        return result;    &#125;&#125;\n\nConsider it as a digit transform problem.\nNotice that the first char is A which corresponse to number 0, so there should be n-1.\n\n","categories":["leetcode"]},{"title":"leetcode  17 Letter Combinations of a Phone Number","url":"/leetcode/leetcode-solution-17/","content":"Given a digit string, return all possible letter combinations that the number could represent.\nA mapping of digit to letters (just like on the telephone buttons) is given below.\n\nInput:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].\nNote:\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.\n\nclass Solution &#123;    public List&lt;String&gt; letterCombinations(String digits) &#123;        LinkedList&lt;String&gt; answer = new LinkedList&lt;String&gt;();         if (digits.isEmpty()) return answer;        String[] mapping = new String[]&#123;&quot; &quot;, &quot; &quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;        answer.add(&quot;&quot;);        for(int i=0; i&lt;digits.length(); i++)&#123;            String s = mapping[Character.getNumericValue(digits.charAt(i))];            while(answer.peek().length() &lt; i+1)&#123;                String t = answer.remove();                for(char c: s.toCharArray())&#123;                    answer.add(t+c);                &#125;            &#125;        &#125;        return answer;    &#125;&#125;\n\nUsing a queue, every time fetch the fisrt queue and find if it’s length equals to the current processing number. if it’s small, adding the distinct characters of the current processing number’s coresponding Letters.\n\n","categories":["leetcode"]},{"title":"leetcode  176 Next Permutation","url":"/leetcode/leetcode-solution-176/","content":"Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\nThe replacement must be in-place, do not allocate extra memory.\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1\n\nclass Solution &#123;    public void nextPermutation(int[] nums) &#123;        int i = nums.length-1;        if(i&lt;1) return ;         while( i &gt;= 1 &amp;&amp; nums[i-1] &gt;= nums[i] )&#123;            i--;        &#125;        if(i &gt;= 1 &amp;&amp; nums[i-1] &lt; nums[i])&#123;            int j = i+1;            for( ; j&lt;nums.length; j++)&#123;                if(nums[j] &lt;= nums[i-1])                    break;            &#125;            swap(nums, i-1, j-1);            reverse(nums, i, nums.length-1);        &#125;        else&#123;            reverse(nums,i,nums.length-1);        &#125;    &#125;    public void swap(int[] nums, int a, int b)&#123;        int t = nums[a];        nums[a] = nums[b];        nums[b] = t;    &#125;    public void reverse(int[] nums, int a, int b)&#123;        while(a&lt;=b)&#123;            swap(nums, a, b);            a++;            b--;        &#125;            &#125;    &#125;\n\n\nThe main idea is to search from tail to head to find nums[i-1] &lt; nums[i]\n\n\nSwap i-1 with j, where nums[j] is the first number which is larger than nums[i-1]\n\n\nthe Reverse i~n;\n\n\n4 5 9 7 2 1\n\nswap 5 with 7 --&gt; 4 7 9 5 2 1\nreverse 9 5 2 1 --&gt; 4 7 1 2 5 9\n\n\n\n","categories":["leetcode"]},{"title":"leetcode  18 4Sum","url":"/leetcode/leetcode-solution-18/","content":"\nGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\nFor example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[  [-1,  0, 0, 1],  [-2, -1, 1, 2],  [-2,  0, 0, 2]]\n\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        if(nums.length &lt; 4) return ans;        Arrays.sort(nums);        for(int i=0; i&lt;nums.length-3; i++)&#123;            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1])                continue;            for(int j = i+1; j&lt;nums.length-2; j++)&#123;                int start = j+1;                int end = nums.length-1;                if(nums[j] == nums[j-1] &amp;&amp; j&gt;i+1)                  continue;                     while(start &lt; end)&#123;                       if(nums[i] +nums[j] +nums[start] + nums[end] &lt; target)&#123;                           start ++;                       &#125;                       else if(nums[i] +nums[j] +nums[start] + nums[end] &gt; target)&#123;                           end --;                       &#125;                       else&#123;                           List&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;();                           t.add(nums[i]);                           t.add(nums[j]);                           t.add(nums[start]);                           t.add(nums[end]);                           ans.add(t);                           while(nums[start] == nums[start+1] &amp;&amp; start+1 &lt; end) start ++;                           while(nums[end] == nums[end-1]&amp;&amp; start+1 &lt; end) end --;                           start ++;                           end --;                       &#125;                   &#125;            &#125;        &#125;                return ans;    &#125;&#125;\n\nGenerally, we can using 3sum to deal 4sum, 2sum to deal 3sum.\nusing 4 pointers to judge\nThere are some improvements which to avoid some redundent calculation.\nPay attention to the clause used to avoid duplicate answers.\n\n","categories":["leetcode"]},{"title":"leetcode 189 Rotate Array","url":"/leetcode/leetcode-solution-189/","content":"189. Rotate Array\n\nRotate an array of n elements to the right by k steps.\nFor example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].\n\nclass Solution &#123;    public void rotate(int[] nums, int k) &#123;        if(k&lt;=0)            return ;        k = k%nums.length;        reverse(nums, 0, nums.length-k-1);        reverse(nums, nums.length-k, nums.length-1);        reverse(nums, 0, nums.length-1);    &#125;    public void reverse(int[] nums, int i, int j)&#123;        while(i&lt;j)&#123;            int temp = nums[i];            nums[i] = nums[j];            nums[j] = temp;            i++;            j--;        &#125;    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode  19 Remove n-th Node from End of List","url":"/leetcode/leetcode-solution-19/","content":"Given a linked list, remove the nth node from the end of list and return its head.\nFor example,\nGiven linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.\nNote:\nGiven n will always be valid.\nTry to do this in one pass.\n\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        ListNode slow = head;        ListNode fast = head;        int i = 0;        while(i!=n)&#123;            fast = fast.next;            i++;        &#125;        if(fast == null)&#123;            return slow.next;        &#125;        while(fast.next != null)&#123;            fast = fast.next;            slow = slow.next;        &#125;        slow.next = slow.next.next;        return head;    &#125;    &#125;\n\nUsing two points, both starts with pointing to the first node.\nMoving the fast pointer n times, so that fast is n nodes ahead the slow pointer\nMoving the two pointers in the same time untile fast reaches the end of the linked list\nNotice that when there is only one node in the list and removing the only element. This is an special case which need to be examed.\n\n","categories":["leetcode"]},{"title":"leetcode solution 190 Reverse Bits","url":"/leetcode/leetcode-solution-190/","content":"Reverse bits of a given 32 bits unsigned integer.\nFor example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).\n\npublic class Solution &#123;    // you need treat n as an unsigned value    public int reverseBits(int n) &#123;        int result = 0;        for(int i=0; i&lt;32; i++)&#123;            result &lt;&lt;= 1;            result += n&amp;1;            n &gt;&gt;= 1;        &#125;        return result;    &#125;&#125;\nalse\n\n","categories":["leetcode"]},{"title":"leetcode 205 Isomorphic String","url":"/leetcode/leetcode-solution-205/","content":"Given two strings s and t, determine if they are isomorphic.\nTwo strings are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\nFor example,\nGiven &quot;egg&quot;, &quot;add&quot;, return true.\nGiven &quot;foo&quot;, &quot;bar&quot;, return false.\nGiven &quot;paper&quot;, &quot;title&quot;, return true.\nNote:\nYou may assume both s and t have the same length.\n\n\n首先想到的是利用HashMap，保存分别保存当前的字符和对应的下标。\n如果s[i]和t[i]都已经存在与各自的hashmap中，判断其value是否一致，及第一次出现的下标是否一致\n还要判断，当si、ti都不存在与各自的hashmap中时，将其保存到各自的hashMap中\n否在，si存在而ti不存在，或者si不存在ti存在，返回false\n返回true\n\nclass Solution &#123;    public boolean isIsomorphic(String s, String t) &#123;        HashMap&lt;Character, Integer&gt; m1 = new HashMap&lt;Character, Integer&gt;();        HashMap&lt;Character, Integer&gt; m2 = new HashMap&lt;Character, Integer&gt;();        for(int i=0;i&lt;s.length();i++)&#123;            if(m1.containsKey(s.charAt(i)) &amp;&amp; m2.containsKey(t.charAt(i)))&#123;                if(m1.get(s.charAt(i)) != m2.get(t.charAt(i)))&#123;                    return false;                &#125;            &#125;            else if(!m1.containsKey(s.charAt(i)) &amp;&amp; !m2.containsKey(t.charAt(i)))            &#123;                m1.put(s.charAt(i),i);                m2.put(t.charAt(i),i);            &#125;            else&#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;\n\n这里用到了两个hashmap，但是可以优化为只用一个hashmap\nclass Solution &#123;    public boolean isIsomorphic(String s, String t) &#123;        HashMap&lt;Character, Character&gt; m = new HashMap&lt;Character, Character&gt;();        for(int i=0; i&lt;s.length(); i++)&#123;            if(m.containsKey(s.charAt(i)))&#123;                if(m.get(s.charAt(i))!= t.charAt(i))&#123;                    return false;                &#125;            &#125;            else if (m.containsValue(t.charAt(i)))&#123;                return false;            &#125;            m.put(s.charAt(i), t.charAt(i));        &#125;        return true;    &#125;&#125;\n但是这个的时间效率更低\n\n还有一种设置两个256长度的int[]数组。\n初始化为0\nclass Solution &#123;    public boolean isIsomorphic(String s, String t) &#123;        int[] m1 = new int[256];        int[] m2 = new int[256];        for(int i=0;i&lt;s.length(); i++)&#123;            if(m1[s.charAt(i)] != m2[t.charAt(i)])&#123;                return false;            &#125;            else&#123;                m1[s.charAt(i)] = i+1;// 注意这里是i+1                m2[t.charAt(i)] = i+1;                &#125;                    &#125;        return true;    &#125;&#125;\n之所以是i+1，是存在这种情况\n如果是i：\ni=0时，if不成立，\n”a b“\tm1[‘a’] = 0\n“a a”\tm2[‘a’] = 0\ni=1时， if不成立，\n​\t\tm1[‘a’] = 1\n​\t\tm2[‘a’] = 1\nreturn true;\n","categories":["leetcode"]},{"title":"leetcode  209 Minimum Size Subarray Sum","url":"/leetcode/leetcode-solution-209/","content":"Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.\nFor example, given the array [2,3,1,2,4,3] and s = 7,\nthe subarray [4,3] has the minimal length under the problem constraint.\n\nclass Solution &#123;    public int minSubArrayLen(int s, int[] nums) &#123;        int i=0;        int j=0;        int n = nums.length-1;        int sum = 0;        int ans = Integer.MAX_VALUE;        while(i&lt;=n &amp;&amp; j&lt;=n &amp;&amp; i&lt;=j)&#123;            if(sum &lt; s)&#123;                sum += nums[j];                j++;            &#125;            while(sum &gt;=s)&#123;                ans = Math.min(j-i, ans);                sum -= nums[i];                i++;            &#125;        &#125;        return ans == Integer.MAX_VALUE? 0: ans;    &#125;&#125;\n\n用两个指针一个执行最前面，一个指向最后面，sum之和大于s时，i++，且记录当前的长度（j-i）。否则 j++\n时间复杂度为O(n)\n\n\nclass Solution &#123;    public int minSubArrayLen(int s, int[] nums) &#123;        int end = nums.length;        int start = 0;        int ans = 0;        while(start &lt;= end)&#123;            int mid = start + ((end - start)&gt;&gt;1);            if(findWindow(s, nums, mid))&#123;                ans = mid;                end = mid-1;                System.out.print(ans);                            &#125;            else&#123;                start = mid + 1;            &#125;        &#125;        return ans;    &#125;    public boolean findWindow(int s, int[] nums, int size)&#123;                for(int i=0; i&lt;nums.length-(size-1); i++ )&#123;            int j=i;            int sum = 0;            while(j&lt;=i+size-1)&#123;                sum += nums[j];                j++;            &#125;            if(sum &gt;= s)                return true;        &#125;        return false;    &#125;&#125;\n\n用二分查找的方式来计算求size。\n\n","categories":["leetcode"]},{"title":"leetcode  216 Combination Sum III","url":"/leetcode/leetcode-solution-216-Combination-Sum-III/","content":"Find all possible combinations of *k* numbers that add up to a number *n*, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.\n*Example 1:*\nInput: *k* = 3, *n* = 7\nOutput:\n[[1,2,4]]\n*Example 2:*\nInput: *k* = 3, *n* = 9\nOutput:\n[[1,2,6], [1,3,5], [2,3,4]]\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if(k == 0 || n == 0) return ans;        backtrace(ans, new ArrayList&lt;Integer&gt;(), k, n, 1);        return ans;    &#125;    public void backtrace(List&lt;List&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; t, int k, int n, int start)&#123;        if(t.size() == k &amp;&amp; n == 0)&#123;            ans.add(new ArrayList&lt;Integer&gt;(t));            return ;        &#125;        for(int j = start; j&lt;=9; j++)&#123;            if(j &gt; n)                continue;            t.add(j);            backtrace(ans, t, k, n-j, j+1);            t.remove(t.size()-1);        &#125;    &#125;&#125;\n\n注意只能用1-9里面的数字。\n注意backtrace的条件里面，j+1，start+1 的区别\n\nj+1没有重复数字\nstart+1会有重复数字\n\n\n\n","categories":["leetcode"]},{"title":"leetcode 219 Contains Duplicate II","url":"/leetcode/leetcode-solution-219/","content":"219. Contains Duplicate II\n\nGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.\n\n\n\n\n最intuitive的方法是一个二重循环来判断，但这样势必时间复杂很高，导致超时：\nclass Solution &#123;    public boolean containsNearbyDuplicate(int[] nums, int k) &#123;        for(int i=1; i&lt;nums.length; i++)&#123;            for(int j=Math.max(i-k,0); j&lt;i;j++)&#123;                if(nums[i] == nums[j])&#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;&#125;\n\n\n\n\n使用之前返回两个相等的数的下标那种方法：\n利用一个HashMap保存当前数和索引：\nclass Solution &#123;    public boolean containsNearbyDuplicate(int[] nums, int k) &#123;        HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;();        for(int i=0; i&lt;nums.length; i++)&#123;            if(m.containsKey(nums[i]))&#123;                if(i-m.get(nums[i])&lt;=k)&#123;                    return true;                &#125;            &#125;            m.put(nums[i], i);        &#125;        return false;    &#125;&#125;\n\n\n\n\n使用一个set，利用set.add()来判断当前加进set中的数字是否已经存在于set中。\nclass Solution &#123;    public boolean containsNearbyDuplicate(int[] nums, int k) &#123;        HashSet&lt;Integer&gt; s = new HashSet&lt;Integer&gt;();        for(int i=0;i&lt;nums.length; i++)&#123;            if(i&gt;k)&#123;                s.remove(nums[i-k-1]);            &#125;            if(!s.add(nums[i]))&#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;\n注意边界条件的设定。\n","categories":["leetcode"]},{"title":"leetcode  22 Generat Parentheses","url":"/leetcode/leetcode-solution-22/","content":"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nFor example, given n = 3, a solution set is:\n[  &quot;((()))&quot;,  &quot;(()())&quot;,  &quot;(())()&quot;,  &quot;()(())&quot;,  &quot;()()()&quot;]\n\nclass Solution &#123;    public List&lt;String&gt; generateParenthesis(int n) &#123;        List&lt;String&gt; ans = new ArrayList&lt;String&gt;();        backtrace(0,0,&quot;&quot;,n,ans);        return ans;    &#125;    public void backtrace(int left, int right, String s, int n, List&lt;String&gt; ans)&#123;        if(s.length() == 2*n)&#123;            ans.add(s);            return ;        &#125;        if(left &lt; n)            backtrace(left+1, right, s+&quot;(&quot;, n, ans);        if(right &lt; left)            backtrace(left, right+1, s+&quot;)&quot;, n, ans);    &#125;&#125;\n\nUsing backtrace method.\nleft means the number of ( , right means the number of ) . Each step, if left &lt; n , this means that we should add ( to current string s , if right &lt; left , this means that we should add ) to current string s.\n\n","categories":["leetcode"]},{"title":"leetcode  228. Summary Ranges","url":"/leetcode/leetcode-solution-228-Summary-Ranges/","content":"Given a sorted integer array without duplicates, return the summary of its ranges.\nExample 1:\nInput: [0,1,2,4,5,7]Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]\nExample 2:\nInput: [0,2,3,4,6,8,9]Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]\n\nclass Solution &#123;    public List&lt;String&gt; summaryRanges(int[] nums) &#123;        List&lt;String&gt; ans = new ArrayList&lt;String&gt;();        if(nums.length == 0) return ans;        StringBuilder ab = new StringBuilder();        boolean isStart = true;        int i=0;        int j=1;        if(nums.length == 1)&#123;            ab.append(nums[0]);            ans.add(ab.toString());            ab = null;            return ans;        &#125;        while(i&lt;nums.length &amp;&amp; j&lt;nums.length)&#123;            if(nums[j]!=nums[i]+1)&#123;                ab.append(nums[i]);                ans.add(ab.toString());                ab.delete(0, ab.length());                i=j;                j=j+1;                            &#125;            else&#123;                while(j&lt;nums.length &amp;&amp; nums[j]==nums[j-1]+1)&#123;                    j++;                &#125;                if(j &gt; nums.length-1)&#123;                    ab.append(nums[i] + &quot;-&gt;&quot; + nums[j-1]);                    ans.add(ab.toString());                    ab.delete(0, ab.length());                    i = j+1;                    j = j+2;                &#125;                else&#123;                    ab.append(nums[i] + &quot;-&gt;&quot; + nums[j-1]);                    ans.add(ab.toString());                    ab.delete(0, ab.length());                    i = j;                    j = j+1;                &#125;                            &#125;                    &#125;        if(j == nums.length-1)&#123;            ab.append(nums[j]);            ans.add(ab.toString());        &#125;        if(i == nums.length-1)&#123;            ab.append(nums[i]);            ans.add(ab.toString());        &#125;        return ans;    &#125;&#125;\n\nList&lt;String&gt; list=new ArrayList();\tif(nums.length==1)&#123;\t\tlist.add(nums[0]+&quot;&quot;);\t\treturn list;\t&#125;    for(int i=0;i&lt;nums.length;i++)&#123;    \tint a=nums[i];    \twhile(i+1&lt;nums.length&amp;&amp;(nums[i+1]-nums[i])==1)&#123;    \t\ti++;    \t&#125;    \tif(a!=nums[i])&#123;    \t\tlist.add(a+&quot;-&gt;&quot;+nums[i]);    \t&#125;else&#123;    \t\tlist.add(a+&quot;&quot;);    \t&#125;    &#125;    return list;\n","categories":["leetcode"]},{"title":"leetcode  221 Maximal Square","url":"/leetcode/leetcode-solution-221-Maximal-Square/","content":"Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.\nFor example, given the following matrix:\n1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0\nReturn 4.\n\nclass Solution &#123;    public int maximalSquare(char[][] matrix) &#123;        if(matrix.length == 0) return 0;        if(matrix[0].length == 0) return 0;        int m = matrix.length;        int n = matrix[0].length;                int[][] dp = new int[m+1][n+1];        int size = 0;        for(int i=1; i&lt;=m; i++)&#123;            for(int j=1; j&lt;=n; j++)&#123;                if(matrix[i-1][j-1] == &#x27;1&#x27;)&#123;                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;                    size = Math.max(size, dp[i][j]);                &#125;            &#125;        &#125;        return size*size;    &#125;&#125;\n\ndp[i][j] = min(dp[i-1][j-1], dp[j-1][i], dp[i][j-1]) + 1  if(matrix[i-1][j-1] == 1)\n这里dp记录的是边长，只有当前点的左边，上边和左上角一般大时，当前点的值才加一\n\n\n\n\n1  (dp = 1)\n1 (dp = 1)\n0 (dp = 0)\n\n\n\n\n0  (dp = 0)\n1 (dp = 1)\n1 (dp = 1)\n\n\n0  (dp = 0)\n1 (dp = 1)\n1 (dp = 2)\n\n\n\n\n要注意的是，如果最后一个位置的值为0的话，dp = 0 ，因此需要一个变量来保存整个过程中的最大值\n\n","categories":["leetcode"]},{"title":"leetcode 234 Palindrome Linked List","url":"/leetcode/leetcode-solution-234/","content":"Given a singly linked list, determine if it is a palindrome.\nFollow up:\nCould you do it in O(n) time and O(1) space?\n\n\nusing two pointers:\n\nA slow pointer with step length equals One\nA fast pointer with step length eauqls Two\n\n\nWe can get the middle elements pointed by slow when the total number of the array is odd.\nSlow pointer points at the larger one when the array is at a length of even.\nWe can implements an function which reverses the linked list, So we can get the reverse list over [slow, -1].\ncompare head with slow step by step until slow points to null.\n\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public boolean isPalindrome(ListNode head) &#123;        ListNode fast = head;        ListNode slow = head;        while(fast != null &amp;&amp; fast.next != null)&#123;            fast = fast.next.next;            slow = slow.next;        &#125;        slow = reverse(slow);        while(slow!=null)&#123;            if(slow.val != head.val)&#123;                return false;            &#125;            head = head.next;            slow = slow.next;        &#125;        return true;    &#125;    public ListNode reverse(ListNode head)&#123;        ListNode prev = null;        while(head != null)&#123;            ListNode next = head.next;            head.next = prev;            prev = head;            head = next;        &#125;        return prev;    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode 2 Add Two Numbers","url":"/article/leetcode-addTwoNumbers/","content":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse orderand each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\nInput: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.\nimport utils.ListNode;public class addTwoNumbers &#123;  public ListNode addTwoNumbers(ListNode a, ListNode b) &#123;    ListNode ans = new ListNode(0);    ListNode head = ans;    int carry = 0;    while (a.next!= null &amp;&amp; b.next != null) &#123;      int t = (a.val + b.val + carry)%10;      carry = t/10;      ListNode tt = new ListNode(t);      head.next = tt;      head = head.next;    &#125;    while (a.next != null) &#123;      int t = (a.val + carry)%10;      carry = t/10;      ListNode tt = new ListNode(t);      head.next = tt;      head = head.next;    &#125;    while (b.next != null) &#123;      int t = (b.val + carry)%10;      carry = t/10;      ListNode tt = new ListNode(t);      head.next = tt;      head = head.next;    &#125;    if (carry != 0) &#123;      ListNode t = new ListNode(carry);      head.next = t;    &#125;    return ans.next;  &#125;&#125;\n\n445. Add Two Numbers II\nYou are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up:\nWhat if you cannot modify the input lists? In other words, reversing the lists is not allowed.\nExample:\nInput: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7\n\n\n\n最直接的方法是利用reverse，先转换为上述的问题，得到结果后再reverse回来\n# Definition for singly-linked list.# class ListNode(object):#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution(object):    def addTwoNumbers(self, l1, l2):        &quot;&quot;&quot;        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        &quot;&quot;&quot;        a = self.reverse(l1)        b = self.reverse(l2)                dump = ListNode(0)        p = dump        carry = 0        while a and b:            t = (a.val + b.val + carry) % 10            cur = ListNode(t)            p.next = cur            p = p.next            carry = (a.val + b.val + carry)/10            a = a.next            b = b.next        while a:            t = (a.val + carry) % 10            cur = ListNode(t)            carry = (a.val + carry)/10            p.next = cur            p = p.next            a = a.next        while b:            t = (b.val + carry) % 10            cur = ListNode(t)            carry = (b.val + carry)/10            p.next = cur            p = p.next            b = b.next        if carry:            cur = ListNode(carry)            p.next = cur            p = p.next        return self.reverse(dump.next)                        def reverse(self, head):        pre = None        p = head        while p is not None:            q = p.next            p.next = pre            pre = p            p = q        return pre\n\n\n但是题目要求不用reverse，这样一来，直接得出l1和l2对应的整数，将其相加后变成列表\n\n\nclass Solution(object):    def addTwoNumbers(self, l1, l2):        &quot;&quot;&quot;        :type l1: ListNode        :type l2: ListNode        :rtype: ListNode        &quot;&quot;&quot;        a = self.getNumber(l1)        b = self.getNumber(l2)        c = a + b        return self.getLinkList(c)                def getNumber(self, l):        val = 0        while l:            val = val*10 + l.val            l = l.next        return val        def getLinkList(self, val):        if val == 0:            return ListNode(0)        dump = ListNode(0)        while val:            y = val % 10            val = val / 10            # dump.next, dump.next.next = ListNode(y), dump.next            t = dump.next            dump.next = ListNode(y)            dump.next.next = t        return dump.next\n","tags":["leetcode"]},{"title":"leetcode 268 Missing Number","url":"/leetcode/leetcode-solution-268/","content":"\n268. Missing Number\nGiven an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\nExample 1\nInput: [3,0,1]Output: 2\nExample 2\nInput: [9,6,4,2,3,5,7,0,1]Output: 8\n\n\n\nThe sum of [0, 1, 2,…,n] should be n*(n+1)/2 , so the missing one could be calculated by n*(n-1)/2 minus the sum of array which exclude the missing array.\nclass Solution &#123;    public int missingNumber(int[] nums) &#123;        int n = nums.length;        int sum = 0;        for(int i:nums)&#123;            sum += i;        &#125;        return n*(n+1)/2 - sum;    &#125;&#125;\n\n\n\nIn the disscus area, there is an other solution using xor and ~ operation.\npublic int missingNumber(int[] nums) &#123;    int xor = 0, i = 0;\tfor (i = 0; i &lt; nums.length; i++) &#123;\t\txor = xor ^ i ^ nums[i];\t&#125;\treturn xor ^ i;&#125;\n\nNotice that a xor b xor b = a\n\nfor example, let nums = [0,1,3]\nxor = 0 xor 1 xor 3 xor 0 xor 1xor2 xor 3 = 2.\n\n\nNotice that i should be initialized outside the for loop cause it will be used at the last return cause, outside the for loop.\n\n","categories":["leetcode"]},{"title":"leetcode  238 Product of Array Except Self","url":"/leetcode/leetcode-solution-238-Product-of-Array-Except-Self/","content":"Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\nSolve it without division and in O(n).\nFor example, given [1,2,3,4], return [24,12,8,6].\nFollow up:\nCould you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)\n\nclass Solution &#123;    public int[] productExceptSelf(int[] nums) &#123;                int left = 1;        int[] ans = new int[nums.length];        ans[0] = 1;        for(int i=1; i&lt;nums.length; i++)&#123;            ans[i] = left * nums[i-1];            left = ans[i];        &#125;        int right = 1;        for(int i=nums.length-1; i&gt;=0; i--)&#123;            ans[i] *= right;            right *= nums[i];        &#125;        return ans;    &#125;&#125;\n\n\nleft从左开始，保存当前一个数左边的数的乘积\n\n\nright从右边开始，保存当前一个数右边的数的乘积\n\n\n连着合体即可\n​\t\t1\t\t2\t\t3\t\t4\nleft\t\t\t\t1\t\t1*2\t\t1*2*3\nright\t4*3*2\t4*3\t\t4\n\n\n注意ans[0]需要初始化为1，不然ans[0]将会等于0；\n\n\n","categories":["leetcode"]},{"title":"leetcode  257 Binary Tree Paths","url":"/leetcode/leetcode-solution-257/","content":"Given a binary tree, return all root-to-leaf paths.\nFor example, given the following binary tree:\n   1 /   \\2     3 \\  5\nAll root-to-leaf paths are:\n[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]\n\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;        List&lt;String&gt; result = new ArrayList&lt;String&gt;();        binaryTreePathsFinder(root, &quot;&quot;, result);        return result;    &#125;    public void binaryTreePathsFinder(TreeNode root, String path, List&lt;String&gt; result)&#123;        if (root == null) return ;        if(root.left == null &amp;&amp; root.right == null)&#123;            result.add(path + root.val);        &#125;        else if( root.left != null &amp;&amp; root.right != null)&#123;            path = path + root.val + &quot;-&gt;&quot;;            binaryTreePathsFinder(root.left, path, result);            binaryTreePathsFinder(root.right, path, result);        &#125;        else if(root.left != null &amp;&amp; root.right == null)&#123;            path = path + root.val + &quot;-&gt;&quot;;            binaryTreePathsFinder(root.left, path, result);        &#125;        else&#123;            path = path + root.val + &quot;-&gt;&quot;;            binaryTreePathsFinder(root.right, path, result);        &#125;    &#125;&#125;\n\npublic List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;    List&lt;String&gt; answer = new ArrayList&lt;String&gt;();    if (root != null) searchBT(root, &quot;&quot;, answer);    return answer;&#125;private void searchBT(TreeNode root, String path, List&lt;String&gt; answer) &#123;    if (root.left == null &amp;&amp; root.right == null) answer.add(path + root.val);    if (root.left != null) searchBT(root.left, path + root.val + &quot;-&gt;&quot;, answer);    if (root.right != null) searchBT(root.right, path + root.val + &quot;-&gt;&quot;, answer);&#125;\n","categories":["leetcode"]},{"title":"leetcode  278 Fisrt Bad Version","url":"/leetcode/leetcode-solution-278/","content":"You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\nCredits:\nSpecial thanks to @jianchao.li.fighter for adding this problem and creating all test cases.\n\n/* The isBadVersion API is defined in the parent class VersionControl.      boolean isBadVersion(int version); */public class Solution extends VersionControl &#123;    // public int firstBadVersion(int n) &#123;    //     return helper(1, n);    // &#125;    // public int helper(int start, int end)&#123;    //     if(start == end)    //         return start;    //     int mid = (start + end) &gt;&gt; 1;    //     if(isBadVersion(mid))    //         return helper(start, mid);    //     else    //         return helper(mid+1, end);    // &#125;    public int firstBadVersion(int n)&#123;        int start = 1;        int end = n;        while(start &lt; end)&#123;            int mid = start + ((end - start)&gt;&gt;1);            if(isBadVersion(mid))                end = mid;            else                start = mid+1;        &#125;        return start;    &#125;&#125;\n\n\n简单的二分查找\n\n\n要注意递归的话会超时\n\n\n同时，如果start end 都是超大的数的话，直接start+end可能会导致溢出，因此，用 start + （end - start）/2 。 同时，位操作相比于直接相除速度要快。因此\nmid = start + ((end - start)&gt;&gt;1)\n\n\n","categories":["leetcode"]},{"title":"leetcode  279 Perfect Squares","url":"/leetcode/leetcode-solution-279-Perfect-Squares/","content":"Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\nFor example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.\n\nclass Solution &#123;    public int numSquares(int n) &#123;        int[] dp = new int[n+1];        for(int i=1; i&lt;=n; i++)&#123;            int j=1;            dp[i] = i;            while( i - j*j &gt;= 0)&#123;                dp[i] = Math.min(dp[i], dp[i-j*j]+1);                j++;            &#125;                    &#125;        return dp[n];    &#125;&#125;\ndp[0] = 0 dp[1] = dp[0]+1 = 1dp[2] = dp[1]+1 = 2dp[3] = dp[2]+1 = 3dp[4] = Min&#123; dp[4-1*1]+1, dp[4-2*2]+1 &#125;       = Min&#123; dp[3]+1, dp[0]+1 &#125;       = 1\t\t\t\tdp[5] = Min&#123; dp[5-1*1]+1, dp[5-2*2]+1 &#125;       = Min&#123; dp[4]+1, dp[1]+1 &#125;       = 2\t\t\t\t\t\t.\t\t\t\t\t\t.\t\t\t\t\t\t.dp[13] = Min&#123; dp[13-1*1]+1, dp[13-2*2]+1, dp[13-3*3]+1 &#125;        = Min&#123; dp[12]+1, dp[9]+1, dp[4]+1 &#125;        = 2\t\t\t\t\t\t.\t\t\t\t\t\t.\t\t\t\t\t\t.dp[n] = Min&#123; dp[n - i*i] + 1 &#125;,  n - i*i &gt;=0 &amp;&amp; i &gt;= 1\n","categories":["leetcode"]},{"title":"leetcode  290 word Pattern","url":"/leetcode/leetcode-solution-290/","content":"\nGiven a pattern and a string str, find if str follows the same pattern.\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.\nExamples:\n\npattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot; should return true.\npattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot; should return false.\npattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot; should return false.\npattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot; should return false.\n\nNotes:\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.\n\nclass Solution &#123;    public boolean wordPattern(String pattern, String str) &#123;        String[] words = str.split(&quot; &quot;);        if(pattern.length() != words.length )            return false;        int n = pattern.length();        HashMap&lt;Character, String&gt; m = new HashMap&lt;Character, String&gt;();        for(int i=0; i&lt;n; i++)&#123;            if(m.containsKey(pattern.charAt(i)))&#123;                if(!m.get(pattern.charAt(i)).equals(words[i]))&#123;                    return false;                &#125;            &#125;            else &#123;                if(m.containsValue(words[i]))                    return false;                m.put(pattern.charAt(i), words[i]);            &#125;        &#125;        return true;    &#125;&#125;\n\n使用一个hashmap，值得注意的是题中的要求是一对一，不能一对对，也不能多对一。\n\n","categories":["leetcode"]},{"title":"leetcode 28 Implement strStr()","url":"/leetcode/leetcode-solution-28/","content":"28. Implement strStr()\n\nImplement strStr().\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1:\nInput: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2\nExample 2:\nInput: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1\n\n第一反应就是建立一个hashMap&lt;String, Integer&gt; 来存储substring和对应的index。\nclass Solution &#123;    public int strStr(String haystack, String needle) &#123;        // 注意当要查找的string为“”时，返回的是0，不是-1      \tif(needle.length() == 0)&#123;            return 0;        &#125;                int window = needle.length();        HashMap&lt;String, Integer&gt; m = new HashMap&lt;String, Integer&gt;();        for (int i=0;i&lt;=haystack.length()-window; i++)&#123;// 这里注意是&lt;=，因为有可能两个字符串长度相等            String substring = haystack.substring(i,i+window);            m.put(substring, i);            if(m.containsKey(needle))&#123;// 返回首个index，所以这里的判断语句要在for之内                return m.get(needle);            &#125;        &#125;        return -1;    &#125;&#125;\n\nbut，在discuss区看到：\npublic class Solution &#123;    public int strStr(String haystack, String needle) &#123;        int l1 = haystack.length(), l2 = needle.length();        if (l1 &lt; l2) &#123;            return -1;        &#125; else if (l2 == 0) &#123;            return 0;        &#125;        int threshold = l1 - l2;        for (int i = 0; i &lt;= threshold; ++i) &#123;       \t\t// 直接判断是否相等就好，不用hashMap！！！！            if (haystack.substring(i,i+l2).equals(needle)) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode  287 Find the Duplicate Number","url":"/leetcode/leetcode-solution-287-Find-the-Duplicate-Number/","content":"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\nNote:\n\nYou must not modify the array (assume the array is read only).\nYou must use only constant, O(1) extra space.\nYour runtime complexity should be less than O(n2).\nThere is only one duplicate number in the array, but it could be repeated more than once.\n\n\nclass Solution &#123;    public int findDuplicate(int[] nums) &#123;        if(nums.length == 0) return -1;        if(nums.length == 1) return nums[0];        int slow = 0;        int fast = 0;        do&#123;            slow = nums[slow];            fast = nums[nums[fast]];        &#125;while(slow != fast);        fast = 0;        while(slow != fast)&#123;            slow = nums[slow];            fast = nums[fast];        &#125;        return slow;    &#125;&#125;\n\n\n可以看成是有环链表中找到环的entrypoint\n\n\nfast指针和slow指针，设相交点为p\n\n\n设slow指针走的路程为s\n\n\nfaslt走的路程为2s\n\n\n2s = s + nC（C为cycle的长度）\n\n\n即slow走过的长度即为cycle的长度\n\n\n设startpoint到entrypoint的长度为x，则entrypoint到endpoint的长度为y\n\n\nx + y = s = nC\n\n\nx = nC - y\n\n\n即说明startpint到entrypoint的距离x和endpoint到entrypoint的距离相等。\n\n\n\n\n","categories":["leetcode"]},{"title":"leetcode  299 Bulls and Cows","url":"/leetcode/leetcode-solution-299-Bulls-and-Cows/","content":"You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.\nFor example:\nSecret number:  &quot;1807&quot;Friend&#x27;s guess: &quot;7810&quot;\nHint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)\nPlease note that both secret number and friend’s guess may contain duplicate digits, for example:\nSecret number:  &quot;1123&quot;Friend&#x27;s guess: &quot;0111&quot;\t\nIn this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return &quot;1A1B&quot;.\nYou may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.\n\n\n\n对于bull，是很好统计的。对应位置的数字相同，bull++即可\n\n\n但是对于cows，统计起来需要技巧。\n\n\nsecret\t: 10\nguess\t: 01\nbull\t: 0\ncows\t: 2\n\nsecret\t: 100\nguess\t: 010\nbull\t: 1\ncows\t: 2\n\nsecret\t: 11\nguess\t: 01\nbull\t: 1\ncows\t: 0\n\nsecret\t: 01\nguess\t: 11\nbull\t: 1\ncows\t: 0\n  对于每一个guess[i]!=secret[i]的元素  ​\t如果guess中元素，在secret中存在且没有与secret中配对的guess中的元素，则cows++  ​\t如果secret中元素，在guess中存在且没有与guess中配对的guess中的元素，则cow++---\n\n\n\nclass Solution{\npublic String getHint(String secret, String guess){\n\tint bull = 0;\n\tint cows = 0;\n\tint[] helper = new int[10];\nfor(int i=0; i&lt;secret.length(); i++){\nint m = secret.charAt(i) - ‘0’;\nint n = guess.charAt(i) - ‘0’;\nif(m == n){\nbull ++;\n}\nelse{\nif(helper[m] &lt; 0) cows ++;\nif(helper[n] &gt; 0) cows ++;\nhelper[m] ++;\nhelper[n] --;\n}\nreturn bull + “A” + cows + “B”;\n}\n}\n\n\n\n","categories":["leetcode"]},{"title":"leetcode 313 Super Ugly Number","url":"/leetcode/leetcode-solution-313-Super-Ugly-Number/","content":"Write a program to find the nth super ugly number.\nSuper ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4.\nNote:\n(1) 1 is a super ugly number for any given primes.\n(2) The given numbers in primes are in ascending order.\n(3) 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000.\n(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n\nclass Solution &#123;    public int nthSuperUglyNumber(int n, int[] primes) &#123;        int size = primes.length;        int[] nums = new int[size];                for(int i=0; i&lt;size; i++)&#123;            nums[i] = primes[i];        &#125;                int[] index = new int[size];        int[] ans = new int[n];        ans[0] = 1;                for(int i=1; i&lt;n; i++)&#123;            int min = Integer.MAX_VALUE;                        for(int j=0; j&lt;size; j++)&#123;                min = Math.min(min, nums[j]);            &#125;            ans[i] = min;            for(int j=0; j&lt;size; j++)&#123;                if(ans[i] == nums[j])&#123;                    index[j] ++;                    nums[j] = ans[index[j]] * primes[j];                &#125;            &#125;                    &#125;        return ans[n-1];            &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode 40 组合总和 II","url":"/article/leetcode-solution-40-Combination-Sum-II/","content":"Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\nEach number in C may only be used once in the combination.\nNote:\n\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\n\nFor example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\nA solution set is:\n[  [1, 7],  [1, 2, 5],  [2, 6],  [1, 1, 6]]\n\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if(candidates.length == 0) return ans;        Arrays.sort(candidates);        backtrace(ans, new ArrayList&lt;Integer&gt;() , candidates, target, 0);        return ans;    &#125;        public void backtrace(List&lt;List&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; t, int[] candidates, int target, int start)&#123;        if(target == 0)&#123;            ans.add(new ArrayList&lt;Integer&gt;(t));        &#125;        for(int i=start; i&lt;candidates.length; i++)&#123;            if(i!= start &amp;&amp; candidates[i-1] == candidates[i])                continue;            if(candidates[i] &gt; target)                 return ;            t.add(candidates[i]);            backtrace(ans, t, candidates, target - candidates[i], i+1);            t.remove(t.size()-1);        &#125;    &#125;&#125;\n\n注意有重复的情况\n\n[10,1,2,7,6,1,5]\n8\n如果没有continue操作，则会产生两个[1,7]\n\n\n\n","tags":["leetcode","数组","回溯"]},{"title":"leetcode  39 Combination Sum","url":"/leetcode/leetcode-solution-39/","content":"Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\nThe same repeated number may be chosen from C unlimited number of times.\nNote:\n\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\n\nFor example, given candidate set [2, 3, 6, 7] and target 7,\nA solution set is:\n[  [7],  [2, 2, 3]]\n\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if(candidates.length == 0) return ans;        Arrays.sort(candidates);        ArrayList&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;();        backtrack(candidates, target, ans, t, 0);        return ans;    &#125;        public void backtrack(int[] candidates, int target, List&lt;List&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; t, int start)&#123;        if(target == 0)&#123;           ans.add(new ArrayList(t));            return ;        &#125;        if(target &lt; 0)            return ;                for(int i=start; i&lt;candidates.length; i++)&#123;            if(candidates[i] &lt;= target)&#123;                t.add(candidates[i]);                backtrack(candidates, target - candidates[i], ans, t, i);                t.remove(t.size() - 1);            &#125;        &#125;    &#125;&#125;\n\n在不添加start的情况下，是直接的回溯法\n这里要考虑到需要取出重复操作。如果不加上start，会出现 [1,1,2] [2,1,1]同时出现的情况。\n\n","categories":["leetcode"]},{"title":"leetcode 35 Search Insert Position","url":"/article/leetcode-solution-35/","content":"35. Search Insert Position\n\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou may assume no duplicates in the array.\nExample 1:\nInput: [1,3,5,6], 5Output: 2\nExample 2:\nInput: [1,3,5,6], 2Output: 1\nExample 3:\nInput: [1,3,5,6], 7Output: 4\nExample 1:\nInput: [1,3,5,6], 0Output: 0\n\nclass Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        // 开始时进行特例设置，但是这里可以省去，因为当n==0时，low=0， high=-1,不会进入while循环，返回low=0      \tint n = nums.length;        if(n == 0)&#123;            return 0;        &#125;        int low = 0;        int high = n-1;        while (low &lt;= high)&#123;            int mid = (high + low)/2;            if(nums[mid]&lt; target)&#123;                low = mid+1;            &#125;            else if(nums[mid]&gt; target)&#123;                high = mid-1;            &#125;            else&#123;                return mid;            &#125;        &#125;        return low;    &#125;&#125;\n简单的二分查找。\n"},{"title":"leetcode  43 Multiply Strings","url":"/leetcode/leetcode-solution-43-Multiply-Strings/","content":"Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.\nNote:\n\nThe length of both num1 and num2 is &lt; 110.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n\npublic class Solution&#123;    public String MultiplyStrings(String num1, String num2)&#123;        int m = num1.length();        int n = num2.length();        int ans = new int[m+n];                for(int i=m-1; i&gt;=0; i++)&#123;            for(int j=n-1; j&gt;=0; j++)&#123;                int p1 = i+j;                int p2 = i+j+1;                                int mul = (num1.charAt(i) - &#x27;0&#x27;) * (num2.charAt(j) - &#x27;0&#x27;);                int sum = mul + ans[p2];                                ans[p1] += sum / 10;                ans[p2] = sum % 10;                         &#125;        &#125;        StringBuilder sb = new StringBuilder();        for(int i: ans)&#123;            if(!(i==0 &amp;&amp; sb.length() == 0))                sb.append(i);        &#125;        if(sb.length() == 0) return &quot;0&quot;;        else return sb.toString();           &#125;&#125;\n\n​\t\t1\t2\t3\t\t\tindex = 1\t(i)\n​\t* \t\t4\t5\t\t\tindex = 0\t(j)\n​\t----------------------------\n​\t\t\t1\t5\n​\t\t1\t0\n​\t0\t5\n​\t\t1\t2\n​\t0\t8\t\t\t\t\tindex = [1, 2]\t(i+j, i+j+1)\n0\t4\n--------------------------------------\nclass Solution(object):    def multiply(self, num1, num2):        &quot;&quot;&quot;        :type num1: str        :type num2: str        :rtype: str        &quot;&quot;&quot;        n1, n2 = len(num1), len(num2)        ans = [0]*(n1+n2)        for i in range(n1-1, -1, -1):            for j in range(n2-1, -1, -1):                t = int(num1[i]) * int(num2[j])                idx = i+j+1                ans[idx] += t                if ans[idx] &gt;= 10:                    ans[idx-1] += ans[idx]//10                    ans[idx] = ans[idx]%10                while ans[0] == 0 and len(ans)&gt;1:            ans.pop(0)        return &quot;&quot;.join(map(str, ans))\n","categories":["leetcode"]},{"title":"leetcode  46 Permutations","url":"/leetcode/leetcode-solution-46/","content":"Given a collection of distinct numbers, return all possible permutations.\nFor example,\n[1,2,3] have the following permutations:\n[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]\n\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        if(nums.length == 0) return null;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();        boolean[] used = new boolean[nums.length];        ArrayList&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;();        dfs(ans, nums, t, used);        return ans;    &#125;    public void dfs(List&lt;List&lt;Integer&gt;&gt; ans, int[] nums, ArrayList&lt;Integer&gt; t, boolean[] used)&#123;        if(t.size() == nums.length)&#123;            ans.add(new ArrayList(t));            return ;        &#125;        for(int i=0; i&lt;nums.length; i++)&#123;            if(!used[i])&#123;                used[i] = true;                t.add(nums[i]);                dfs(ans, nums, t, used);                used[i] = false;                t.remove(t.size()-1);            &#125;        &#125;            &#125;&#125;\n\n使用一个数组used来保存当前已经加入数组t中的元素。\n使用dfs的方法，找到一个可行解后，回溯，更换另一个解。\n\n","categories":["leetcode"]},{"title":"leetcode  47 Permutation II","url":"/leetcode/leetcode-solution-47/","content":"Given a collection of numbers that might contain duplicates, return all possible unique permutations.\nFor example,\n[1,1,2] have the following unique permutations:\n[  [1,1,2],  [1,2,1],  [2,1,1]]\n\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();        Arrays.sort(nums);        if(nums.length == 0)&#123;            return ans;        &#125;        ArrayList&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;();        boolean[] used = new boolean[nums.length];        dfs(nums, ans, t, used);        return ans;    &#125;    public void dfs(int[] nums, List&lt;List&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; t, boolean[] used)&#123;        if(t.size() == nums.length)&#123;            ans.add(new ArrayList&lt;Integer&gt;(t));            return ;        &#125;        else&#123;            for(int i=0; i&lt;nums.length; i++)&#123;                if(!used[i])&#123;                    if(i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1]) continue;                    used[i] = true;                    t.add(nums[i]);                    dfs(nums, ans, t, used);                        used[i] = false;                    t.remove(t.size()-1);                &#125;                            &#125;        &#125;            &#125;&#125;\n\nif(i&gt;0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1]) continue; Notice this is i-1， not i\nalso, when adding terms to ans, you should new a ArrayList\nUsing Dfs, remenber to remove the character you just processed.\n\n","categories":["leetcode"]},{"title":"leetcode  48. Rotate Image","url":"/leetcode/leetcode-solution-48-Rotate-Image/","content":"You are given an n x n 2D matrix representing an image.\nRotate the image by 90 degrees (clockwise).\nNote:\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nExample 1:\nGiven input matrix = [  [1,2,3],  [4,5,6],  [7,8,9]],rotate the input matrix in-place such that it becomes:[  [7,4,1],  [8,5,2],  [9,6,3]]\nExample 2:\nGiven input matrix =[  [ 5, 1, 9,11],  [ 2, 4, 8,10],  [13, 3, 6, 7],  [15,14,12,16]], rotate the input matrix in-place such that it becomes:[  [15,13, 2, 5],  [14, 3, 4, 1],  [12, 6, 8, 9],  [16, 7,10,11]]\n\nclass Solution &#123;    public void rotate(int[][] matrix) &#123;        for(int i=0; i&lt;matrix.length/2; i++)&#123;            for(int j=i; j&lt;matrix.length-1-i; j++)&#123;                int temp = matrix[i][j];                matrix[i][j] =  matrix[matrix.length-1-j][i];                matrix[matrix.length-1-j][i] = matrix[matrix.length-1-i][matrix.length-1-j];                matrix[matrix.length-1-i][matrix.length-1-j] = matrix[j][matrix.length-1-i];                matrix[j][matrix.length-1-i]= temp;            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\ni, j\n\n\nj, matrix.length-1-i\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmatrix.length-1-j, i\n\n\nmatrix.length-1-i, matrix.length-1-j\n\n\n\n\n\n","categories":["leetcode"]},{"title":"leetcode 485 Max Consecutive Ones","url":"/leetcode/leetcode-solution-485/","content":"Given a binary array, find the maximum number of consecutive 1s in this array.\nExample 1:\nInput: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s.    The maximum number of consecutive 1s is 3.\nNote:\n\nThe input array will only contain 0 and 1.\nThe length of input array is a positive integer and will not exceed 10,000\n\n\nThe basic idea is to set an tag recording the maxium ones at present.\nwhen current number is One,  current++\nwhen current number is Zero, copy the max one to max\nIn case a situation where all the numbers are One, e.g. [1, 1, 1]\ncurrent == 3 , however, there is no Zero, so max still should be 0,\nyou should return the max of current and max\nclass Solution &#123;    public int findMaxConsecutiveOnes(int[] nums) &#123;        int max = 0;        int current = 0;        for(int i=0; i&lt;nums.length; i++)&#123;            if(nums[i] == 1)&#123;                current ++;            &#125;            else&#123;                max = Math.max(max, current);                current = 0;            &#125;        &#125;        return max = Math.max(max, current);    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode 5 Longest Palindromic Substring","url":"/article/leetcode-solution-5/","content":"5. Longest Palindromic Substring\n\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nExample:\nInput: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.\nExample:\nInput: &quot;cbbd&quot;Output: &quot;bb&quot;\n\n这道题在卜老师的算法课上做过。\n用动态规划的思想，开辟一个n*n的二维数组dp\n当dp[i][j]是回文且s[i-1]==s[j+1]时，新的子字符串也是回文\n注意临界点的处理，上述条件只适用于j-i &gt; 2的情况\n当j-i &lt;= 2 时，相当于 (i) () (j) 和 (i) (j) 这两种情况，只需要判断s[i] 是否等于s[j] 即可。\n临界条件同样也可以改为\nif((i-j &gt;=2 &amp;&amp; s.charAt(j)==s.charAt(i) &amp;&amp; dp[j+1][i-1])|| (i-j&lt;=1 &amp;&amp; s.charAt(j)==s.charAt(i))) \n因为当j-i == 2时，dp[i+1][j-1] 表示的是长度为1的字符串，已经在之前判断过，可以放在第一个判断里面。\n**注意：**问清楚，当字符串为：abcdefg这种形式时，返回什么。\n\nclass Solution &#123;    public String longestPalindrome(String s) &#123;        if (s.length() == 0)&#123;            return &quot;&quot;;        &#125;        if (s.length() == 1)&#123;            return s;        &#125;        int n = s.length();        int max = 0;        String result = s.substring(0,1);                boolean dp[][] = new boolean[n][n];                for(int i=0; i&lt;n; i++)&#123;            for (int j=0; j&lt;=i; j++)&#123;                if((i-j &gt;2 &amp;&amp; s.charAt(j)==s.charAt(i) &amp;&amp; dp[j+1][i-1])|| (i-j&lt;=2 &amp;&amp; s.charAt(j)==s.charAt(i))) &#123;                    dp[j][i] = true;                    if(max &lt; i-j)&#123;                        max = i-j;                        result = s.substring(j,i+1);                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 50 Pow(x, n)","url":"/article/leetcode-solution-50/","content":"50. Pow(x, n)\n\nImplement pow(x, n).\nExample 1:\nInput: 2.00000, 10Output: 1024.00000\nExample 2:\nInput: 2.10000, 3Output: 9.26100\n\n\n最要考察递归，初始的idea是pow(x, n) = x*pow(x, n-1) 但是这样的递归势必会造成栈溢出\n如果n是2的倍数，则可以进一步转换为pow(x, n) = pow(x,n/2)*pow(x, n/2) 但是这样有包含重复计算的子问题\n进一步转换 pow(x, n) = pow(x*x,n/2)\n同时，考虑当n小于0时，$x^n = \\frac{1}{x}^{-n}$ 所以我们需要将x = 1/x, 同时 n = -n;\n注意： 在对一个int类型取反的时候，一定要考虑溢出问题，对于一个int类型的数，范围为[$-2^{31}, 2^{31}-1$], 如果对$-2^{31}$ 取反，就会造成溢出问题，因此需要考虑当n== Integer.MIN_VALUE的问题。\n当n== Integer.MIN_VALUE,如果x==1的话，1的任何次方都为1，当x != 1 的话，相当于是$\\frac{1}{x}^{+∞}$ == 0\n\n\nclass Solution &#123;    public double myPow(double x, int n) &#123;        if (n== Integer.MIN_VALUE )&#123;            if (x == 1 || x == -1)&#123;                return 1;            &#125;            else&#123;                return 0;            &#125;        &#125;                if (n==0)&#123;            return 1;        &#125;        if (n&lt;0)&#123;            x = 1/x;            n = -n;        &#125;        if (n%2 == 0)            return myPow(x*x, n/2);        return x*myPow(x,n-1);    &#125;&#125;\n\n","tags":["leetcode"]},{"title":"leetcode 53 Maximal Subarray","url":"/leetcode/leetcode-solution-53/","content":"###53. Maximum Subarray\n\nFind the contiguous subarray within an array (containing at least one number) which has the largest sum.\nFor example, given the array [-2,1,-3,4,-1,2,1,-5,4],\nthe contiguous subarray [4,-1,2,1] has the largest sum = 6.\n\n第一眼看是一个简单的动态规划问题\ndp[i][j] 保存数组从i到j的和，利用下面的dp式进行简化计算\ndp[i][j]  = dp[i][j-1] + nums[j]\n注意要问清楚，当数组为空的时候的返回值是多少\n于是写出了如下动态规划代码\nclass Solution &#123;    public int maxSubArray(int[] nums) &#123;        int n = nums.length;        int[][] dp = new int[n][n];        int current_max = Integer.MIN_VALUE;                for (int i=0;i&lt;n;i++)&#123;            dp[i][i] = nums[i];            if(dp[i][i] &gt; current_max)&#123;                current_max = dp[i][i];            &#125;            for(int j=0; j&lt;=i; j++)&#123;                if(i&gt;=1)&#123;                    dp[j][i] = dp[j][i-1] + nums[i];                    if(dp[j][i] &gt; current_max)&#123;                        current_max = dp[j][i];                    &#125;                &#125;                           &#125;        &#125;        return current_max;    &#125;&#125;\n时间复杂度为$O(n^2)$,提交显示超时。\n其实可以优化成$O(n)$\ndp[i]表示以i结尾的子串中，最大的数值和。\nclass Solution &#123;    public int maxSubArray(int[] nums) &#123;        int n = nums.length;        int[] dp = new int[n];        int current_max = Integer.MIN_VALUE;        if(n == 0)&#123;            return current_max;        &#125;        dp[0] = nums[0];        current_max = dp[0];                for(int i=1; i&lt;n; i++)&#123;            //dp[i] = nums[i] &gt; 0 ? dp[i-1]+nums[i]:nums[i]; // 这里了错了，如果dp[i-1]&lt;0,就有问题            //dp[i] = nums[i] + (dp[i-1]&gt;0? dp[i-1]: 0); // 对的，同下            dp[i] = nums[i] + Math.max(dp[i-1], 0);            current_max = Math.max(current_max, dp[i]);        &#125;        return current_max;    &#125;&#125;\nclass Solution(object):    def maxSubArray(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        if not nums:            return 0        maxSum = nums[0]        cur = 0        for i in nums:            cur = max(cur+i, i)            maxSum = max(cur, maxSum)        return maxSum                        \n","categories":["leetcode"]},{"title":"leetcode  54 Spiral Matrix","url":"/leetcode/leetcode-solution-54/","content":"Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\nFor example,\nGiven the following matrix:\n[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]\nYou should return [1,2,3,6,9,8,7,4,5].\n\nclass Solution &#123;    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;        List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();        if(matrix == null || matrix.length == 0) return ans;        int upperRow = 0;        int bottomRow = matrix.length-1;        int leftColumn = 0;        int rightColumn = matrix[0].length-1;                while(upperRow &lt;= bottomRow &amp;&amp; leftColumn &lt;= rightColumn)&#123;            for(int i=leftColumn; i&lt;=rightColumn; i++)&#123;                ans.add(matrix[upperRow][i]);            &#125;            upperRow ++;                        for(int i=upperRow; i&lt;= bottomRow; i++)&#123;                ans.add(matrix[i][rightColumn]);                            &#125;            rightColumn --;                        if(upperRow &lt;= bottomRow)&#123;                for(int i=rightColumn; i&gt;= leftColumn; i--)&#123;                    ans.add(matrix[bottomRow][i]);                &#125;                bottomRow --;            &#125;                            if(leftColumn &lt;= rightColumn)&#123;                for(int i=bottomRow; i&gt;= upperRow; i--)&#123;                    ans.add(matrix[i][leftColumn]);                &#125;                leftColumn ++;            &#125;                        &#125;        return ans;    &#125;&#125;\n\nUsing four pointers to point the four outside boundaries.\n\n","categories":["leetcode"]},{"title":"leetcode  55 Jump Game","url":"/leetcode/leetcode-solution-55/","content":"Given an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nFor example:\nA = [2,3,1,1,4], return true.\nA = [3,2,1,0,4], return false.\n\nclass Solution &#123;    public boolean canJump(int[] nums) &#123;        int max = 0;        for(int i = 0; i &lt; nums.length; i++)&#123;            if(i &gt; max)&#123;                return false;            &#125;            max = Math.max(max, i+nums[i]);        &#125;        return true;            &#125;&#125;\n\nUsing max to tag currently, the max distance we can reach.\nEvery time , we check if current max reaches the index distance, if not, return false.\n\nclass Solution(object):    def canJump(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: bool        &quot;&quot;&quot;        i = 0        far = 0        while i &lt;= far:            far = max(far, i+nums[i])            if far &gt;= len(nums)-1:                return True            i += 1        return False\n","categories":["leetcode"]},{"title":"leetcode  57 Insert Interval","url":"/leetcode/leetcode-solution-57/","content":"Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\nYou may assume that the intervals were initially sorted according to their start times.\nExample 1:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]Output: [[1,5],[6,9]]\nExample 2:\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]Output: [[1,2],[3,10],[12,16]]Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\n\n若interval在当前区间的右边，将当前区间添加到ans中\n若interval在当前区间的左边，判断是否已经插入过interval\n\n若没插入过interval，插入interval，修改插入标记，插入当前区域\n若已插入过interval，插入当前区域\n\n\n若interval和当前区间有交集，将interval.start 取interval和当前区间的最小值，interval.end 取interval和当前区域的最大值，继续循环。\n循环结束，判断是否已经插入，若没插入，即将interval插入ans，结束。\n\nclass Solution &#123;    public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123;        int start = newInterval.start;        int end = newInterval.end;        List&lt;Interval&gt; ans = new LinkedList&lt;Interval&gt;();        int n = intervals.size();        if (n == 0)&#123;            ans.add(newInterval);        &#125;        else&#123;            boolean inserted = false;            for (Interval s: intervals)&#123;                if (end &lt; s.start)&#123;                    if (! inserted)&#123;                        ans.add(new Interval(start, end));                        inserted = true;                    &#125;                    ans.add(s);                &#125;                else if (start &gt; s.end)&#123;                    ans.add(s);                &#125;                else&#123;                    start = Math.min(s.start, start);                    end = Math.max(s.end, end);                &#125;            &#125;            if (!inserted)&#123;                ans.add(new Interval(start, end));            &#125;        &#125;        return ans;    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetocode 58 Length of Last Word","url":"/article/leetcode-solution-58/","content":"Length of Last Word\n\nGiven a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.\nIf the last word does not exist, return 0.\nNote: A word is defined as a character sequence consists of non-space characters only.\nExample:\nInput: &quot;Hello World&quot;Output: 5\n\n倒序遍历string\n用length记录最后一个单词的长度\n如果length==0，且当前字符为‘ ’，continue\n如果length！=0 ，且当前字符不为‘ ’，length++\n如果length！=0，且当前字符为‘ ’，说明是在最后一个单词前面的‘ ’，return length。\nclass Solution &#123;    public int lengthOfLastWord(String s) &#123;        int n = s.length();        int length = 0;        for (int i=n-1;i&gt;=0;i--)&#123;            if(s.charAt(i) == &#x27; &#x27;)&#123;                if(length == 0)                    continue;                else                    return length;            &#125;            else&#123;                length ++;            &#125;        &#125;        return length;    &#125;&#125;\n\ndiscuss里有一个超级简洁的写法：\npublic int lengthOfLastWord(String s) &#123;    return s.trim().length()-s.trim().lastIndexOf(&quot; &quot;)-1;&#125;\n\n总结一下java中String对象常用的方法：\njava中String的常用方法\n\n\nlength() 字符串的长度\nchar chars[]={‘a’,‘b’.‘c’};\n　　　　String s=new String(chars);\n　　　　int len=s.length();\n\n\ncharAt() 截取一个字符\n例：char ch;\n　　　　ch=“abc”.charAt(1); 返回’b’\n\n\ngetChars() 截取多个字符\nvoid getChars(int sourceStart,int sourceEnd,char target[],int targetStart)\n　　sourceStart指定了子串开始字符的下标\n​\tsourceEnd指定了子串结束后的下一个字符的下标。因此， 子串包含从sourceStart到sourceEnd-1的字符。\n​\t接收字符的数组由target指定，target中开始复制子串的下标值是targetStart。\n例：String s=“this is a demo of the getChars method.”;\n　　　　char buf[]=new char[20];\n　　　　s.getChars(10,14,buf,0);\n\n\ngetBytes()\n​\t替代getChars()的一种方法是将字符存储在字节数组中，该方法即getBytes()。\n\n\ntoCharArray()\n\n\nequals()和equalsIgnoreCase() 比较两个字符串\n\n\nregionMatches() 用于比较一个字符串中特定区域与另一特定区域，它有一个重载的形式允许在比较中忽略大小写。\nboolean regionMatches(int startIndex,String str2,int str2StartIndex,int numChars)\n　　boolean regionMatches(boolean ignoreCase,int startIndex,String str2,int str2StartIndex,int numChars)\n\n\nstartsWith()和endsWith()\n​\tstartsWith()方法决定是否以特定字符串开始\n​\tendWith()方法决定是否以特定字符串结束\n\n\nequals() 和 ==\nequals()方法比较字符串对象中的字符\n​\t==运算符比较两个对象是否引用同一实例。\n　　例：String s1=“Hello”;\n　　　　String s2=new String(s1);\n　　　　s1.eauals(s2); //true\n　　　　s1==s2;//false\n\n\ncompareTo()和compareToIgnoreCase() 比较字符串\n\n\nindexOf()和lastIndexOf()\nindexOf() 查找字符或者子串第一次出现的地方。\n　　lastIndexOf() 查找字符或者子串是后一次出现的地方。\n\n\nsubstring()\n​\t它有两种形式，第一种是：String substring(int startIndex)\n\n\n第二种是：String substring(int startIndex,int endIndex)\n\n\nconcat()\n​\t连接两个字符串\n\n\nreplace() 替换\n它有两种形式，第一种形式用一个字符在调用字符串中所有出现某个字符的地方进行替换，形式如下：\n　　\tString replace(char original,char replacement)\n　　\t例如：String s=“Hello”.replace(‘l’,‘w’);\n　　第二种形式是用一个字符序列替换另一个字符序列，形式如下：\n　　\tString replace(CharSequence original,CharSequence replacement)\n\n\ntrim() 去掉起始和结尾的空格\n\n\nvalueOf() 转换为字符串\n\n\ntoLowerCase() 转换为小写\n\n\ntoUpperCase() 转换为大写\nStringBuffer\n\n\nStringBuffer构造函数\n\n\nStringBuffer定义了三个构造函数：\n　　StringBuffer()\n　　StringBuffer(int size)\n　　StringBuffer(String str)\n　　StringBuffer(CharSequence chars)\n\n\nlength()和capacity()\n​\t一个StringBuffer当前长度可通过length()方法得到,而整个可分配空间通过capacity()方法得到\n\n\n\nensureCapacity() 设置缓冲区的大小\n\nvoid ensureCapacity(int capacity)\n\nsetLength() 设置缓冲区的长度\n\nvoid setLength(int len)\n\ncharAt()和setCharAt()\n\nchar charAt(int where)\n　　　　void setCharAt(int where,char ch)\n\ngetChars()\n\nvoid getChars(int sourceStart,int sourceEnd,char target[],int targetStart)\n\nappend() 可把任何类型数据的字符串表示连接到调用的StringBuffer对象的末尾。\n\n例：int a=42;\n　　　　　　StringBuffer sb=new StringBuffer(40);\n　　　　　　String s=sb.append(“a=”).append(a).append(&quot;!&quot;).toString();\n\ninsert() 插入字符串\n\nStringBuffer insert(int index,String str)\n　　　　StringBuffer insert(int index,char ch)\n　　　　StringBuffer insert(int index,Object obj)\n　　　　index指定将字符串插入到StringBuffer对象中的位置的下标。\n\nreverse() 颠倒StringBuffer对象中的字符\n\nStringBuffer reverse()\n\ndelete()和deleteCharAt() 删除字符\n\nStringBuffer delete(int startIndex,int endIndex)\n　　　　StringBuffer deleteCharAt(int loc)\n\nreplace() 替换\n\nStringBuffer replace(int startIndex,int endIndex,String str)\n"},{"title":"leetcode  61 Rotate List","url":"/leetcode/leetcode-solution-61-Rotate-List/","content":"\n\nRotate List\n\nGiven a linked list, rotate the list to the right by k places, where k is non-negative.\nExample 1:\nInput: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL\nExample 2:\nInput: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL\n\n/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode rotateRight(ListNode head, int k) &#123;        int length = 1;        ListNode tag = head;        ListNode tail = head;        if (head == null)&#123;            return head;        &#125;        while(tail.next != null)&#123;            tail = tail.next;            length ++;        &#125;        k = (length - (k % length)) - 1;        tag = head;        int i = 0;        while(i &lt; k)&#123;            tag = tag.next;            i++;        &#125;        ListNode t = tag.next;        if(t == null)&#123;            return head;        &#125;        tag.next = null;        tail.next = head;        return t;    &#125;&#125;\npython\n\n","categories":["leetcode"]},{"title":"leetcode 62 63 Unique Paths","url":"/leetcode/leetcode-solution-62-63/","content":"62. Unique Paths I\n\n给定一个m*n的棋盘，从棋盘左上角到棋盘右下角最多有多少条路径。\n每一次移动，只能向右移一格或者向下移动一格。\n\n\n\nstar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nend\n\n\n\n\n动态规划问题：\ndp[i][j] = dp[i-1][j] + dp[i][j-1];\n当i==0，或者j == 0时，表示在棋盘的边缘，只有向下或者向右一条路。所以dp[i][j] = 1;\n63 Unique Path II\n\n相对于上一题，增加了一个条件：给定了一个等棋盘大小的01矩阵，1表示对应位置为一个障碍位置，不能走。\n同样求一共有多少条路。\n\n\n\nstart\n1\n0\n\n\n\n\n0\n0\n0\n\n\n0\n0\n0\n\n\n0\n1\nend\n\n\n\n\n当obstacleGird[i][j] == 1时，dp[i][j] = 0;\n当i==0 and j==0时，dp[i][j] = 1;\n当i==0时，dp[i][j] = dp[i][j-1]\n当j==0时，dp[i][j] = dp[i-1][j]\ndp[i][j] = dp[i-1][j] + dp[i][j-1]\nclass Solution(object):    def uniquePathsWithObstacles(self, obstacleGrid):        &quot;&quot;&quot;        :type obstacleGrid: List[List[int]]        :rtype: int        &quot;&quot;&quot;        if not obstacleGrid or not obstacleGrid[0]:            return False        m, n = len(obstacleGrid), len(obstacleGrid[0])        dp = [[0 for i in range(n)] for j in range(m)]        for i in range(m):            for j in range(n):                if obstacleGrid[i][j] == 0:                    if i==0 and j==0:                        dp[i][j] = 1                    elif i==0:                        dp[i][j] = dp[i][j-1]                    elif j==0:                        dp[i][j] = dp[i-1][j]                    else:                        dp[i][j] = dp[i-1][j] + dp[i][j-1]        return dp[-1][-1]\n","categories":["leetcode"]},{"title":"leetcode 41 缺失的第一个正数","url":"/article/leetcode-solution-41/","content":"Given an unsorted integer array, find the smallest missing positive integer.\nExample 1:\nInput: [1,2,0]Output: 3\nExample 2:\nInput: [3,4,-1,1]Output: 2\nExample 3:\nInput: [7,8,9,11,12]Output: 1\nNote:\nYour algorithm should run in O(n) time and uses constant extra space.\n\n\n\nPutting every number into the right place recuritivly\n​\t4, 3, 1, 2, 5\n-&gt; \t2, 3, 1, 4, 5\t( swap 4, 2 )\n-&gt;\t3, 2, 1, 4, 5\t( swap 2, 3 )\n-&gt;\t1, 2, 3, 4, 5\t( swap 1, 3 )\n\n\nScan the array, find the first place that not correspond to it’s value\n​\t1, 2, 3, 6, 7\t( return 4 )\n​\t4, 5, 6, 7, 8 \t( return 1 )\n\n\n   public static void swap(int[] list, int a, int b)&#123;       int temp = list[a];       list[a] = list[b];       list[b] = temp;   &#125;public static int solution(int[] list)&#123;       int n = list.length;       for (int i=0; i&lt;n; i++)&#123;           while(list[i]&gt;0  &amp;&amp; list[i]&lt;n &amp;&amp; list[i]!= list[list[i]-1])&#123;               swap(list, i, list[i]-1);           &#125;       &#125;       for (int i=0; i&lt;n; i++)&#123;           if (list[i]!= i+1)               return i+1;       &#125;       return n+1;   &#125;\n","tags":["leetcode","数组"]},{"title":"leetcode  64 Minimum Path Sum","url":"/leetcode/leetcode-solution-64/","content":"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\nExample 1:\n[[1,3,1], [1,5,1], [4,2,1]]\nGiven the above grid map, return\n7\n. Because the path 1→3→1→1→1 minimizes the sum.\n\nclass Solution &#123;    public int minPathSum(int[][] grid) &#123;        if(grid == null || grid.length == 0) return 0;        int m = grid.length;        int n = grid[0].length;        int sum = 0;        int[][] dp = new int[m][n];        for(int i=0; i&lt;m; i++)&#123;            for(int j=0; j&lt;n; j++)&#123;                if(i==0 &amp;&amp; j==0)                    dp[i][j] =grid[0][0];                else if(i == 0)&#123;                    dp[i][j] = dp[i][j-1] + grid[i][j];                &#125;                else if(j==0)&#123;                    dp[i][j] = dp[i-1][j] + grid[i][j];                &#125;                else&#123;                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];                &#125;            &#125;            &#125;        return dp[m-1][n-1];            &#125;&#125;\n\n这种情况下，不需要使用DP数组。使用DP数组的好处就是能够不改变Grid中的内容。\n\n","categories":["leetcode"]},{"title":"leetcode 66 Plus One","url":"/leetcode/leetcode-solution-66/","content":"\n66. Plus One\nGiven a non-negative integer represented as a non-empty array of digits, plus one to the integer.\nYou may assume the integer do not contain any leading zero, except the number 0 itself.\nThe digits are stored such that the most significant digit is at the head of the list.\n\n开始的想法是将digits数组转换为int类型在自增1.\n但是这样digits表示的数字是可能超过int类型的范围的，long一样，因此不可取。\n下面解法的主体思路如下：\n\n设置一个int类型的carry表示进位，初始化为0\n\n\n对digits最后一位自增\n从digits最后一位开始判断当前的数字加上carry是否大于10\n如果大于10，对其模10，并将carry置1\n如果小于10，将carry置0\n循环结束后，判断当前carry是否为1\n如果为1，需要新建一个数组，第一位置1后，将digits复制到新建数组中\n\nclass Solution &#123;    public int[] plusOne(int[] digits) &#123;        int n = digits.length;        int carry = 0;        digits[n-1]++;        for(int i=n-1;i&gt;=0;i--)&#123;            digits[i] = digits[i] + carry;            if(digits[i] &gt; 9)&#123;                digits[i] = digits[i] % 10;                carry = 1;            &#125;            else&#123;                carry = 0;            &#125;        &#125;        if(carry != 0)&#123;            int[] result = new int[n+1];            result[0] = carry;            for(int i=1;i&lt;n+1;i++)&#123;                result[i] = digits[i-1];            &#125;            return result;        &#125;        return digits;\nbut！\ndiscuss区更优的解决方案：\npublic class Solution&#123;  public int[] plusOne(int[] digits)&#123;    int n = digits.length;    for(int i=n-1; i&gt;=0; i--)&#123;      if(digits[i] &lt; 9)&#123;        digits[i]++;        return digits;      &#125;      else&#123;        digits[i] = 0;      &#125;    &#125;    int[] result = new int[n+1];    result[0] = 1;    return result;  &#125;&#125;\n\n从后往前倒序遍历数组digits\n如果当前数字小于9，在当前数字+1后，返回digits\n如果当前数字大于9，也就是等于9，将当前数组置0\n如果循环结束都没有返回，说明digits数组已经被全部置为0了，需要新建一个数组，将第0位置1后返回。\n\n","categories":["leetcode"]},{"title":"leetcode 67 Add Binaies","url":"/leetcode/leetcode-solution-67/","content":"Given two binary strings, return their sum (also a binary string).\nFor example,\na = &quot;11&quot;\nb = &quot;1&quot;\nReturn &quot;100&quot;.\n\nclass solution&#123;  public String addBinaires(String a, String b)&#123;    int i = a.length()-1;    int j = b.length()-1;    StringBuilder result = new StringBuilder();    int carry = 0;    while( i&gt;=0 || j&gt;=0)&#123;      int sum = carry;      if(i&gt;=0)&#123;        sum += a.charAt(i--) - &#x27;0&#x27;;      &#125;      if(j&gt;=0)&#123;        sum += b.charAt(j--) - &#x27;0&#x27;;      &#125;      result.append(sum%2);      carry = sum / 2;    &#125;    if(carry != 0)&#123;      result.append(carry);    &#125;    return result.reverse().toString();  &#125;&#125;\n\n加法问题从后往前遍历数组\n有进位时设置一个carry\nStringBuilder\n\n","categories":["leetcode"]},{"title":"leetcode 7 Reverse Integer","url":"/leetcode/leetcode-solution-7/","content":"7. Reverse Integer\n\nGiven a 32-bit signed integer, reverse digits of an integer.\nExample 1:\nInput: 123Output:  321\nExample 2:\nInput: -123Output: -321\nExample 3:\nInput: 120Output: 21\nNote:\nAssume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n\n将int类型的数字翻转过来。按最简单的模10处理。\n注意：倒转过来的时候，可能会导致溢出问题。\nint类型的范围是[-65536, 65535]\n例如：\t一个数为10009，倒过来为90001，就会导致溢出。\n​\t\t同理一个数为-10009，同样也会导致溢出。\n所以需要问清楚，当溢出时返回结果是什么。\n\nclass Solution &#123;  public int reverse(int x) &#123;      long result = 0;      while (x != 0)&#123;          int tail = x % 10;          result = result*10 + tail;          if (result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE)&#123;              return 0;          &#125;          x = x/10;      &#125;      return (int) result;  &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode  73 Set Matrix zeros","url":"/leetcode/leetcode-solution-73/","content":"Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.\nFollow up:\nDid you use extra space?\nA straight forward solution using O(mn) space is probably a bad idea.\nA simple improvement uses O(m + n) space, but still not the best solution.\nCould you devise a constant space solution?\n\nclass Solution &#123;    public void setZeroes(int[][] matrix) &#123;        if(matrix == null || matrix.length == 0) return ;        boolean firstRow = false;        boolean firstCol = false;                for(int i=0; i&lt;matrix.length; i++)&#123;            for(int j=0; j&lt;matrix[0].length; j++)&#123;                if(matrix[i][j] == 0)&#123;                    if(i == 0) firstRow = true;                    if(j == 0) firstCol = true;                                        matrix[0][j] = 0;                    matrix[i][0] = 0;                &#125;            &#125;        &#125;        for(int i=1; i&lt;matrix.length; i++)&#123;            for(int j=1; j&lt;matrix[0].length; j++)&#123;                if(matrix[i][0] == 0 || matrix[0][j] == 0)&#123;                    matrix[i][j] = 0;                &#125;            &#125;        &#125;                if(firstRow)&#123;            for(int i=0; i&lt;matrix[0].length; i++)&#123;                matrix[0][i] = 0;            &#125;        &#125;        if(firstCol)&#123;            for(int i=0; i&lt;matrix.length; i++)&#123;                matrix[i][0] = 0;            &#125;        &#125;        return ;    &#125;&#125;\n\n如果matrix[i][j] == 0， 则将第i行的第一个元素和第j列的第一个元素置0\n扫描第一行和第一列，将对应的行和列置0\n注意第一行和第一列需要特殊处理。\n\n","categories":["leetcode"]},{"title":"leetcode  72 Search 2D Matrix","url":"/leetcode/leetcode-solution-74/","content":"Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n\nIntegers in each row are sorted from left to right.\nThe first integer of each row is greater than the last integer of the previous row.\n\nFor example,\nConsider the following matrix:\n[  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]\nGiven target = 3, return true.\n\nclass Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        if(matrix == null || matrix.length == 0) return false;        int m = matrix.length;        int n = matrix[0].length;                int start = 0;        int end = m-1;        while(start &lt; end)&#123;            int mid = start + ((end - start + 1)&gt;&gt;1);            if(matrix[mid][0] &lt;= target) start = mid;            else end = mid-1;        &#125;        int row = start;                start = 0;        end = n-1;        while(start &lt;= end)&#123;            int mid = start + ((end - start)&gt;&gt;1);            if(matrix[row][mid] == target)&#123;                return true;            &#125;            if(start == end) return false;            else if(matrix[row][mid] &lt; target) start = mid + 1;            else end = mid;         &#125;        return false;    &#125;&#125;\n\n运用两次二分查找的方法先确定元素所在行数，然后在该行进行查找。\n注意返回false的情况。\n\n\nclass Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        if(matrix == null || matrix.length == 0) return false;        int i = 0;        int j = matrix[0].length-1;        while(i &lt; matrix.length &amp;&amp; j &gt;= 0)&#123;            if(matrix[i][j] == target) return true;            else if(matrix[i][j] &lt; target) i++;            else j--;        &#125;        return false;    &#125;&#125;\n\nclass Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        if(matrix == null || matrix.length == 0) return false;                int m = matrix.length;        int n = matrix[0].length;                int start = 0;        int end = m * n - 1;                while(start &lt;= end)&#123;            int mid = start + ((end - start)&gt;&gt;1);            if(matrix[mid/n][mid%n] == target) return true;            else if(matrix[mid/n][mid%n] &lt; target) start = mid + 1;            else end = mid-1;        &#125;        return false;    &#125;&#125;\n\n直接将整个二维数组看成是一个一维数组，直接一次二分搜索就好\n\n","categories":["leetcode"]},{"title":"leetcode 746 Min Cost Climbing Stairs","url":"/leetcode/leetcode-solution-746/","content":"746. Min Cost Climbing Stairs\n\nOn a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\nOnce you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\nExample 1:\nInput: cost = [10, 15, 20]Output: 15Explanation: Cheapest is start on cost[1], pay that cost and go to the top.\nExample 2:\nInput: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].\nNote:\n\ncost will have a length in the range [2, 1000].\nEvery cost[i] will be an integer in the range [0, 999].\n\n\n动态规划问题\n定义一个dp[n]，表示在包含n个阶梯的cost时，最小的总cost。\ndp[i] = min( dp[i-1]+cost[i] , dp[i-2]+cost[i])，对于第i个阶梯，可以从第i-1个阶梯或者是第i-2个阶梯过来，\n最终返回的时第n个阶梯和第n-1个阶梯中cost小的那一个，返回max(dp[n], dp[n-1])。\n\nclass solution&#123;  public int minCostClimbingStairs(int[] cost)&#123;    if (cost.length == 0)&#123;      return 0;    &#125;    int n = cost.length;    int[] dp = new int[n];    dp[0] = cost[0];    dp[1] = cost[1];    for (int i=2; i&lt;n; i++)&#123;      dp[i] = Math.min(dp[i-1]+cost[i], dp[i-2]+cost[i]);    &#125;    return Math.min(dp[n-1], dp[n-2]);  &#125;&#125;\n\nsolution区域更简洁的版本：\n空间开销更小，达到了O(1)\nclass Solution &#123;    public int minCostClimbingStairs(int[] cost) &#123;        int f1 = 0, f2 = 0;        for (int i = cost.length - 1; i &gt;= 0; --i) &#123;            int f0 = cost[i] + Math.min(f1, f2);            f2 = f1;            f1 = f0;        &#125;        return Math.min(f1, f2);    &#125;&#125;\nclass Solution(object):    def minCostClimbingStairs(self, cost):        f1 = f2 = 0        for x in reversed(cost):            f1, f2 = x + min(f1, f2), f1        return min(f1, f2)\n","categories":["leetcode"]},{"title":"leetcode  75 Sort Colors","url":"/leetcode/leetcode-solution-75-Sort-Colors/","content":"Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nNote:\nYou are not suppose to use the library’s sort function for this problem.\n\nclass Solution &#123;    public void sortColors(int[] nums) &#123;        int sum = 0;        int blue = 0;        int red = 0;        int white = 0;        for(int i=0; i&lt;nums.length; i++)&#123;            sum += nums[i];            if(nums[i] == 2)&#123;                blue += 1;            &#125;        &#125;        white = sum - blue*2;        red = nums.length - blue - white;        int i = 0;        while(i&lt;nums.length)&#123;            if(i&lt;red)&#123;                nums[i] = 0;            &#125;            else if(i&lt;red + white)&#123;                nums[i] = 1;            &#125;            else&#123;                nums[i] = 2;            &#125;            i ++;        &#125;    &#125;&#125;\n\n数出和是多少，2有多少个，从而计算出1有多少个，0有多少个，重新构建nums即可\n\n\nclass Solution &#123;    public void sortColors(int[] nums) &#123;        int zero = 0;        int two = nums.length-1;        for(int i=0; i&lt;=two; i++)&#123;            if(nums[i] == 0)&#123;                swap(nums, i, zero);                zero ++;            &#125;            else if(nums[i] == 2)&#123;                swap(nums, i, two);                two --;                i --;            &#125;        &#125;    &#125;    public void swap(int[] nums, int i, int j)&#123;        int t = nums[i];        nums[i] = nums[j];        nums[j] = t;    &#125;&#125;\n\nzero指向第一个应该放0的位置\ntwo指向第一个放2的位置\ni从0到two，如果为0，和zero兑换位置，如果为2，和two兑换位置，值得注意的是缓过来的需要再次比较，导致i需要–。\n\n为什么zero置换后不需要i–？因为换过来的必然是1.\n\n\n\npython:\n\n","categories":["leetcode"]},{"title":"leetcode  78 Subset","url":"/leetcode/leetcode-solution-78/","content":"\nGiven a set of distinct integers, nums, return all possible subsets (the power set).\nNote: The solution set must not contain duplicate subsets.\nFor example,\nIf nums = [1,2,3], a solution is:\n&gt;[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []&gt;]\n\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;        int total = 1 &lt;&lt; nums.length;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();        for(int i=0; i&lt;total; i++)&#123;            ArrayList&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;();            for(int j=0; j&lt;nums.length; j++)&#123;                if(((i&gt;&gt;j)&amp;1) == 1)&#123;                    t.add(nums[j]);                &#125;            &#125;            ans.add(t);        &#125;        return ans;    &#125;&#125;\n\n用位操作来实现\n1 &lt;&lt; nums.length 为ans的数目。即2^nums.length\n(i&gt;&gt;j &amp; 1) 用来判断第i为是否要取\n\neg. i = 4，即 i：0100\n\ni&gt;&gt;0 &amp; 1 ==0 表示第0位不取\ni&gt;&gt;1 &amp; 1 == 0 表示第1位不取\ni&gt;&gt;2 &amp; 1 == 1 表示第2位去\n\n\n\n\n\n\n","categories":["leetcode"]},{"title":"leetcode  79 word search","url":"/leetcode/leetcode-solution-79/","content":"Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nFor example,\nGiven board =\n[  [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],  [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],  [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]]\nword = &quot;ABCCED&quot;, -&gt; returns true,\nword = &quot;SEE&quot;, -&gt; returns true,\nword = &quot;ABCB&quot;, -&gt; returns false.\n\nclass Solution &#123;    public boolean exist(char[][] board, String word) &#123;        if(board == null || board.length == 0) return false;        int m = board.length;        int n = board[0].length;        for(int i=0; i&lt;m; i++)&#123;            for(int j=0; j&lt;n; j++)&#123;                if(search(board, word, i, j, 0))&#123;                    return true;                &#125;            &#125;        &#125;        return false;    &#125;    public boolean search(char[][] board, String word, int i, int j, int pos)&#123;        if(i&lt;0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length)            return false;        if(board[i][j] != word.charAt(pos)) return false;        if(board[i][j] == word.charAt(pos) &amp;&amp; pos == word.length()-1)            return true;        board[i][j] = &#x27; &#x27;;        boolean result =             search(board, word, i-1, j, pos+1) ||            search(board, word, i+1, j, pos + 1) ||            search(board, word, i, j-1, pos + 1) ||            search(board, word, i, j+1, pos + 1);        board[i][j] = word.charAt(pos);        return result;    &#125;&#125;\n\n运用递归的思想，判断第i行第j列的字符是否等于当前判断字符，若等于，则判断(i,j)周围四个点是否等于下一个字符，依次递归，知道最后一个字符若相等，返回true,否则若i,j超过board返回或者不相等，返回False；\n\n","categories":["leetcode"]},{"title":"leetcode 8 String to Integer (atoi)","url":"/leetcode/leetcode-solution-8/","content":"8. String to Integer (atoi)\n\nImplement atoi to convert a string to an integer.\nHint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.\n\n注意异常的输入：\n“”\n“acbd”\n“±123&quot;\n”   111&quot;\n“0&quot;\n”  “\n“±±”\n”-1&quot;\n&quot;  -0012a42&quot;\n&quot;-11919730356x&quot;\n&quot;999999999999999999999999999999&quot;\n“9223372036854775809”\n class Solution &#123; \tpublic int myAtoi(String str) &#123;      // 判断是否是空的字符串      if (str.length() == 0)&#123;          return 0;      &#125;      int index = 0;      int positive = 1;      long result = 0;      // 字符前面有可能存在空格，去掉      while(index &lt; str.length() &amp;&amp; str.charAt(index) == &#x27; &#x27; )&#123;          index ++;      &#125;      // 每一次index++操作后，要判断index是否已经超过数组范围      if (index == str.length())&#123;          return 0;      &#125;      // 一个正确的str刚开始的第一个数字应该是正负号      if(str.charAt(index) == &#x27;-&#x27; || str.charAt(index) == &#x27;+&#x27;)&#123;          positive = str.charAt(index)==&#x27;-&#x27;? -1:1 ;          index ++;      &#125;      if (index == str.length())&#123;          return 0;      &#125;      while(index &lt; str.length())&#123;        // 判断是否是数字这一段应该放在whle里面，有可能存在一段数字后出现字母的情况          if (str.charAt(index) &lt; &#x27;0&#x27; || str.charAt(index) &gt; &#x27;9&#x27; )&#123;              break;          &#125;          result = result * 10 + str.charAt(index)-&#x27;0&#x27;;\t\t// 溢出的情况，虽然用了long型result，但是输入的数字可能造成long溢出，因此应该判断溢出应该放在while里面，而不能是while外。          if(result*positive &gt; Integer.MAX_VALUE)&#123;              return Integer.MAX_VALUE;          &#125;        \tif(result*positive &lt; Integer.MIN_VALUE)&#123;            \treturn Integer.MIN_VALUE;        \t&#125;        \tindex ++;    \t&#125;      \t// 最后不要忘记乘上符号，返回的时候需要强制类型转换    \tresult = result*positive;    \treturn (int) result;\t&#125;&#125;\n\n感觉我的答案还是不够简练，这里贴上discuss区里得分最高的solution：\npublic int myAtoi(String str) &#123;    int index = 0, sign = 1, total = 0;    //1. Empty string    if(str.length() == 0) return 0;    //2. Remove Spaces    while(str.charAt(index) == &#x27; &#x27; &amp;&amp; index &lt; str.length())        index ++;    //3. Handle signs    if(str.charAt(index) == &#x27;+&#x27; || str.charAt(index) == &#x27;-&#x27;)&#123;        sign = str.charAt(index) == &#x27;+&#x27; ? 1 : -1;        index ++;    &#125;        //4. Convert number and avoid overflow    while(index &lt; str.length())&#123;        int digit = str.charAt(index) - &#x27;0&#x27;;        if(digit &lt; 0 || digit &gt; 9) break;        //check if total will be overflow after 10 times and add digit        if(Integer.MAX_VALUE/10 &lt; total || Integer.MAX_VALUE/10 == total &amp;&amp; Integer.MAX_VALUE %10 &lt; digit)            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;        total = 10 * total + digit;        index ++;    &#125;    return total * sign;&#125;\n","categories":["leetcode"]},{"title":"leetcode  84 Remove Duplicates from Sorted List II","url":"/leetcode/leetcode-solution-84/","content":"Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.\nExample 1:\nInput: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5\nExample 2:\nInput: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3\n\nSolution 1:\n\n遍历一遍数组，依次比较相邻的两个元素，同时，设定一个tag isSame 来保存上两个元素是否一样\n如果上两个元素一样，指针p q 往后移一位，继续\n如果两个元素不一样，将p加入到待返回的列表中，继续\n循环结束时，isSame中保存了最后一次的比较情况，如果最后一次结果一样，返回列表的最后需要加上null 如果最后一次结果不一样，需要将p之后的元素都添加到返回列表中。\n\nclass Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        boolean isSame = false;        ListNode dump = new ListNode(0);        ListNode t = dump;          if (head == null || head.next == null)&#123;            return head;        &#125;        ListNode p = head;        ListNode q = head.next;        while(q != null)&#123;            while (q != null &amp;&amp; p.val == q.val)&#123;                isSame = true;                p = p.next;                q = q.next;            &#125;            if (q == null)&#123;                break;            &#125;            if (isSame)&#123;                p = p.next;                q = q.next;                isSame = false;            &#125;            else &#123;                t.next = p;                t = t.next;                p = p.next;                q = q.next;            &#125;        &#125;        if (! isSame)&#123;            t.next = p;        &#125;        if  (isSame)&#123;            t.next = null;        &#125;        return dump.next;            &#125;&#125;\n\nSolution 2\n\n使用两个指针，分别保存每一数字结束的位置\n\npublic ListNode deleteDuplicates(ListNode head) &#123;        if(head==null) return null;        ListNode FakeHead=new ListNode(0);        FakeHead.next=head;        ListNode pre=FakeHead;        ListNode cur=head;        while(cur!=null)&#123;            while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123;                cur=cur.next;            &#125;            if(pre.next==cur)&#123;                pre=pre.next;            &#125;            else&#123;                pre.next=cur.next;            &#125;            cur=cur.next;        &#125;        return FakeHead.next;    &#125;\n","categories":["leetcode"]},{"title":"leetcode 88 Merge Sorted Array","url":"/leetcode/leetcode-solution-88/","content":"\n88. Merge Sorted Array\n\nGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\nNote:\nYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.\n\n最初始的想法是从前往后遍历，找到一个nums1[i] &gt; nums2[j]，把nums1从i开始后移一位。但是这样的时间复杂度较高\n再然后适用一个新的数组result[m+n]，时间复杂度为O(m+n)，但是空间复杂度也有O(m+n)\n再考虑从后往前遍历两个数组，时间复杂度为O(m+n), 空间复杂度为O(1).\nclass Solution &#123;    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;        int i = m-1;        int j = n-1;        int k = m+n-1;        while(k &gt; i &amp;&amp; k &gt; j)&#123;            if(nums1[i] &lt;= nums2[j])&#123;                nums1[k] = nums2[j];                k--;                j--;            &#125;            else&#123;                nums1[k] = nums1[i];                i--;                k--;            &#125;        &#125;      // 上面循环结束的条件是k=i或者k=j;      // 如果k=i，说明num1从第k位开始，前面的数都应该从nums1中获取，因此不需要再操作      // 如果k=j，说明num1从第k为开始，前面的数都应该从nums2中获取，因此循环将nums2中的数赋值给nums1        while(j&gt;=0)&#123;            nums1[k] = nums2[j];            k--;            j--;        &#125;    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode  49 Group Anagrams","url":"/leetcode/leetcode-solution-49-Group-Anagrams/","content":"Given an array of strings, group anagrams together.\nFor example, given: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],\nReturn:\n[  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],  [&quot;nat&quot;,&quot;tan&quot;],  [&quot;bat&quot;]]\n\n\n对每一个String，转换成char[]，利用sort进行排序。\n利用给一个hashmap，对应出第i个String所在的组别。\n\n\nclass Solution &#123;    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        if(strs.length == 0) return null;        List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;List&lt;String&gt;&gt;();                Map&lt;String, Integer&gt; m = new HashMap&lt;String, Integer&gt; ();                int count = 0;        for(String i : strs)&#123;            char[] arrayString = i.toCharArray();            Arrays.sort(arrayString);            if(m.containsKey(String.valueOf(arrayString)))&#123;                int index = m.get(String.valueOf(arrayString));                List&lt;String&gt; t = ans.get(index);                t.add(i);                                ans.remove(index);                ans.add(index, t);                            &#125;            else&#123;                List&lt;String&gt; t = new ArrayList&lt;String&gt; ();                t.add(i);                ans.add(t);                m.put(String.valueOf(String.valueOf(arrayString)),count);                count++;            &#125;                    &#125;        return ans;    &#125;&#125;\n class Solution(object):   def groupAnagrams(self, strs):       &quot;&quot;&quot;       :type strs: List[str]       :rtype: List[List[str]]       &quot;&quot;&quot;       dic = &#123;&#125;       for i in strs:           counter = str(sorted(i))           if counter not in dic:               dic[counter] = []           dic[counter].append(i)       ans = []       for i in dic.keys():           ans.append(dic[i])       return ans\n","categories":["leetcode"]},{"title":"leetcode 9 Palindrome Number","url":"/article/leetcode-solution-9/","content":"9. Palindrome Number\n\nDetermine whether an integer is a palindrome. Do this without extra space.\n\n\n用一个变量reverse来保存翻转的x部分\nreverse只保存了一般\n终止条件为x的大小小于reverse\n例如：\n\n1234 终止条件：x = 12 y = 32\n3223 终止条件：x = 32 y = 32  √\n123  终止条件： x = 1  y = 32\n121 终止条件： x = 1  y = 12 √\n\n\n\nclass Solution &#123;  public boolean isPalindrome(int x) &#123;    // 输入特例判断，小于0不是回文数字    if (x &lt; 0)&#123;          return false;      &#125;    // 输入特例判断，大于0但是是10的整数倍的数字不是回文      if(x &gt; 0 &amp;&amp; x%10 == 0)&#123;          return false;      &#125;      int reverse=0;      while(x &gt; reverse)&#123;          reverse = reverse*10 + x%10;          x = x/10;      &#125;      return (x==reverse)||(x==reverse/10);  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode  92 Reverse Linkedlist II","url":"/leetcode/leetcode-solution-92/","content":"Reverse a linked list from position m to n. Do it in one-pass.\nNote: 1 ≤ m ≤ n ≤ length of list.\nExample:\nInput: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL\npublic  ListNode reverseBetween(ListNode head, int m, int n) &#123;   ListNode prev = new ListNode(0);    ListNode dump = new ListNode(0);    dump.next = head;    prev.next = head;    int start = m;    ListNode position = head;    int k = 1;    while(k &lt; m)&#123;        position = position.next;        prev = prev.next;        k ++;    &#125;    while(m &lt; n)&#123;        ListNode temp = position.next;        position.next = temp.next;        temp.next = prev.next;        prev.next = temp;        m ++;    &#125;    if ( start == 1)&#123;        return prev.next;    &#125;    return head;&#125;\n","categories":["leetcode"]},{"title":"leetcode  90 Subsets II","url":"/leetcode/leetcode-solution-90-Subsets-II/","content":"Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\nNote: The solution set must not contain duplicate subsets.\nFor example,\nIf nums = [1,2,2], a solution is:\n[  [2],  [1],  [1,2,2],  [2,2],  [1,2],  []]\n\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if(nums.length == 0) return ans;        Arrays.sort(nums);        backtrace(ans, new ArrayList&lt;Integer&gt;(), nums, 0);        return ans;    &#125;    public void backtrace(List&lt;List&lt;Integer&gt;&gt; ans, ArrayList&lt;Integer&gt; t, int[] nums, int start)&#123;        if(!ans.contains(t))            ans.add(new ArrayList&lt;Integer&gt;(t));        for(int i=start; i&lt;nums.length; i++)&#123;            t.add(nums[i]);            backtrace(ans, t, nums, i+1);            t.remove(t.size()-1);        &#125;    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode  93 Restore IP Addresses","url":"/leetcode/leetcode-solution-93-Restore-IP-Addresses/","content":"\nGiven a string containing only digits, restore it by returning all possible valid IP address combinations.\nFor example:\nGiven &quot;25525511135&quot;,\nreturn [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. (Order does not matter)\n\nclass Solution &#123;    public List&lt;String&gt; restoreIpAddresses(String s) &#123;        List&lt;String&gt; ans = new ArrayList&lt;String&gt;();        StringBuilder ip = new StringBuilder();                for(int A = 1; A &lt;=3; A++)&#123;            for(int B = 1; B &lt;=3; B++)&#123;                for(int C = 1; C &lt;=3; C++)&#123;                    for(int D=1; D &lt;=3; D++)&#123;                        if(A + B + C + D == s.length())&#123;                            int a = Integer.parseInt(s.substring(0, A));                            int b = Integer.parseInt(s.substring(A, A+B));                            int c = Integer.parseInt(s.substring(A+B, A+B+C));                            int d = Integer.parseInt(s.substring(A+B+C));                            if(a&lt;=255 &amp;&amp; b&lt;=255 &amp;&amp; c&lt;=255 &amp;&amp; d&lt;= 255)&#123;                                ip.append(a);                                ip.append(&#x27;.&#x27;);                                ip.append(b);                                ip.append(&#x27;.&#x27;);                                ip.append(c);                                ip.append(&#x27;.&#x27;);                                ip.append(d);                                                                if(ip.length() == s.length() + 3)&#123;                                    ans.add(ip.toString());                                &#125;                                ip.delete(0, ip.length());                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode solution 96 Unique Binary Search Trees","url":"/leetcode/leetcode-solution-96-Unique-Binary-Search-Trees/","content":"Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?\nFor example,\nGiven n = 3, there are a total of 5 unique BST’s.\n1         3     3      2      1 \\       /     /      / \\      \\  3     2     1      1   3      2 /     /       \\                 \\2     1         2                 3\n\nclass Solution &#123;    public int numTrees(int n) &#123;        int[] dp = new int[n+1];        dp[0] = 1;        dp[1] = 1;        for(int i=2; i&lt;=n; i++)&#123;            for(int j=1; j&lt;=i; j++)&#123;                dp[i] += dp[j-1] * dp[i-j];            &#125;        &#125;        return dp[n];    &#125;&#125;\n\n对于n = 5\n1 2 3 4 5\ndp[0] = 1\ndp[1] = 1\ndp[2] =当1为根节点和当2为更节点之和\ndp[4]\n\n1为根节点 + 2为根节点 + 3为根结点 + 3为根节点\n当j为根节点时， 可能的组合为 左子树的可能组合*右子树的可能组合\n假设跟个节点为2， 左子树 1  右子树 3 4 ，而3 4 等价于 1 2\n\n\n\n","categories":["leetcode"]},{"title":"leetcode solution 98 Valid Binary Search Tree","url":"/leetcode/leetcode-solution-96/","content":"Given a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than the node’s key.\nThe right subtree of a node contains only nodes with keys greater than the node’s key.\nBoth the left and right subtrees must also be binary search trees.\n\nExample 1:\nInput:    2   / \\  1   3Output: true\nExample 2:\n    5   / \\  1   4     / \\    3   6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node&#x27;s value             is 5 but its right child&#x27;s value is 4.\n\n","categories":["leetcode"]},{"title":"leetcode  97 isInterleave","url":"/article/leetcode-solution-97/","content":"Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\nExample 1:\nInput: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;Output: true\nExample 2:\nInput: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;Output: false\n\nclass Solution()&#123;    \tpublic boolean isInterleave(String s1, String s2, String s3) &#123;        if (s1.length() + s2.length() != s3.length())&#123;            return false;        &#125;        boolean[][] matrix = new boolean[s1.length()+1][s2.length()+1];        matrix[0][0] = true;        for (int i=1; i&lt;s1.length()+1; i++)&#123;            if (s3.charAt(i-1) == s1.charAt(i-1) &amp;&amp; matrix[i-1][0])&#123;                matrix[i][0] = true;            &#125;        &#125;        for (int i=1; i&lt;s2.length()+1; i++)&#123;            if (s3.charAt(i-1) == s2.charAt(i-1) &amp;&amp; matrix[0][i-1])&#123;                matrix[0][i] = true;            &#125;        &#125;        for (int i=1; i&lt;s1.length()+1; i++)&#123;            for (int j=1; j&lt;s2.length()+1; j++)&#123;                if (s3.charAt(i+j-1) == s1.charAt(i-1) &amp;&amp; matrix[i-1][j])&#123;                    matrix[i][j] = true;                &#125;                if (s3.charAt(i+j-1) == s2.charAt(j-1) &amp;&amp; matrix[i][j-1])&#123;                    matrix[i][j] = true;                &#125;            &#125;        &#125;        return matrix[s1.length()][s2.length()];    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 98 Valid Binary Search Tree","url":"/leetcode/leetcode-solution-98/","content":"Given a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than the node’s key.\nThe right subtree of a node contains only nodes with keys greater than the node’s key.\nBoth the left and right subtrees must also be binary search trees.\n\nExample 1:\nInput:    2   / \\  1   3Output: true\nExample 2:\n    5   / \\  1   4     / \\    3   6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node&#x27;s value             is 5 but its right child&#x27;s value is 4.\n\n\n使用一个stack，每遇到一个node，一直向左走，将经过的元素加入栈中\npop出一个元素，使之为root，标记该root为pre，继续下一次向左走，此时，比较每一个经过的值和pre的大小\n\nclass Solution &#123;    public boolean isValidBST(TreeNode root) &#123;        if(root == null)&#123;            return true;        &#125;        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();        TreeNode pre = null;        while(!s.isEmpty() || root != null)&#123;            while(root != null)&#123;                s.add(root);                root = root.left;            &#125;                        root = s.pop();            if (pre != null &amp;&amp; pre.val &gt;= root.val)&#123;                return false;            &#125;            pre = root;            root = root.right;        &#125;        return true;    &#125;&#125;\n","categories":["leetcode"]},{"title":"leetcode 94 Binary Tree Inorder Traversal","url":"/leetcode/leetcode-soution-94/","content":"Given a binary tree, return the inorder traversal of its nodes’ values.\nExample:\nInput: [1,null,2,3]   1    \\     2    /   3Output: [1,3,2]\nFollow up: Recursive solution is trivial, could you do it iteratively?\n\n\n\nRecursive solution:\nclass Solution&#123;\tpublic static List&lt;Integer&gt; inorderTraversalRecursive(TreeNode root) &#123;        List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();        helper(ans, root);        return ans;    &#125;    public static void helper(List&lt;Integer&gt; ans, TreeNode root) &#123;        if (root != null)&#123;            helper(ans, root.left);            ans.add(root.val);            helper(ans, root.right);        &#125;    &#125;&#125;\n\n\nIteritive solution\nclass Solution &#123;    public List&lt;Integer&gt; inorderTraversal(TreeNode root)&#123;        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();        List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();        while(!s.isEmpty() || root != null)&#123;            while(root != null)&#123;                s.add(root);                root = root.left;                &#125;            root = s.pop();            ans.add(root.val);            root = root.right;                    &#125;        return ans;    &#125;&#125;\n\n\n","categories":["leetcode"]},{"title":"leetcode wordSearch","url":"/article/leetcode-wordSearch/","content":"public class wordSearch &#123;    /**     * Given a 2D board and a word, find if the word exists in the grid.     *     * The word can be constructed from letters of sequentially adjacent cell,     * where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.     *     * Example:     *     * board =     * [     *   [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],     *   [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],     *   [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]     * ]     *     * Given word = &quot;ABCCED&quot;, return true.     * Given word = &quot;SEE&quot;, return true.     * Given word = &quot;ABCB&quot;, return false.     */    public boolean exist(char[][] board, String word) &#123;        if (board == null || board[0].length == 0) return false;        int m = board.length;        int n = board[0].length;        boolean[][] visited = new boolean[m][n];        for (int i=0; i&lt;m; i++) &#123;            for (int j=0; j&lt;n; j++) &#123;                if (board[i][j] == word.charAt(0)) &#123;                    if (dfs(word, board, visited, m, n, i, j, 0)) &#123;                        return true;                    &#125;                &#125;            &#125;        &#125;        return false;    &#125;    public boolean dfs(String word, char[][] board, boolean[][] visited, int m, int n, int i, int j, int index) &#123;        if (i &lt; 0 || j &lt; 0 || i &gt;= m || j&gt;=n || visited[i][j] || board[i][j]!=word.charAt(index))            return false;        if (index == word.length()-1) return true;        visited[i][j] = true;        boolean ans =  dfs(word, board, visited, m, n, i+1, j, index+1)                || dfs(word, board, visited, m, n, i-1, j, index+1)                || dfs(word, board, visited, m, n, i, j+1, index+1)                || dfs(word, board, visited, m, n, i, j-1, index+1) ;        visited[i][j] = false;        return ans;    &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode 73 Set Matrix Zeroes","url":"/article/leetcode-zeroMatrix/","content":"Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.\nExample 1:\nInput: [  [1,1,1],  [1,0,1],  [1,1,1]]Output: [  [1,0,1],  [0,0,0],  [1,0,1]]\nExample 2:\nInput: [  [0,1,2,0],  [3,4,5,2],  [1,3,1,5]]Output: [  [0,0,0,0],  [0,4,5,0],  [0,3,1,0]]\nFollow up:\n\nA straight forward solution using O(mn) space is probably a bad idea.\nA simple improvement uses O(m + n) space, but still not the best solution.\nCould you devise a constant space solution?\n\n\npublic class zeroMatrix &#123;  public void setZero(int[][] matrix)&#123;    int m = matrix.length;    int n = matrix[0].length;    int firstRow = 1;    int firstColum = 1;    for (int i=0; i&lt;m; i++) &#123;      if (matrix[i][0] == 0) firstColum = 0;    &#125;    for (int i=0; i&lt;n; i++) &#123;      if (matrix[0][i] == 0) firstRow = 0;    &#125;    for (int i=1; i&lt;m; i++) &#123;      for (int j=1; j&lt;n; j++) &#123;        if (matrix[i][j] == 0) &#123;          matrix[0][j] = 0;          matrix[i][0] = 0;        &#125;      &#125;    &#125;    for (int i=1; i&lt;n; i++) &#123;      for (int j=1; j&lt;n; j++) &#123;        if (matrix[0][j] == 0 || matrix[i][0] == 0) &#123;          matrix[i][j] = 0;        &#125;      &#125;    &#125;    for (int i=0; i&lt;m; i++) &#123;      if (firstColum == 0) &#123;        matrix[i][0] = 0;      &#125;    &#125;    for (int i=0; i&lt;n; i++) &#123;      if (firstRow == 0) &#123;        matrix[0][i] = 0;      &#125;    &#125;  &#125;&#125;\n","tags":["leetcode"]},{"title":"leetcode solution 680 Valid Palindrome II","url":"/leetcode/leetocde-solution-680/","content":"Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.\nExample 1:\nInput: &quot;aba&quot;Output: True\nExample 2:\nInput: &quot;abca&quot;Output: TrueExplanation: You could delete the character &#x27;c&#x27;.\nNote:\n\nThe string will only contain lowercase characters a-z. The maximum length of the string is 50000.\n\n\nclass Solution &#123;    public boolean validPalindrome(String s) &#123;        int l = 0;        int r = s.length()-1;        while(l &lt; r)&#123;            if(s.charAt(l) != s.charAt(r))&#123;                return isPalindrome(s, l+1, r) || isPalindrome(s, l, r-1);            &#125;            l++;            r--;        &#125;        return true;    &#125;    public boolean isPalindrome(String s, int l, int r)&#123;        while(l&lt;r)&#123;            if(s.charAt(l) != s.charAt(r))&#123;                return false;            &#125;            else&#123;                l++;                r--;            &#125;        &#125;        return true;    &#125;&#125;\n\nThe basic idea is to compare the first ant the last character of string s . if s is a palindrome after remove one single letter. we can know that it can be seen as insert a letter into a palindrome.\nso, we can consitently compare the first and the last letter of s , if they’re not the same, we judge the two substring which is the original string removing one of the ends letter.\n\naabbcaa : we consistently judge abbca -&gt; bbc -&gt; bb -&gt; ba\n\n\n\n","categories":["leetcode"]},{"title":"pytorch notes","url":"/pytorch/pytorch-notes/","content":"数据集加载流程：\n\n\ntorchvision.datasets中已经包含众多数据集，先建立一个数据集对。\nmnist_train = torchvision.datasets.MNIST(root=&quot;\\data&quot;, train=True, download=True, transform= transform)\n不过在建立对象的时候，需要指定transform来确定对原始数据集中的图片的转换过程。\ntransform = torchvision.transforms.ToTensor() # 定义transform为ToTensor(),将原始PLT数据转换为Tensor\n又例如：\ntransform = transforms.Compose(    [transforms.ToTensor(),     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]) # 定义transform为这一系列步骤，先将图片转换为tensor，在将其进行归一化，第一个括号代表将RGB三通道的数据均值都归一化到0.5，第二个括号代表将均方差同样也归一化到0.5\n\n\n使用torch.utils.data中的DataLoader来加载之前定义好的数据集对象\ntrain_loader = DataLoader(mnist_train, batch_size=8, shuffle=True, num_workers=4)\n\n\n读取DataLoader中的数据，一般在训练的时候，使用\nfor batch, (img, label) in enumerate(train_loader):\n在测试时，使用\nfor img, label in test_loader:\n\n\n\n图片显示：\n 需要导入`matploitlab`来帮助显示图片\n\n直接通过```for img, label in train_loader``` 得到的`img`的维度是四维的 [ $ batch\\_size  \\times channels \\times width \\times hight$ ], 例如，从`Mnist`中读取的数据维度为： `torch.Size([8, 1, 28, 28])` 表示这个batch中有八张图片，由于MNIST中的图片为灰度图，因此`channel`为1。\n\n要显示单张图片，\n\nimg = img[0] # 取出第一张图片plt.imshow(img[0], cmap=&quot;gray&quot;) # 灰度图像显示时，接受的图片维度为（width，hight），因此这里再次取[0]，使(channel, width, hight)降为(width， hight)\n要显示单张图片：\n\nimg = torchvision.utils.make_grid(img).numpy()plt.imshow(np.transpose(img, (1, 2, 0))) #这里的（1， 2， 0） 指的是，将原始维度（channel， width， hight）转换为 （width， hight， channel）\n","categories":["pytorch"]},{"title":"leetcode  45 Jump Game II","url":"/article/leetcode-solution-45/","content":"Given an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nYour goal is to reach the last index in the minimum number of jumps.\nFor example:\nGiven array A = [2,3,1,1,4]\nThe minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)\nNote:\nYou can assume that you can always reach the last index.\n\nclass Solution &#123;    public int jump(int[] nums) &#123;        int currentMax = 0;        int count = 0;        int lastMax = 0;        for (int i=0; i&lt;nums.length-1; i++)&#123;            currentMax = Math.max(currentMax, i+nums[i]);            if(lastMax == i)&#123;                lastMax = currentMax;                count ++;            &#125;        &#125;        return count;    &#125;&#125;\n\ncurrentMax means currently the longest distance we can reach.\nlastMax means currently, the longest distance to reach position i\n\n","tags":["leetcode","数组"]},{"title":"《Beyond Trade-off: Accelerate FCN-based Face Detector with Higher Accuracy》论文解读","url":"/article/%C2%B0%E2%88%82Beyond-Trade-off-Accelerate-FCN-based-Face-Detector-with-Higher-Accuracy%C2%B0%E2%88%91%C2%AC%E2%82%AC%C5%92%C6%92%CE%A9%E2%80%9A%E2%88%82%C2%A1/","content":"论文提出将图片中人脸的搜索空间分解为两个正交方向的向量，尺度方向和空间方向，尺度方向，进而提出了尺度估计（Scale Estimation）和空间注意力提议机制（Spatial attention proposal， $S^2AP$）。在我们知道粗略的空间位置和人脸尺度时，我们能够将注意力集中在某些特定的范围和位置，这样一来，搜索空间将得到有效的降低。\n尺度方向：保证了Image Pyramid中，只有可能性高的层会被FCN注意。\n空间方向：使得网络能快速排除大量的背景。\n在很多目标检测系统中，使用的是两阶段的方法，先使用RPN（Region Proposal Network）来找到ROI(Region of Interest)，然后在第二阶段进一步对ROI进行回归和分类。突出的算法有：Faster-RCNN、R-FCN等。这些方法具有较高的召回率和精确度，但是，由于训练这样的二阶段的网络计算代价非常的大。\n对于这些传统的两阶段方案，有人提出了Single-scale技术，使用Image Pyramid，同样也是时间消耗巨大的。\n其次就是端到端的方案，例如YOLO，SSD等，YOLO直接对BB进行回归，对目标进行分类。\n\n给定一张图片，系统首先预测人脸的尺度和所在的位置，然后，图片以及定量的信息将会将会被输入到Mask-FCN\n$S^2AP$\nScale Attention\n$S^2AP$是一个用于预检测的快速注意力模型。首先，在BoundingBox的定义上，没有采用原始的人工标注的Bounding Box，而是通过5个人脸标记点（Landmark）来推到出face box。\n$(x_1, y_1) , …,(x_5, y_5)$ 分别表示左眼中心，右眼中心，鼻子，左嘴角，右嘴角。\n$(p_1, q_1),…,(p_5,q_5)$ 分别表示正则化后的人脸标注，变换规则为：\n$$\np_i = \\frac{x_i-X1}{w} \\\nq_i = \\frac{y_i - Y_1}{h}\n$$\n可以知道，原始的坐标经过这样的变换之后，得到的坐标范围均在0~1之间。\n其中，X1，Y1表示人工标注的BoundingBox最右上角的坐标，w、h分别表示BB的长和高。\n$(mp_i, mq_i)$ 指的是整个数据集中，所有$(p_i, q_i)$ 的平均值。\n上面所述的操作，我们可以定义一个相似度转换矩阵$T$， 通过学习这个矩阵的方式，将原始坐标的点映射到新坐标系上。\n$$\n\\begin{bmatrix}\nmp_i \\\nmq_i \\\n1\n\\end{bmatrix}^T\n=\n\\begin{bmatrix}\nx_i \\\ny_i \\\n1\n\\end{bmatrix}^T T\n$$\n这样一来，反过来，我们可以求得在映射后左上角和有下角的坐标（0,0）（1,1）在原始坐标系中的坐标$(x_{tl}, y_{tl}), (x_{dr}, y_{dr})$位置：\n$$\n\\begin{bmatrix}\nx_{tl} \\\ny_{tl} \\\n1\n\\end{bmatrix}\n^T T\n=\n\\begin{bmatrix}\n0 \\\n0 \\\n1\n\\end{bmatrix}^T\n$$\n$$\n\\begin{bmatrix}\nx_{dr} \\\ny_{dr} \\\n1\n\\end{bmatrix}\n^T T\n=\n\\begin{bmatrix}\n1 \\\n1 \\\n1\n\\end{bmatrix}^T\n$$\n因此，有：\n$$\n\\begin{bmatrix}\nx_{tl} &amp; x_{tl} \\\ny_{tl} &amp; y_{tl} \\\n1 &amp; 1\n\\end{bmatrix}\n^T\n=\n\\begin{bmatrix}\n0 &amp; 1 \\\n0 &amp; 1\\\n1 &amp; 1\n\\end{bmatrix}^T\nT^{-1}\n$$\n对于一张给定的人脸图片，人脸的尺寸$x = \\sqrt{(x_{dr}-x_{tl})*(y_{dr}-y_{tl})}$\n$S^2AP$ 的输出是一系列的特征图：$F_b (b \\in [1,…,m])$ ，每一个特征图负责一个尺寸人脸的特征的提取。因此，对于不同尺寸的人脸$x$， 作者提取了人脸尺度对应特征图下标的对应关系\n$$\nb = 10 [\\log_2(\\frac{x}{L_{max}} \\times S_{max})-4]\n$$\n其中，$L_{max}$ 是图片的长宽中，较长的一遍的大小，$S_{max}$ 是预定义的一个最长的长度，定义为1024\nSpatical Attention\n","tags":["Face"]},{"title":"《Discriminative Deep Hashing for Scalable Face Image Retrieval Jie》论文笔记","url":"/article/%C2%B0%E2%88%82Discriminative-Deep-Hashing-for-Scalable-Face-Image-Retrieval-Jie%C2%B0%E2%88%91%C2%AC%E2%82%AC%C5%92%C6%92%C2%B1%C2%A0%C2%BA%C2%AB/","content":"Discriminative Deep Hashing for Scalable Face Image Retrieval\n提出辨识力深度哈希网络（Discriminative Deep Hash Network）\n简单来说，可以总结为一下几点：\n\n使用卷积来提取多尺度的特征\n使用divide-and encode分治编码的方式，用来生成紧凑的哈希编码\n设计了一个损失函数来降低预测误差（prediction error)\n\n\n网络结构\n在网络结构\n\n","tags":["Face Retrieval"]},{"title":"《Direct Shape Regression Networks for End-to-End Face Alignment》论文解读","url":"/article/%C2%B0%E2%88%82Direct-Shape-Regression-Networks-for-End-to-End-Face-Alignment%C2%B0%E2%88%91%C2%AC%E2%82%AC%C5%92%C6%92%CE%A9%E2%80%9A%E2%88%82%C2%A1/","content":"该论文主要提出了Direct shape regression network (DSRN) 来直接预测人脸标记点。\n人脸对齐主要的困难在于人脸图片和相关的人脸形状之间的高度非线性对应关系。\n\n输入的图像$I$\n人脸形状$S​$\n$N$ 总共的标记点数目\n$[x_1, y_1, …,x_N,y_N]^T \\in \\R^{2N}$ 是一组标记点的实例。\n\n人脸对其的主要目标是在已知人脸语义描述的情况下，估计一些列预定义的标记点的位置。\n图片通常使用过低维的特征来表示的，但是人脸形状却包含了高度的语义信息，同时，标记的是空间相关的。\n级联回归（Cascaded Regression）是一种非直接的方法，迭代的估计形状的增量（shape increment），由于这是一种迭代的方式，如果初始点的位置没有选好的话，最中的结果很有可能卡在局部最优解上。在级联模型中，只有标记点周围的区域被传输到特征提取器，这使得人脸整体的语义信息和特征点之间的关联信息被忽略。\nDSRN由三部分组成，双卷积层（Doubly Convolutional layer）、傅里叶特征池化（Fourier feature pooling layer）和低秩学习层（Low-rank learning layer）\n\n双卷积层：\n双卷积层起源于论文：S. Zhai, Y. Cheng, Z. M. Zhang, and W. Lu. Doubly convo- lutional neural networks. In Advances in Neural Information Processing Systems, pages 1082–1090, 2016. 与传统的卷积相比，双卷积的计算量更小，在提高性能的同时，降低了参数量。\n在人脸对齐训练数据相对较小，同时，人脸的形状有很大的差异性。\n在传统的卷积层中，卷积核的大小一般都相对较小，同时，很多卷积核之间具有相关性，一个卷积核可能只是另一个卷积核的翻译版本，导致了很多的冗余。在双卷积中存在两种卷积核\n\n\n元卷积核（meta filter）\n$L’ \\times L’$\n\n\n有效卷积核（effective filter）\n$L \\times L$\n\n\n$L’ &gt; L$ ，一个双卷积中，包含$(L’-L+1)^2$ 个有效卷积核。每一组有效卷积核，都被强制成组内相关连的，即组内的每一个卷积核都是另一个卷积核的翻译版本。\n\n傅里叶池化层：\n能够获图片整体的表示，傅里叶池化层起源于核估计（Kernal approximation），可以提取出非线性特征。能够较好的处理图片和形状的非线性信息。它使用的激活函数是余弦激活函数，可以端到端的反向传播。\n在双卷积层输出的特征图$X \\in \\R^{w \\times h \\times c}$ ， 表示每个特征图的长为$w$, 高为$h$，一共有$c$ 个特征。我们用$\\bold{x} = [x_1, x_2, …, x_c]^T$ 表示每一个特征包含$x_1$到$x_c$ 这c个特征。\n\n通过监督学习，学习到${\\bold{w}, \\bold{b}}$ ，其中$\\bold{w} = [w_1, …,w_d] \\in \\R^{d \\times c}, \\bold{b} = [b_1, …,b_d]$ 非线性层：\n$$\n\\phi_i = \\cos(\\bold{w}\\bold{x}_i + \\bold{b})\n$$\n其中$\\cos(·)$ 是一个按位计算的函数$i$表示特征图$\\bold{x}$中的第$i$个位置。这样，对于一个特征图$\\bold{x}$ 都能够得到$\\phi_1, …,\\phi_p$ 个特征值，其中，$p  = w \\times h$ . 连接这些特征值，得到特征矩阵$\\bold{z} = [\\phi_1,…,\\phi_p] \\in \\R^d$\n低秩学习层：\n用于学习标记点之间的相关性，用它来代替普通情况下的全连接层。低秩学习层强制其输出共享一些局部特征，来显示的处理相关性。\n在已知整体表示$\\bold{z}$ ,通常的全连接层使用一个矩阵$M \\in \\R^{Q \\times D}, Q =2N$  ， 而此时，我们将$M$分解为两个矩阵，使得：\n$$\n\\bold{y} = M\\bold{z} =  U^TV\\bold{z}\n$$\n其中，$U \\in \\R^{P \\times Q}, V \\in \\R^{P \\times D}, P \\le Q$\n中间的低秩矩阵，使得网络的输出显式的进行了相关性的编码。\n网络结构：\n使用了四层双卷积，四层池化层，每一次卷积后使用relu激活函数，每次池化使用最大池化，size分别为：$5 \\times 5, 5 \\times 3, 3\\times 3, 3\\times 3$ ,使用标准均误差（Normalized mean error）:\n$$\nNME = \\frac{\\frac{1}{N}\\sum^N_{i=1}\\sqrt{(\\hat{x}_i-x_i)^2 + (\\hat{y_i} - y_i)^2}}{d}\n$$\n其中，d用于正则化。\n\n","tags":["Face Recognition"]},{"title":"《Partially Shared Multi-Task Convolutional Neural Network with Local Constraint for Face Attribute Learning》论文解读","url":"/article/%C2%B0%E2%88%82Partially-Shared-Multi-Task-Convolutional-Neural-Network-with-Local-Constraint-for-Face-Attribute-Learning%C2%B0%E2%88%91%C2%AC%E2%82%AC%C5%92%C6%92%CE%A9%E2%80%9A%E2%88%82%C2%A1/","content":"人脸属性学习（Face Attribute Learning）的主要目的在于学习图像的中等级的特征，这些特征是低级别特征和高级别标签的抽象结合。\nMulti-task deep CNN (MCNN) 指的是对于每一个属性，共享网络的底层，同时，对于高度相关的属性，同样共享高层的网络。MCNN将40余中属性，根据其各自的相似性，将其分为9个属性组。在初始进行split之后，每一个组相当于是相互独立的，这样的话，高层网络中，组间的信息将没有得到充分的利用。\n类似的，本文同样根据属性的位置信息，将40余中属性分为四类：\n\n\nUpper Group: Arched Eyebrows, Bags Under Eyes, Bald, Bangs, Black Hair, Blond Hair, Brown Hair, Bushy Eyebrows, Eyeglasses, Gray Hair, Narrow Eyes, Receding Hairline, Wearing Hat.\n\n\nMiddle Group: Big Nose, High Cheekbones, Pointy Nose, Rosy Cheeks, Sideburns, Wearing Earrings.\n\n\nLower Group: Big Lips, Double Chin, Goatee, Mustache, Mouth Slightly Open, No Beard, Wearing Lipstick, Wearing Necklace, Wearing Necktie.\n\n\nWhole Image Group: 5 o’Clock Shadow, Attractive, Blurry, Chubby, Heavy Makeup, Male, Oval Face, Pale Skin, Straight Hair, Smiling, Wavy Hair, Young.\n\n\n论文主要研究同时考虑 身份信息（identity information）和 属性关系（attribute relationships），论文假设充分的利用属性组之间的信息和有效的利用身份标签信息能够通过建模属性的局部集合结构的方式提升性能。\nPartially Shared Multi-task Convolutional Neu- ral Network (PS-MCNN)\n提出，通过shared network(SNet) 来学习 任务间的关系，每一个任务通过Task Specific Network(TSNets)来学习。PS-MCNN的关键对于所有的组，共享一个网络来学习共享的特征。同时，对于每一个给定的任务，指定一个网络来学习。\n\n每一层SNet在t+1时刻的输入包括SNet在t时刻的输出和其他所有TSNet在t时刻的输出。\n每一层TSNet在t+1时刻的输入包括TSNet本省在t时刻的输出以及SNet在t时刻的输出。\n\n对于任务身份信息的利用，由于属性特征通常是身份信息特征中的一部分，如果直接将身份信息作为人脸的一个属性的话，这样就没充分利用到身份信息。对此，作者提出来，使用局部学习限制，来最小化同一个人物身份的不同表示间的差异。由此提出Local Constraint Loss（LCLoss）。\n对于同一个identity，我们将其定义为相互的地理邻居（geometric neighbor），对于一个样本，他的特征表示应该和他的地理邻居的表示差异较小，由此得到：\n$$\nLCLoss = \\frac{1}{N(N-1)}{\\sum_{i=1}^{N}\\sum_{j=i+1}^{N}w_{i,j}||feature_{si}^t - feature_{sj}^{t}||_2}\n$$\n$$\nw_{i,j} =\n\\begin{cases}\n&amp; 1 &amp;\\text{, if i j have the same identy} \\\n&amp; 0 &amp;\\text{, otherwise}\n\\end{cases}\n$$\n总的loss为：\n$$\nLoss = \\sum_{i=1}^4 ALoss_i + \\lambda LCLoss\n$$\n网络的设置：\n\n\n","tags":["Face Recognition"]},{"title":"《Rethinking Atrous Convolution for Semantic Image Segmentation》阅读笔记","url":"/article/%C2%B0%E2%88%82Rethinking-Atrous-Convolution-for-Semantic-Image-Segmentation%C2%B0%E2%88%91%E2%80%98%C6%92%E2%88%82%C2%A1%C2%B1%C2%A0%C2%BA%C2%AB/","content":"显示的调整录波器的感受野的同时控制卷积后特征的分辨率\n为了应对语义分割中的多尺度问题，提出了级联或者并联具有不同multiple atrous rate的atrous convolution的方式来抓取不同尺度的上下文信息。\n增强了Atrous Spatial Pyramid Pooling模块，使得图像级别的特征能够被编码。\n在语义分割领域主要有两个困难：\n\n由于连续的卷积操作，图像的特征表示的分辨率越来越小。而些密集预测任务需要细节的空间信息，这使得这些任务难以保证其精度\n目标物体的尺度复杂\n\n\n上图所示的四种常用的结构来捕获多尺度上下文信息。\n\n\n对原始图片进行缩放成不同的尺寸，对其进行特征提取，将特征融合在一起。但是缩放的比例不一定很好，并且由于GPU显存的限制，一般用在推断阶段。\n\n\n编码器解码器，在编码的过程中对多尺度特征进行挖掘，空间维度和特征图逐步的别降低，因此，在网络的深层，long range information更容易获取，在解码过程中，从编码的特征中恢复细节的空间分辨率信息。\n\n\n在原始的网络最顶层加入一个模块，用于捕获大范围的信息。\n\n\n图像金字塔池化，具体可以参考博文：Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition , 简单来说是可以对任意尺寸的图片进行卷积操作，最终的到特征图像的特征是一致的。\n\n\nAtrous Convolution for Dense Feature Extraction\n考虑两个维度的信号，\n$$\ny[i] = \\sum_k x[i + rk]w[k]\n$$\n输出信号$y$的每一个位置$i$, 滤波器$w$，atrous rate为$r$。 等价于对输入$x$ 进行上采样，同时在每个方向上的连续的滤波器值间插入$r-1$个0.\n\n作者提出了如下的结构：\n\n\n","tags":["Semantic Segmentation"]},{"title":"《deep face recognition》论文解读","url":"/article/%C2%B0%E2%88%82deep-face-recognition%C2%B0%E2%88%91%C2%AC%E2%82%AC%C5%92%C6%92%CE%A9%E2%80%9A%E2%88%82%C2%A1/","content":"原文地址： Deep Face Recognition\n该论文主要从两个方面阐述了他们的工作：\n\n通过半自动化的方式来生成大规模的数据集，使用web中资源，来收集人脸数据。\n提出一种用于人脸识别的卷积网路的训练过程。\n\n\nGoogle使用的一个人人脸图像数据集中包含2亿张图片，8百万个人物身份。但是公开的数据集很难达到这样的数据规模。\n\n如上图所示，左侧的公开数据集在量级上要远小于大公司所使用的数据集。\n论文提出以下的流程来建立数据集：\n\n先在IMDB中找到一个公众人物列表，在通过Freebase，来获得相关公众人物的信息。这样能够得到5千个人名，构成一个候选列表。然后，使用谷歌图片搜索，为这5千个人名中的每一个人名收集200张图片，然后在人工对其进行过滤，如果每个人名的的200张图片中的纯度大于90%才保留，这样，一共得到了3250个人物。接下来过滤掉LFW，YTF中出现过的人物，这样一共收集到了2622个人物。\n对2622个人物，借助谷歌以及必应图片搜索，为每个人物收集到了2000张图片。\n对每一个人名，搜索引擎提供的前50的图片作为正例，其他人物的前50的图片作为负例，训练一个一对多的线性SVM。对每一个人名，都训练一个SVM，SVN将每个人物的2000张图片中得分最高的1000图片保留下来。\n为每个人物的每张图片计算VLAD描述符，对图片进行聚类，在每个类中选取出一张图片，以此来去除重复的图片以及相似的图片。\n使用AlexNet结构的CNN来辅助最后的人工过滤。这一步的目的是为了使用人工标注来降低数据的纯度。使用这个网络来对着2622个人物图像进行分类，这样，每个人物的图像，我们都能得到交叉熵得分。对每个人物的图像，我们按排序的每200张组成一个block，人工对每个block进行验证，如果该block的纯度大于95%，则保留。\n\n\n在人脸识别中传统的方法通常使用浅层特征，这些方法别称为浅层方法（Shallow Methods），使用到神经网络的方法称为深层方法（Deep Methods）。\n\n\n浅层方法\n先使用手工的局部图片描述符（handcrafted local image descriptors）来取提取图片的表示，在使用池化机制来聚合这些局部描述符来形成人脸描述符。\n\n\n深层方法\n使用卷积网络来提取人脸特征，代表的系统有DeepFace。\n\n\n\nThis method uses a deep CNN trained to classify faces using a dataset of 4 million examples spanning 4000 unique identities. It also uses a siamese network architecture, where the same CNN is applied to pairs of faces to obtain descriptors that are then compared using the Euclidean distance.\n\nDeepFace 使用组合的CNN，同时对人脸图像进行预处理，使用3D模型将人脸进行标准对齐，在当时DeepFace取得了最好的效果。随后，在DeepFace的基础上，DeepID系列由取得了一些列的进展。\n例如：\n\n使用多重CNN\n使用贝叶斯学习框架\n识别-验证多任务学习\n更深层的网络\n\nDeepID不使用3D人脸对齐，但是进行了2D的仿射对齐（Affine Alignment）\n基础的网络结果如下图所示：\n\n数学化表示如下：\n\n\n$\\phi$ : 网络\n\n\n$N$ : 数据集中人物的个数，即类别的个数，$N = 2622$\n\n\n$l_t$ : 第t张训练图像\n\n\n$W, b$ : 全连接层的参数， 其中$W \\in \\R^{N\\times D}, b \\in \\R^{N}$\n\n\n$x_t = W\\phi(l_t)+b$:  图片$l_t$ 经过网络后得到的该图片在N个类别中的得分\n\n\n$e_c$ : 类别c的one-hot向量\n\n\n经过一个softmax交叉熵损失来进行训练：\n$$\nE(\\phi)=-\\sum_t\\log(\\frac{e^{&lt;e_{t_c}，x_t&gt;}}{\\sum_{q=1, …,N}e^{&lt;e_q, x_t&gt;}})\n$$\n在学习过后，最后的全连接层(W, b)将被移除，通过网络$\\phi$ 得到的特征$\\phi(x_t)$将可以对其进行欧氏距离的计算来用于人脸验证。\n作者提出，使用三元组损失（Triplet-loss）得到的表示更具有分辨力。\n\n\n$\\phi(l_i)​$ : 图片i在卷积网络后得到的特征表示\n\n\n$W’$ : 是一个纺射投影，通过\n\n\n$$\nx_i = W’ \\frac{\\phi(l_i)}{||\\phi(l_i)||_2}\n$$\n将维度为$\\R^D$ 的特征表示映射到$x_i \\in \\R^L$ 的特征表示，其中，$L \\ll D$ ，其中的$W’$可以通过以下的损失来学习$(a, p, n)$: 是一个三元组，a是一个anchor 人脸图，p是a所属类别的一个正实例，n是a所属的类别的一个负实例\n$$\nE(W’) = \\sum_{(a, p, n) \\in T} max{ 0, \\alpha-||x_a - x_n||^{2}_{2} +||x_a - x_p||^2_2 }\n$$\n实验结果\n\n在LFW的实验结果\n\n\n\n在YFD的实验结果\n\n\n","tags":["Face Recognition"]},{"title":"剑指offer 62 圆圈中最后剩下的数组","url":"/article/%E5%89%91%E6%8C%87offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E7%BB%84/","content":"给定给一个从1到N的链表围城一个圈圈，从1开始，每次删掉第M个数，求这个链表中剩下的最后一个数。\ndef LastNodeInCircle(n, m):  last = 0  for i in range(2, n+1):    last = (last + m) % i  return last\n","tags":["链表"]},{"title":"计算机视觉中的注意力机制","url":"/article/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/","content":"简单的来说，注意力机制的目标就是学习到一个权重。\n将权重施加在原来的特征上，使得施加权重后的模型效果更好。\n这里学习到的权重没有一个固定的模式，可以是作用在原图上，可以作用在空间尺度上，也可以作用在channel尺度上。\n对于注意力的分类，大家有分为以下几种：\n\nSoft attention，对所有的分量均做加权\nHard attention，通过采样，只对部分分量做加权\n\n下面通过论文的方式对不同的方法进行说明。\n\n\n主要是在一些细粒度的图像分类中，类别之间的区别主要体现在一些局部的区域中的细微差别，如果直接用全尺寸的图像特征的话，这些细微的区别表达地不够。论文提出了RA-CNN(Recurrent Attention Convolutional Neural Network）\n\n这里一共利用了三个相同网络结构，不同输入尺寸的CNN，利用coarse to fine的思想，希望网络能够聚焦到能够体现出细微差别的区域中。\n对每一个网络，前面两个子网络论文将其称为APN(Attention Proposal Network)。每个子网络都用来做两个事情：\n\n对图像进行分类\n$$\n\\begin{equation}\n\\mathbf{p}(\\mathbf{X})=f\\left(\\mathbf{W}_{c} * \\mathbf{X}\\right)\n\\end{equation}\n$$\n\n\n\n预测attention region\n$$\n\\begin{equation}\n\\left[t_{x}, t_{y}, t_{l}\\right]=g\\left(\\mathbf{W}_{c} * \\mathbf{X}\\right)\n\\end{equation}\n$$\n其中：\n$t_x， t_y$ 指 attention region 的中心坐标\n$t_l$ 指预测出的squre边长的一半\n\n\nCrop\n$$\n\\begin{equation}\n\\begin{aligned} t_{x(t l)} &amp;=t_{x}-t_{l}, \\quad t_{y(t l)}=t_{y}-t_{l} \\ t_{x(b r)} &amp;=t_{x}+t_{l}, \\quad t_{y(b r)}=t_{y}+t_{l} \\end{aligned}\n\\end{equation}\n$$\n通过上一步，可以得到预测的attention region的四个点的坐标如上。crop操作只需要通过一个点乘来完成：\n$$\n\\begin{equation}\n\\mathbf{X}^{a t t}=\\mathbf{X} \\odot \\mathbf{M}\\left(t_{x}, t_{y}, t_{l}\\right)\n\\end{equation}\n$$\n这里M的是对原图运用$h(x)=1 /(1+\\exp ^{-k x})$ 得到的，当k足够大时，类似于一个阶跃函数。下图是k=50时的情况。\n\n\n\n\n\n在获得attention region之后，利用双线性插值的方法，获得一个增强的图像：\n$$\n\\begin{equation}\n\\mathbf{X}{(i, j)}^{a m p}=\\sum{\\alpha, \\beta=0}^{1}|1-\\alpha-{i / \\lambda} | 1-\\beta-{j / \\lambda}| \\mathbf{X}_{(m, n)}^{a t t}\n\\end{equation}\n$$\n$\\lambda$ 是上采样因子、$[]$用来取整，${}$用来取小数部分。\n\n\nLoss\n包含两部分LOSS，分类和RANK：\n$$\n\\begin{equation}\nL(\\mathbf{X})=\\sum_{s=1}^{3}\\left{L_{c l s}\\left(\\mathbf{Y}^{(\\mathbf{s})}, \\mathbf{Y}^{*}\\right)\\right}+\\sum_{s=1}^{2}\\left{L_{r a n k}\\left(p_{t}^{(s)}, p_{t}^{(s+1)}\\right)\\right}\n\\end{equation}\n$$\n$$\n\\begin{equation}\nL_{r a n k}\\left(p_{t}^{(s)}, p_{t}^{(s+1)}\\right)=\\max \\left{0, p_{t}^{(s)}-p_{t}^{(s+1)}+\\operatorname{margin}\\right}\n\\end{equation}\n$$\n直观的理解就是随着attention region的细化，它对应的分类损失也应该提高。\n\n\n在训练好之后，对每一个子APN得到的feature进行归一化，之后融合起来就能得到一个fused feature。\n\n\n\n\n主要的贡献是提出了这样一个Residual Attention Module，结构如下图所示：\n\n右边的分支为普通的卷积分支，左边的分支对原图进行下采样和上采样，得到attention mask。左边分支的激活函数是Sigmoid，输出值在（0，1）之间。如果直接用mask和原图相乘，在网络越来越深的时候，由于mask小于1，会导致输出的太小，给网络的训练带来困难。于是作者使用的是$H_{i, c}(x)=\\left(1+M_{i, c}(x)\\right) * F_{i, c}(x)$.\n那么当M(x)=0时，该层的输入就等于F(x)，因此该层的效果不可能比原始的F(x)差，这一点也借鉴了ResNet中恒等映射的思想，同时这样的加法，也使得Trunk Branch输出的feature map中显著的特征更加显著，增加了特征的判别性。这样，优化的问题解决了，性能的问题也解决了，因此通过将这种残差结构进行堆叠，就能够很容易的将模型的深度达到很深的层次，具有非常好的性能。\n","tags":["深度学习"]},{"title":"背包问题总结","url":"/article/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","content":"518. 零钱兑换 II\n\n给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。\n示例 1:\n输入: amount = 5, coins = [1, 2, 5]\n输出: 4\n解释: 有四种方式可以凑成总金额:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n示例 2:\n输入: amount = 3, coins = [2]\n输出: 0\n解释: 只用面额2的硬币不能凑成总金额3。\n示例 3:\n输入: amount = 10, coins = [10]\n输出: 1\n注意:\n你可以假设：\n0 &lt;= amount (总金额) &lt;= 5000\n1 &lt;= coin (硬币面额) &lt;= 5000\n硬币种类不超过 500 种\n结果符合 32 位符号整数\n\nclass Solution(object):    def change(self, amount, coins):        &quot;&quot;&quot;        :type amount: int        :type coins: List[int]        :rtype: int        &quot;&quot;&quot;        dp = [0] * (amount+1)        dp[0] = 1        for i in coins:            for j in range(i, amount+1):                dp[j] = dp[j] + dp[j-i]        return dp[-1]\n\n377. 组合总和 Ⅳ\n\n给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。\n示例:\nnums = [1, 2, 3]\ntarget = 4\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n因此输出为 7。\n进阶：\n如果给定的数组中含有负数会怎么样？\n问题会产生什么变化？\n我们需要在题目中添加什么限制来允许负数的出现？\n\nclass Solution(object):    def combinationSum4(self, nums, target):        &quot;&quot;&quot;        :type nums: List[int]        :type target: int        :rtype: int        &quot;&quot;&quot;        dp = [0]*(target+1)        dp[0] = 1                for i in range(1, target+1):            for j in nums:                if i-j &gt;= 0:                    dp[i] += dp[i-j]        return dp[-1]\n\n474. 一和零\n\n在计算机界中，我们总是追求用有限的资源获取最大的收益。\n现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。\n你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。\n注意:\n给定 0 和 1 的数量都不会超过 100。\n给定字符串数组的长度不会超过 600。\n示例 1:\n输入: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3\n输出: 4\n解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 “10”,“0001”,“1”,“0” 。\n示例 2:\n输入: Array = {“10”, “0”, “1”}, m = 1, n = 1\n输出: 2\n解释: 你可以拼出 “10”，但之后就没有剩余数字了。更好的选择是拼出 “0” 和 “1” 。\n\nclass Solution(object):    def findMaxForm(self, strs, m, n):        &quot;&quot;&quot;        :type strs: List[str]        :type m: int        :type n: int        :rtype: int        &quot;&quot;&quot;        dp = [[0]*(m+1) for _ in range(n+1)]        for i in strs:            ones = i.count(&#x27;1&#x27;)            zeros = i.count(&#x27;0&#x27;)            for j in range(n, ones-1, -1):                for k in range(m, zeros-1, -1):                    dp[j][k] = max(dp[j][k], dp[j-ones][k-zeros]+1)        return dp[-1][-1]\n\n139. 单词拆分\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n说明：\n拆分时可以重复使用字典中的单词。\n你可以假设字典中没有重复的单词。\n示例 1：\n输入: s = “leetcode”, wordDict = [“leet”, “code”]\n输出: true\n解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。\n示例 2：\n输入: s = “applepenapple”, wordDict = [“apple”, “pen”]\n输出: true\n解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。\n注意你可以重复使用字典中的单词。\n\nclass Solution(object):    def wordBreak(self, s, wordDict):        &quot;&quot;&quot;        :type s: str        :type wordDict: List[str]        :rtype: bool        &quot;&quot;&quot;        dp = [False]*(len(s)+1)        dp[0] = True        for i in range(1, len(s)+1):            for j in wordDict:                if s[i-1:].startswith(j):                    dp[i+len(j)-1] = dp[i+len(j)-1] or dp[i-1]        return dp[-1]                \n\n494. 目标和\n\n给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n示例 1:\n输入: nums: [1, 1, 1, 1, 1], S: 3\n输出: 5\n解释:\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n一共有5种方法让最终目标和为3。\n注意:\n数组的长度不会超过20，并且数组中的值全为正数。\n初始的数组的和不会超过1000。\n保证返回的最终结果为32位整数。\n\nclass Solution(object):    def findTargetSumWays(self, nums, S):        &quot;&quot;&quot;        :type nums: List[int]        :type S: int        :rtype: int        &quot;&quot;&quot;        if S &gt; sum(nums) or S &lt; -sum(nums):            return 0        total = (S+sum(nums))/2        if total * 2 != S+sum(nums):            return 0        dp = [0] * (total+1)        dp[0] = 1        for i in nums:            for j in range(total, i-1, -1):                dp[j] += dp[j-i]        return dp[-1]\n\n416. 分割等和子集\n\n给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n注意:\n每个数组中的元素不会超过 100\n数组的大小不会超过 200\n示例 1:\n输入: [1, 5, 11, 5]\n输出: true\n解释: 数组可以分割成 [1, 5, 5] 和 [11].\n示例 2:\n输入: [1, 2, 3, 5]\n输出: false\n解释: 数组不能分割成两个元素和相等的子集.\n\nclass Solution(object):    def canPartition(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: bool        &quot;&quot;&quot;        if sum(nums)//2 * 2 != sum(nums):            return False                target = sum(nums)//2        dp = [False] * (target+1)        dp[0] = True                for i in nums:            for j in range(target, i-1, -1):                dp[j] = dp[j] or dp[j-i]                        return dp[-1]\n\n322. 零钱兑换\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n示例 1:\n输入: coins = [1, 2, 5], amount = 11\n输出: 3\n解释: 11 = 5 + 5 + 1\n示例 2:\n输入: coins = [2], amount = 3\n输出: -1\n说明:\n你可以认为每种硬币的数量是无限的。\n\nclass Solution(object):    def coinChange(self, coins, amount):        &quot;&quot;&quot;        :type coins: List[int]        :type amount: int        :rtype: int        &quot;&quot;&quot;        dp = [float(&#x27;inf&#x27;)] * (amount+1)        dp[0] = 0        for i in coins:            for j in range(i, amount+1):                dp[j] = min(dp[j], dp[j-i]+1)        return -1 if dp[-1] == float(&#x27;inf&#x27;) else dp[-1]        \n","tags":["bp"]},{"title":"为ipic添加腾讯云床","url":"/article/%E4%B8%BAipic%E6%B7%BB%E5%8A%A0%E8%85%BE%E8%AE%AF%E4%BA%91%E5%BA%8A/","content":"之前一直都在使用新浪云床保存博客的图像。最近发现在浏览器打开时，加载不出来：\n\n而在本地的typroa能够正常显示：\n\n后来将新浪云床换成腾讯云床之后问题解决了。\n具体的步骤如下：\n\n\n登录腾讯云\n\n\n进入控制台\n\n\n\n搜索&quot;存储对象&quot;\n\n\n\n创建存储桶\n\n\n\n填写信息\n\n这里：\n\n名称随便写\n所属地也无所谓，随便写\n访问权限选“共有读私有写”\n\n\n\n创建完之后进入“存储桶列表”\n\n\n\n进入“基础配置”\n\n\n\n将上图中1和2分别填入ipic设置中的1和2\n\n\n\n进入“秘钥管理”\n\n\n\n将下面的3和4填入ipic设置中的3和4\n\n\nDone！\n\n\n","tags":["图床","ipic"]},{"url":"/article/%E9%9D%A2%E7%AD%8B/","content":"template match\n模板匹配是一种最原始、最基本的模式识别方法，研究某一特定对象物的图案位于图像的什么地方，进而识别对象物，这就是一个匹配问题。它是图像处理中最基本、最常用的匹配方法。模板匹配具有自身的局限性，主要表现在它只能进行平行移动，若原图像中的匹配目标发生旋转或大小变化，该算法无效。模板就是一副已知的小图像，而模板匹配就是在一副大图像中搜寻目标，已知该图中有要找的目标，且该目标同模板有相同的尺寸、方向和图像元素，通过一定的算法可以在图中找到目标，确定其坐标位置。\n\n设计模式\n\n单例模式\n\n**意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n**主要解决：**一个全局使用的类频繁地创建与销毁。\n**何时使用：**当您想控制实例数目，节省系统资源的时候。\n**如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n**关键代码：**构造函数是私有的。\n\n\n工厂模式\n\n**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n**主要解决：**主要解决接口选择的问题。\n**何时使用：**我们明确地计划不同条件下创建不同实例时。\n**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。\n**关键代码：**创建过程在其子类执行。\n\n\n装饰器模式\n\n**意图：**动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n**主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n**何时使用：**在不想增加很多子类的情况下扩展类。\n**如何解决：**将具体功能职责划分，同时继承装饰者模式。\n\n\n\nmetaclass\n\n实例对象是由类来创建，那么类又是由什么来创建的呢？ 答案就是元类。\n类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。\ntype可以接受一个类的描述作为参数，然后返回一个类。\n\n变量的作用域\n\n\nLEGB\n当在函数中使用未确定的变量名时，Python会按照优先级依次搜索4个作用域，以此来确定该变量名的意义。首先搜索局部作用域(L)，之后是上一层嵌套结构中def或lambda函数的嵌套作用域(E)，之后是全局作用域(G)，最后是内置作用域(B)。按这个查找原则，在第一处找到的地方停止。如果没有找到，则会出发NameError错误。\n\n\nL(local)局部作用域\n\n包含在def关键字定义的语句块中，即在函数中定义的变量。每当函数被调用时都会创建一个新的局部作用域。\n\n\n\nE(enclosing)嵌套作用域\n\n对一个函数而言，L是定义在此函数内部的局部作用域，而E是定义在此函数的上一层父级函数的局部作用域。\n\n\n\nG(global)全局作用域\n\n即在模块层次中定义的变量，每一个模块都是一个全局作用域。也就是说，在模块文件顶层声明的变量具有全局作用域\n\n\n\nB(built-in)内置作用域\n\n系统内固定模块里定义的变量，如预定义在builtin 模块内的变量。\n\n\n\n\n\ntcp udp\n\nTCP 是面向连接的，UDP 是面向无连接的\nUDP程序结构较简单\nTCP 是面向字节流的，UDP 是基于数据报的\nTCP 保证数据正确性，UDP 可能丢包\nTCP 保证数据顺序，UDP 不保证\n\n图像去噪\n\n\n均值滤波器\n采用邻域平均法的均值滤波器非常适用于去除通过扫描得到的图像中的颗粒噪声。领域平均法有力地抑制了噪声,同时也由于平均而引起了模糊现象,模糊程度与领域半径成正比。\n几何均值滤波器所达到的平滑度可以与算术均值滤波器相比,但在滤波过程中会丢失更少的图象细节。\n谐波均值滤波器对“盐”噪声效果更好,但是不适用于“胡椒”噪声。它善于处理像高斯噪声那样的其他噪声。\n逆谐波均值滤波器更适合于处理脉冲噪声,但它有个缺点,就是必须要知道噪声是暗噪声还是亮噪声,以便于选择合适的滤波器阶数符号,如果阶数的符号选择错了可能会引起灾难性的后果。\n\n\n### 自适应维纳滤波器\n\n它能根据图象的局部方差来调整滤波器的输出,局部方差越大,滤波器的平滑作用越强。它的最终目标是使恢复图像f^(x,y)与原始图像f(x,y)的[均方误差](https://baike.baidu.com/item/均方误差)e2=E[(f(x,y)-f^(x,y)2]最小。该方法的滤波效果比[均值](https://baike.baidu.com/item/均值)滤波器效果要好,对保留图像的边缘和其他高频部分很有用,不过计算量较大。维纳滤波器对具有白噪声的图象滤波效果最佳。\n\n\n\n### 中值滤波器\n\n它是一种常用的非线性平滑滤波器,其基本原理是把[数字图像](https://baike.baidu.com/item/数字图像)或数字序列中一点的值用该点的一个领域中各[点值](https://baike.baidu.com/item/点值)的中值代换其主要功能是让周围象素[灰度值](https://baike.baidu.com/item/灰度值)的差比较大的像素改取与周围的像素值接近的值,从而可以消除孤立的噪声点,所以中值滤波对于滤除图像的椒盐噪声非常有效。中值滤波器可以做到既去除噪声又能保护图像的边缘,从而获得较满意的复原效果,而且,在实际运算过程中不需要图象的统计特性,这也带来不少方便,但对一些细节多,特别是点、线、尖顶细节较多的图象不宜采用中值滤波的方法。\n\n\n\n### 形态学噪声滤除器\n\n将开启和闭合结合起来可用来滤除噪声,首先对有噪声图象进行开启操作,可选择[结构要素](https://baike.baidu.com/item/结构要素)矩阵比噪声的尺寸大,因而开启的结果是将背景上的噪声去除。最后是对前一步得到的图象进行闭合操作,将图象上的噪声去掉。根据此方法的特点可以知道,此方法适用的图像类型是图象中的对象尺寸都比较大,且没有细小的细节,对这种类型的图像除噪的效果会比较好。\n\n\n\n### 小波去噪\n\n这种方法保留了大部分包含信号的[小波系数](https://baike.baidu.com/item/小波系数),因此可以较好地保持图象细节。[小波分析](https://baike.baidu.com/item/小波分析)进行图像去噪主要有3个步骤:(1)对图象信号进行小波分解。(2)对经过层次分解后的高频[系数](https://baike.baidu.com/item/系数)进行[阈值](https://baike.baidu.com/item/阈值)量化。(3)利用二维小波重构图象信号。 [1]\n\n大文件处理\n联通区域\n\n\n大致算法如下：\n设二值化图像A中，像素值为255的点是前景，为0的点是背景。A(x, y)为坐标(x, y)处的像素值，定义连通区域的label是一个1~254的整数，互不联通的区域有不同的label。初始化label=0。遍历图像的每个像素：\n1、 如果像素值不等于255，则继续访问下一个元素。\n2、 如果像素值为A(x, y) = 255，则label++，当前值A(x, y) = label，并且\na. 检查其4个邻域，如果有属于前景的像素也给它赋予label值，并将它的坐标压栈。\nb. 弹出栈顶坐标，重复a的过程，知道堆栈为空。\n此时，便找到了一个连通区域，该区域内的像素值被标记为label。\n3、 重复1、2的过程，检测出所有的区域。\n\n\n\n进程和线程的区别\n进程是资源分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。\n线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。\n\n进程是资源分配的最小单位，线程是程序执行的最小单位。\n进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。\n线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。\n但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。\n\n那就说一下Python中list的底层代码怎么实现的吧\n\nCPython中，列表被实现为长度可变的数组\n指向这个数组的指针及其长度被保存在一个列表头结构中。这意味着，每次添加或删除一个元素时，由引用组成的数组需要该标大小（重新分配）。幸运的是，Python在创建这些数组时采用了指数分配，所以并不是每次操作都需要改变数组的大小。但是，也因为这个原因添加或取出元素的平摊复杂度较低。\n\nTCP三次握手\n一般模型中一层有多少个卷积核\n\n3×3卷积核与5×5卷积核相比的优点\n\n2个3×3的感受野和5×5的一样，但是参数更少\n\n为什么卷积核size都是奇数的\n\n保护位置信息：保证了 锚点 刚好在中间，方便以模块中心为标准进行滑动卷积，避免了位置信息发生 偏移 。\npadding时对称：保证了 padding 时，图像的两边依然相 对称 。\n\n如果强行用偶数的size行吗？\n\n偶数*偶数，没有中心点，那么输入和卷积核内积的结果要置放何处？只能是设定中间的四个像素同时加权更新。这样大大增加了计算量（因为如果步长是1，那么卷积核无论向右还是向下扫描遍历，总有2个像素会重复更新，计算量剧增，效果还不一定好）。\n\n激活函数的作用，如果全部都是非线性的会对模型有什么影响\n\n由于线性模型的表达能力不够，故激活函数的加入可以使得神经网络更好地解决较为复杂的问题。\n\nReLu\n池化层的作用，除了池化层还有什么方法可以减少特征数量\n\n这里他提到了UNet模型，之前有看过，就说出来了，是采样\n\n剪枝和dropout方法的原理\n\n\n神经网络通常如上图左所示：下层中的每个神经元与上一层有连接，但这意味着我们必须进行大量浮点相乘操作。完美情况下，我们只需将每个神经元与几个其他神经元连接起来，不用进行其他浮点相乘操作，这叫做「稀疏」网络。稀疏网络更容易压缩，我们可以在推断期间跳过 zero，从而改善延迟情况。如果你可以根据网络中神经元但贡献对其进行排序，那么你可以将排序较低的神经元移除，得到规模更小且速度更快的网络。可以防止过拟合, 为拓展网络规模和加快训练速度提供了可能性.网络剪枝是指当训练一个较大神经网络时, 移除部分不需要连接的方法.通过移除一个单元, 将其和其所有的传入传出连接从网络中删除.同时, 较大尺寸的网络架构对初始训练条件较为敏感, 而修剪网络能够降低网络的复杂度, 有利于提升泛化能力.\n\n\n取平均的作用： 先回到标准的模型即没有dropout，我们用相同的训练数据去训练5个不同的神经网络，一般会得到5个不同的结果，此时我们可以采用 “5个结果取均值”或者“多数取胜的投票策略”去决定最终结果。例如3个网络判断结果为数字9,那么很有可能真正的结果就是数字9，其它两个网络给出了错误结果。这种“综合起来取平均”的策略通常可以有效防止过拟合问题。因为不同的网络可能产生不同的过拟合，取平均则有可能让一些“相反的”拟合互相抵消。dropout掉不同的隐藏神经元就类似在训练不同的网络，随机删掉一半隐藏神经元导致网络结构已经不同，整个dropout过程就相当于对很多个不同的神经网络取平均。而不同的网络产生不同的过拟合，一些互为“反向”的拟合相互抵消就可以达到整体上减少过拟合。\n减少神经元之间复杂的共适应关系： 因为dropout程序导致两个神经元不一定每次都在一个dropout网络中出现。这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况 。迫使网络去学习更加鲁棒的特征 ，这些特征在其它的神经元的随机子集中也存在。换句话说假如我们的神经网络是在做出某种预测，它不应该对一些特定的线索片段太过敏感，即使丢失特定的线索，它也应该可以从众多其它线索中学习一些共同的特征。从这个角度看dropout就有点像L1，L2正则，减少权重使得网络对丢失特定神经元连接的鲁棒性提高。\n\n\nBN原理\nSVM如果找不到最优超平面怎么办？\n\n回答是通过核函数的方法映射到高维空间\n还有一个是引入松弛因子\n\nAdaboost的原理，训练过程是怎样的\nhaar-like特征原理\n输入图像灰度值对模型的影响，为什么要把0-255转化成0-1？\n\n归一化到1不会让参数变化对图像特征变化影响过大，从而防止震荡和减小训练时间\n\nraw图bayer pattern有几种类型\n图像去噪算法（我说了均值，高斯，双边等，然后让我解释BM3D，可能是一面说的还不错，就大概说一下就被叫停了）\n什么是非极大值抑制？\n图像编码是怎么做的？（12bit变成8bit的过程）\n举出了解的各种排序算法和时间复杂度\n算法两道\n归并排序\n讲项目\n特征选择的常用方法\nbagging和boosting的区别\n手推逻辑回归\n过拟合的解决办法，以及在你的项目中怎么用的\nL1和L2的区别    L1为什么能稀疏矩阵  L2为什么不能，L2为什么能解决过拟合\ngbdt，xgboost模型的比较\nlstm和Rnn区别\n梯度消失的解决办法\n手撕代码:链表反转   最大子序列和\n智力题:马匹赛跑   25匹马，5个跑道，没有计时器，要找出前三名，最少要比多少场，答案是7\n二面:\n手推gbdt\n手推xgboost\n手撕代码两个有序数组，求其中位数，然后改进时间复杂度\nLR和svm的区别\n场景分析题，如何对新闻进行实效性分析，怎么挖特征\nlstm.每个门的公式还会写吗？我说不记得\n第二个问题是 LR的损失函数，很简单嘛，基于极大似然估计，然后楼主嘴贱不小心说了一下最大后验估计和极大似然估计，然后问题来了！！！！！！你知道最大后验估计？那么最大后验估计和极大似然估计解释一下两个分别是什么意思。然后概率估计中贝叶斯学派和频率学派的区别是什么！然后楼主提了嘴先验分布啊，然后接着就解释一下beta分布和二项分布的共轭关系，beta分布的表达式会写吗，beta分布的两个参数是什么意义，比赛中用贝叶斯平滑解决了啥问题。\n第三个问题是svm和xgboost面试官看我比赛写了xgboost觉得我很熟悉就说不问了，SVM是非常经典的问题，就和我讨论了下SVM的用法吧， 挖的比较细，不过在高斯分布那块，有个问题是为什么高斯核经过大量调参可以出很好的效果，楼主回答的是因为可以映射到无穷维，但是具体不太清楚，然后面试官超级NICE的给我讲导了很多blabla的知识。\n两个链表求交点的code题\n第一个问题，介绍一下CTR预估里面的模型，画一下DeepFM的示意图，然后解释一下这些的区别\n第二个问题，手撕代码，写一个矩阵旋转90度的代码，解释一下坐标变换公式\n第三个问题，用非递归的方式实现一个二叉树的删除操作,引申问题O(1)的空间复杂度怎么解决？ 时间换空间，面试官给我说了很多blabla\n2、算法：二叉树公共父节点\n二面\n1、讲项目。\n2、分类为什么用logloss\n3、softmax原理，推导\n4、算法：链表1-&gt;2-&gt;3&gt;4反转为1&gt;4&gt;2&gt;3。\n输入URL之后过程\n一面：\n1.自我介绍（一般套路）\n我介绍了自己的研究方向，自己读研期间的项目以及实习经历。\n2.介绍下你简历里面令你印象深刻的项目，为什么？\n我说了一个实习经历，原因是真实场景，会遇到各种以前没见过的问题，balabala。。。\n（期间会打断我，不断的问实习的时候做的事情，什么特征选择，特征的维度，用户和物品的数量）。\n3.（开始问算法）说说线性回归\n我结合逻辑回归基本讲了一下原理\n4.问了xgboost（我实习的时候用过xgboost，所以写在简历上**），问特征维度是1600，你一般建多少颗树，数的深度你怎么设置，以及其他的参数怎么设置？**\n我说我当时设置100颗树（具体我也忘了。。。因为当时实习的时候是leader把参数设置好让我去跑的）,树的深度我回答50（回答完我就后悔了）\n，面试官问：数的深度是50，你算算有多少结点（自己挖了个坑啊2^50-1，自己笑笑说可能记错了。。。尴尬）。\n5.你了解JVM的参数设置吗，比如现在频繁出现GC，你应该怎么做？\n我说出现GC可能是内存不够用，可以考虑把堆内存调大一点。\n6.延伸第五个问题，你怎么调整内存中新生代和老年代的内存大小？\n我说新生代和老年代的比例不是固定的嘛？1:2.。。。（好吧，我对这块不熟悉）然后就过了。。。\n7.HashMap和Hashtable和Map的区别\n我从线程安全和是否容许null来回答的。\n8.然后又问，Hashtable的线程安全你知道是怎么实现的嘛？\n说真的，这题我真不知道怎么回答，我只是说了加了synchronized关键字。\n9.你和我说说spark RDD吧\n然后我从两大类的算子大致说了下RDD。\n10.说了一个场景：现在我用spark跑一个逻辑回归模型程序，发现数据倾斜了，你怎么解决？\n我说首先分析是否算子方面写的不合理，然后说如果是数据方面的原因，可以考虑对数据进行预处理，然后单独去处理这部分的会导致倾斜的数据。（中间打断了我一次，说，如果在跑程序的过程中，如果是数据出现的问题，你会停止然后重新做？我好直接说：会。。。不知道回答的对不对。。。估计是不是想考我rdd方面的知识，奈何不太熟悉）。\n11.问我有什么想问的？\n整个过程40分钟左右中间电话还断了一次，我问完两个问题，然后面试就结束了，都没说后面还有没有面试了，留下我一脸蒙蔽，心想挂了吧，回去写个面经吧。\n还有其他的问题我就记不起来了，原因是，我在写面经的过程中，二面的电话来了，接下来是二面的面经。\n===================================================================================================\n二面：\n1.自我介绍\n我将刚刚那一套又说了一遍。。。实在不知道还有什么好说的。\n2.说一下xgboost\n我简单说了一下原理。\n3.给我介绍下，推荐方面有那些算法\n我大致将两类的推荐算法都说了。\n4.我看你简历上写了fm，那你和我说说fm吧\n我也简单说了下fm的思想。\n5.现在给你一亿的用户，和一亿的物品，你怎么去做推荐？\n说实话，当时听到这个问题的时候，我内心是拒绝的，心想：我在研究所里最多用的也不过是几万的用户几十万的物品，一亿你存心为难我吧。硬着头皮说，既然数据量这么大的话，是否可以先进行数据预处理，然后利用spark去做？我当时用的是问号，其实是希望面试官回答我的这个问题，结果他直接过了。。。\n6.然后问我项目的事情，问我实习的项目，推荐系统的流程（当时我在实习的时候也是做得推荐**）？**\n我将整个推荐的流程说了一遍，从数据的处理到数据的应用。\n7.你在实习的时候，在召回的步骤用的协同过滤和ALS会不会出现一些效果不好的情况，然后你怎么分析的？\n这个问题，我并没有回答，因为我确实没有参与召回策略那一块。只好说我没有参与，然后转向说目前业界这些基本的算法应该还是很好用的。\n整个过程大概是15分钟，很短，结果二面面试官跟我说，你在我这儿ok，我来问问其他的同事，如果有三面，等会再联系你。\n====================================================================================================\n三面：\n接到三面的电话，我还特意找了一个清净的地方，结果说要电脑，要写代码，我只好回到办公室。\n1.你给我写一下链表的反转\n我还特意问了下，时间复杂度和空间复杂度有什么要求？面试官说没有，这个还是很好写的，看过左神书的应该都会写这个，然后写了一个最优的。\n2.你还有没有其他的方式来实现这个？\n我说递归（说完我就后悔了。。。），面试官说你写一个递归的版本吧，好在网速不稳定页面刷不出来，然后就没写了，让我口述了一下。\n说完，来了一句其实就是考考你递归。。。\n3.你一般用java是吧，你对GC熟悉吗，给我说说GC的有几个算法并说下原理\n我说了标记-清除，标记-整理，还有一个死活想不起来名字，然后说还有一个的原理是这样的，但我忘了叫什么名字。。。\n4.JVM内存是怎么划分的？\n答了堆内存从物理上可以分为年轻代和老年代\n5.年轻代是否可以继续划分？\n答了Eden区和Survivor区，然后两个的比例。\n6.这个比例是固定的嘛?是否可以调整？\n这个问题，我不知道，我记得是固定的8：1：1。。。然后问：这个比例可以调整吗？我没遇到过。。。\n7.什么时候会触发年轻代的GC？\n中间还有几个问题我忘了。。。\n后面聊推荐，因为我的研究方向是推荐，所以聊天推荐的话还行，感觉和三面的面试官后面的时间不像面试，倒是像在交流。面完，同屋子里说，还以为你和谁讨论问题。。。\n三面大概一个小时。\n一面：\n1）子数组最大和\n2）堆排序\n3）数组中出现次数最多的K个数\n二面：\n1、包含重复数字的无序数组，找到所有加和等于target的索引对。\n2、三色旗问题 ，这道题没答上来，已经决定要凉凉了。\nhttps://blog.csdn.net/u011200844/article/details/43227301\n3、后面问了一些项目。\nbagging和boosting的区别\nTFIDF和text rank，说下公式\n说一下随机森林、优缺点是什么\nCNN怎么减少参数\n梯度消失和梯度爆炸\n怎么判断一个字符串是否是日期\nLSTM的几个门\nRNN每一层的输入\n过拟合、欠拟合怎么判断，解决\n分类效果不好怎么做\nID3，C4.5、决策树的构建\n讲下SVM，SVM为什么叫支持向量机、损失函数是什么、核函数\n说下逻辑回归、损失函数\n缺失值怎么处理\n特征选择方法\n\n笔试还是简单，还是机器学习基础，还有编程是求两个无环链表的公共节点的个数\n二、第一轮技术面\n1、python2跟python3的区别\n2、python3中基类怎么运作的\n3、“==”的具体实现机制\n4、还有一堆python的语法，忘记了\n5、SVM的具体实现机制，整个流程\n6、讲讲简历的，介绍了一些新方法，估计是面试官对这个感兴趣，才给过了一面吧。\n三、第二轮技术面\n1、简历中项目的各种细节，画图，各种点的原因\n2、各种分类网络简述，mobilenet具体实现\n3、概率题\n4、视频分割\n四、总监面\n1、RCNN→Fast RCNN→Faster RCNN的内容\n2、多任务学习中每部分损失函数的权重确定\n3、在人像分割中，针对头发这种区域的分割，往往处理不是很好，怎么改进\n4、如何在分割中利用周围像素点进行建模，提高分割结果\n"},{"url":"/article/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"算法工程师知识点大全 (正在更新…) - Mr_HHH 的博客 - CSDN 博客\n下面内容为自己找工作的过程中，自己整理的知识点以及从别人面经中整理的知识点大全，对其中的大部分问题，我都会给出我认为最优答案的 csdn 链接 (ps: 本篇博客正在整理过程中，会不定期更新一些新的知识点的答案，希望可以帮到更多的同学！ 最新更新于 2019-4-19)\n【1】在 github 上找到了一个 2018/2019 / 校招 / 春招 / 秋招 / 自然语言处理 (NLP)/ 深度学习 (Deep Learning)/ 机器学习 (Machine Learning)/C/C++/Python / 面试笔记链接，内容涉及机器学习，深度学习，算法，编程语言，面经，数学等，感觉灰常不错，特来分享：https://github.com/worksking/Interview_Notes-Chinese  ，希望对你有帮助！\n【2】今天又在 github 上发现了一个 2019 年秋招计算机类面经的项目，\nhttps://github.com/zslomo/2019-Autumn-recruitment-experience  ，截图如下：\n\n\n【3】此外我再两外分享一个关于计算机基础知识的 github 主页：https://github.com/CyC2018/CS-Notes\n\n机器学习\n\nBoost 算法\nCART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）\nGBDT 与随机森林比较。\nGBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）\nKKT 条件用哪些，完整描述\nKNN（分类与回归）\nL1 与 L2 的区别以及如何解决 L1 求导困难。\nL1 和 L2 函数。\nL1 和 L2 正则相关问题。\nL1 和 L2 正则项，它们间的比较\nL1 正则为什么可以把系数压缩成 0，坐标下降法的具体实现细节\nLR 为什么用 sigmoid 函数。这个函数有什么优点和缺点？为什么不用其他函数？\nLR 和 SVM 有什么区别，libsvm 和 liblinear 有什么区别。\nLogistics 与随机森林比较\nLogistics（推导）\nLogistic 回归的推导，怎么得到 objective function。\nSVM 与随机森林比较\nSVM 为什么要引入拉格朗日的优化方法。\nSVM 原问题和对偶问题关系？\nSVM 在哪个地方引入的核函数, 如果用高斯核可以升到多少维。\nSVM 怎么防止过拟合\nSVM 的目标函数。常用的核函数。\nSVM 的过程，讲了推导过程，可能表达不清晰，都是泪\nbagging、adaboost、boosting\nem 与 kmeans 的关系；\nk-means 的 k 怎么取等等\nk-means 算法初始点怎么选择？你的项目里面推荐算法是怎么实现的？\nkmeans 的原理，优缺点以及改进。\nk 折交叉验证中 k 取值多少有什么关系\nl2 惩罚项是怎么减小 Overfitting 的？l1，l2 等范数的通式是什么？他们之间的区别是什么？在什么场景下用什么范数？l1 在 0 处不可导，怎么处理？\nrandomforest,GBDT\nrf, gbdt, xgboost 的区别。\nsoftmax 公式\n为什么要做数据归一化？\n主要问最优化方面的知识，梯度下降法的原理以及各个变种（批量梯度下降，随机梯度下降法，mini 梯度下降法），以及这几个方法会不会有局部最优问题，牛顿法原理和适用场景，有什么缺点，如何改进（拟牛顿法）\n什么情况下一定会发生过拟合？\n什么是贝叶斯估计\n介绍 LR、RF、GBDT ，分析它们的优缺点，是否写过它们的分布式代码\n介绍 SVD、SVD++ ？\n会哪些机器学习算法？\n信息熵公式 ？\n假设面试官什么都不懂，详细解释 CNN 的原理；\n决策树原理\n决策树处理连续值的方法？\n决策树如何防止过拟合 ？\n决策树的损失函数？\n决策树过拟合哪些方法，前后剪枝\n分类模型可以做回归分析吗？反过来可以吗？\n分类模型和回归模型的区别\n判别模型，生成模型\n各个模型的 Loss function，牛顿学习法、SGD 如何训练。\n因为面我的总监是做 nlp 的, 所以讲了很多 rnn、lstm、还有 HMM 的东西。不算很熟，但是接触过，以前稍微看过一些相关论文，所以还是勉强能聊的。\n在平面内有坐标已知的若干个点 P0…Pn，再给出一个点 P，找到离 P 点最近的点。\n在模型的训练迭代中，怎么评估效果。\n如何减少参数（权值共享、VGG 的感受野、GoogLeNet 的 inception）\n如何防止过拟合（增加数据，减少模型复杂度 -&gt; 正则化）\n对于同分布的弱分类器，求分类器均值化之后的分布的均值跟方差。\n对于机器学习你都学了哪些？讲一个印象深的。\n常见分类模型（ svm，决策树，贝叶斯等）的优缺点，适用场景以及如何选型\n归一化方式\n手写 k-means 的伪代码。\n手写 k-means 的伪代码和代码。（Code）\n手撕 svm 硬软间隔对偶的推导\n手撕逻辑回归（损失函数及更新方式推导）\n接着写一下信息增益的公式。\n推一下 bp 算法等等\n改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度。\n数据挖掘各种算法，以及各种场景下的解决方案\n是否了解 mutual infomation、chi-square、LR 前后向、树模型等特征选择方式。\n是否了解线性加权、bagging、boosting、cascade 等模型融合方式\n有哪些常见的分类器，简单介绍下原理\n机器学习与深度学习的区别\n机器学习基础（线性回归与逻辑回归区别等）\n机器学习：几种树模型的原理和对比，朴素贝叶斯分类器原理以及公式，出现估计概率值为 0 怎么处理（拉普拉斯平滑），缺点； k-means 聚类的原理以及缺点及对应的改进；\n梯度下降牛顿拟牛顿原理\n梯度下降的优缺点。\n深度学习和普通机器学习有什么不同？\n深度学习有很大部分是 CNN，给他用通俗的语言解释下卷积的概念，解释下 CNN 中的优势及原因\n激活函数的选择（sigmoid-&gt;ReLu-&gt;LReLU-&gt;PReLU）\n然后 20 分钟内手写 k-means\n牛顿法、随机梯度下降算法和直接梯度下降算法的区别？\n牛顿法推导\n特征选择的方法\n由数据引申到数据不平衡怎么处理（10W 正例，1W 负例，牛客上有原题）\n聊聊 SVM，这段说了好久，从基本的线性可分到不可分，相关升维，各种核函数，每个是如何实现升。以及出现了 XX 问题，分析是样本的原因还是其他原因。针对不同情况，采取什么解决方案较好。\n自己实现过什么机器学习算法\n解决过拟合的方法有哪些？\n解释 word2vec 的原理以及哈夫曼树的改进。\n解释一下过拟合和欠拟合，有哪些方法防止过拟合。\n让我一步一步地构造决策树，怎么计算信息熵、信息增益、然后 C4.5 ID3 CART 的区别，还说了一下优缺点\n详细讨论了样本采样和 bagging 的问题\n说一下 Adaboost，权值更新公式。当弱分类器是 LR 时，每个样本的的权重是 w1，w2…, 写出最终的决策公式。\n说了一下 bagging 跟 boosting。\n说明 L1L2 正则的效果与为什么形成这种情况（L1 正则稀疏，L2 正则平滑，之后说明就是画图说明正则化）\n过拟合的解决方法；\n选个你熟悉的机器学习方法 ，着重介绍一下产生原因，推导公式，背后统计意义什么等等\n逻辑回归估计参数时的目标函数，如果加上一个先验的服从高斯分布的假设，会是什么样。\n逻辑回归估计参数时的目标函数\n逻辑回归的值表示概率吗？\n问了会不会 RNN,LSTM。\n问了很多数据挖掘的基础知识，包括 SVM, 逻辑回归、EM、K-means 等，然后给我很多场景问我遇到这些情况我要怎么来处理数据，怎么进行建模等等，问得很细\n随机梯度下降，标准梯度\n随机森林和 GBDT 的区别？LR 的参数怎么求解？有没有最优解？\n随机森林（Bagging+CART）\n拟牛顿法\n随机森林和 GDBT 的区别？\n\nGBDT 和随机森林的相同点：\n1、都是由多棵树组成\n2、最终的结果都是由多棵树一起决定\nGBDT 和随机森林的不同点：\n1、组成随机森林的树可以是分类树，也可以是回归树；而 GBDT 只由回归树组成\n2、组成随机森林的树可以并行生成；而 GBDT 只能是串行生成\n3、对于最终的输出结果而言，随机森林采用多数投票等；而 GBDT 则是将所有结果累加起来，或者加权累加起来\n4、随机森林对异常值不敏感，GBDT 对异常值非常敏感\n5、随机森林对训练集一视同仁，GBDT 是基于权值的弱分类器的集成\n6、随机森林是通过减少模型方差提高性能，GBDT 是通过减少模型偏差提高性能\n\\5. 随机森林怎么取最后的结果？\n\\6. 随机森林是怎样避免 ID3 算法信息增益的缺点的？\n​         答：首先说下信息增益的过程，决策树算法本质上就是要找出每一列的最佳划分以及不同列划分的先后顺序及排布。信息增益的缺点是比较偏向选择取值多的属性。而 gini 系数每次都是二分，所以跟属性多少没有关系。\n\\7. 为什么 deeplearning 能抑制梯度消失或者爆炸的问题？\n答: 几个方面：一是激活函数不光是只用 sigmoid 函数，还有 ReLU 函数二是在参数并不是初始化的时候并不是随机选择的，而是在前面有自编码器做了特征特征器，这样避免了梯度下降法求解陷入局部最优解；三，深度学习一些手段，权值共享，卷积核，pooling 等都能抑制梯度消失问题；四，二次代价函数换成交叉熵损失函数或者选用 softmax + 对数似然代价函数的组合。\n\\8. 介绍下 GBDT?\n​       GBDT 采用的是 boosting 的思想，先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得基学习器做错的训练样本在后续受到更多的关注，然后基于调整后的样本分布来训练下一个基学习器，最后将所有基学习器加权结合。GDBT 在传统的 boosting 的基础上，将以决策树为基函数的提升树拟合残差，利用损失函数的负梯度在当前模型的值作为残差的估计。  (注：GBDT 是 boost 模型的一种，但不是 adaboost,adaboost 也只是 boost 模型的一种，adaboost 和 GBDT 模型和参数更新方法都不一样)\n\\9. 决策树和 adaboost 的区别\n\\10. 卷积层为什么能抽取特征？ 激活函数的种类和特点？sigmoid 反正切都有梯度消失问题 relu 快，\n\\11. pooling 层的作用？ ：http://blog.csdn.net/jiejinquanil/article/details/50042791\n12：什么是数据标准化，以及为什么要进行数据标准化？\n答：一般来说，数据标准化是减去均值再除以标准差，如果我们不进行数据标准化，那些数值范围大的特征将在成本函数中加权更多（如果大的特征变化 1%，则该变化相当大，但对于较小的特征，这是非常不明显的），数据标准化使所有特征均等加权！\n13：在神经网络中，为什么 ReLU 比 Sigmoid 更常用？\n答：【1】第一个问题，为什么要引入非线性激活函数？\n如果不用激励函数（其实相当于激励函数是 f(x) = x），在这种情况下你每一层输出都是上层输入的线性函数，很容易验证，无论你神经网络有多少层，输出都是输入的线性组合，与没有隐藏层效果相当，这种情况就是最原始的感知机（Perceptron）了。\n正因为上面的原因，我们决定引入非线性函数作为激励函数，这样深层神经网络就有意义了（不再是输入的线性组合，可以逼近任意函数）。\n【2】第二个问题，为什么要引入 Relu?\n第一，采用 sigmoid 等函数，算激活函数时（指数运算），计算量大，反向传播求误差梯度时，求导涉及除法，计算量相对大，而采用 Relu 激活函数，整个过程的计算量节省很多。\n第二，对于深层网络，sigmoid 函数反向传播时，很容易就会出现梯度消失的情况（在 sigmoid 接近饱和区时，变换太缓慢，导数趋于 0，这种情况会造成信息丢失，从而无法完成深层网络的训练。\n第三，Relu 会使一部分神经元的输出为 0，这样就造成了网络的稀疏性，并且减少了参数的相互依存关系，缓解了过拟合问题的发生。\n14：解释一下 PCA(Principal Component Analysis)\n15：解释下降维，什么时候降维，以及使用它的好处？\n1：降维的作用？\n（1）降低时间的复杂度和空间复杂度\n（2）节省了提取不必要特征的开销\n（3）去掉数据集中夹杂的噪音\n（4）较简单的模型在小数据集上有更强的鲁棒性\n（5）当数据能有较少的特征进行解释，我们可以更好地解释数据，是的我们可以提取知识\n（6）实现数据的可视化\n2：降维的目的？\n用来进行特征选择和特征提取。\n①特征选择：选择重要的特征子集，删除其余特征；\n②特征提取：由原始特征形成的较少的新特征。\n在特征提取中，我们要找到 k 个新的维度的集合，这些维度是原来 k 个维度的组合，这个方法可以是监督的，也可以是非监督的，如 PCA 是非监督的，LDA 是监督的。\n16：如何处理数据集中的缺失值？\n答：你可以直接删掉缺失值，也可以使用一些新值来填充缺失值，在 pandas 中可以使用 isnull() 和 dropna() 方法帮助你发现缺失值所在的行和列并删掉，如果你想填充缺失值，你可能会需要使用 fillna() 函数。\n17：解释下聚类算法？\n18：你如何进行数据探索（EDA）?\n19：Why do we use convolutions for images rather than just FC layers?\n编程题\n\n1~n 这 n 个数现在去掉两个，如何找到去掉的两个数。 假设去掉的两个数是 a 和 b，那么通过求和，平方和可以知道 a+b 和 a^2+b^2，然后解方程就行了。\nchar a[4] = {1, 2, 3, 4}; char *b = a; b[0] = 100; 请问输出 a 的结果是什么？\n一个 N*M 的矩阵，从左上走到右下最小需要（N+M）步走完，问一共有多少种走法。\n一个严格递增的数组，将前缀取一部分放在后面，在修改后的数组上找到最小的数。(剑指 Offer 原题)\n一个大写字符串如 ABABB（len&lt;1000），代表游客进游乐场的顺序及从哪个入口进入，要求每个入口 (不多于 26 个入口) 从第一个游客直到该入口的最后一个游客，检票员都不能离开，问最少检票人数 K。\n一个字符数组中，每个字符都出现了 3 次，只有一个出现了 2 次，如果快速找出这个出现 2 次的？\n一个字符矩阵，只可能是 R,G,B 三种字符。判断是否满足某个条件。这个条件是每种符号连成一个长方体，三个长方体长宽一致, 且横着平行\n一个广告，它有一个 id，一个上线时间，一个下线时间，现在我有很多这样的广告，如果现在给你一个时间，告诉我有多少个广告在这个时间在线的\n一个数据流中，如何采样得到 100 个数，保证采样得到的 100 个数是随机的？\n一个数组中某个数出现次数大于一半，最快找出该数。\n一个数组只有一个数字是单独出现，其他出现了三次。\n一个数组存着 1-1000 连续的整数，假如我取出其中一个数，怎么能快速找到（用类二分查找）\n一个数组存着负数与正数，将正数放在前面，负数放在后面\n一个运算序列只有 +、*、数字，计算运算序列的结果。（Code）\n一堆 ip 地址区间，不会重叠，来一个新的 ip 地址，看它在不在，在哪个区间。\n一维数组，swap 其中的几对数字（每个数字只属于一次 swap 操作），实现查找（与二分有关）；\n一维有序数组，经过循环位移后，最小的数出现在数列中间，如果原数组严格递增或递减，如何找这个最小数；\n一维有序数组，经过循环位移后，最小的数出现在数列中间，如果原数组严格递增，如何找这个最小数。\n一维有序数组，经过循环位移后，最小的数出现在数列中间，如果原数组非严格递增或递减，如何找这个最小数；\n一维有序数组，经过循环位移后，最小的数出现在数列中间，数组可能是递增、递减、递减后递增、递增后递减四种情况，递增递减都是非严格的，如果有转折点，返回转折点的值，否则返回 - 1；\n一道题：给定一个整数数组，里面有两个数相同，其他数都是不同的，如何尽快找到这两个数（答，用 hash 表，O（N），有更好的方法么？）\n一题是多位数用链表存储（ e.g. 123 用 1-&gt;2-&gt;3 存储），实现相加功能函数\n不创建临时产量换两个数\n两个同样大小有序数组求中位数，写代码\n两个大整数相乘。（Code）\n两棵树相加——对应位置两棵树都有值则相加，对应位置只有一棵树有值则取该值；\n中序遍历二叉树，利用 O(1) 空间统计遍历的每个节点的层次。（Bug Free Code）\n中缀表达式转逆波兰表达式，逆波兰表达式求值；\n为分析用户行为，系统常需存储用户的一些 query ，但因 query 非常多，故系统不能全存，设系统每天只存 m 个 query ，现设计一个算法，对用户请求的 query 进行随机选择 m 个，请给一个方案，使得每个 query 被抽中的概率相等，并分析之，注意：不到最后一刻，并不知用户的总请求量。\n二分查找\n二分查找，查找 target，在区间 [start，end] 之间，如果有重复元素，返回最后一个下标，其他情况返回 - 1\n二叉树前序递归遍历算法（手写代码）\n二叉树的前中后遍历\n二叉树的文件存储，也就是序列化。\n二叉树遍历，描述下层序遍历。\n二维数组，每行递增，每列递增，任意交换其中的两数，发现并恢复。\n二维数组，每行递增，每列递增，实现查找。\n二维数组，每行递增，每列递增，求第 k 大的数。\n什么样的数据结构可以满足多次插入删除，取最小数，给出时间复杂度。\n介绍二叉树前序遍历非递归遍历算法（手写代码）\n介绍大顶堆和小顶堆\n从一组数中找出和为 sum 的三个数（leetcode 原题，先 sort 再找，并且剪枝），写代码，四个数呢？说思路。\n假设有个 M*N 的方格，从最左下方开始往最右上方走，每次只能往右或者往上，问有多少种走法，假设中间有若干个格子不能走，又有多少种走法。\n允许两个元素交换一次的最大连续子序列和。\n全排列\n全排列。\n冒泡排序 (手写代码)\n写 find 函数，在目标串中匹配模式串（要考虑中文字符的情况）\n写一个二叉树的非递归的后续遍历\n写一个简单的正则匹配表达式 (将文本中的 123.4 匹配出来)\n写个动态规划，最长公共子序列\n判断一个字符串是否为另外一个字符串旋转之后的字符串\n前 k 大的数\n单链表的翻转\n去掉连续的重复数字，输出新数组，例如：1，2，2，2，1，3，5——&gt; 3，5。\n去除字符串 S1 中的字符使得最终的字符串 S2 不包含’ab’和’c’。（Code）\n合法括号匹配\n在一个字符串中，找出最长的无重复字符的字串\n在二叉树结点结构中加一个指针域，使其指向层次遍历的下一个结点，特别地，每一层的最后一个结点为空。（Code）\n堆排序 (手写代码)\n堆是怎么调整的。\n复杂链表的复制。\n如果给出一个二叉搜索树的后续能不能建立（可以，因为只要将遍历结果排序就可以得到中序结果）。\n字符串反转（手写代码）\n字符串移位，给出字符串 abc##dfg##gh，实现将所有 #移至字符串串头。输出 ####abcdfggh。\n字符串转整数\n字符串，给一个 url，求中间的 site\n字符串，给一个 url，求中间的 site。\n定义满足 $n=x^a+y^b$（$x，y，a，b$ 是非负整数）的 n 是神奇数。如 $4 = 2^0 + 3^1,17 = 2^3 + 3^2$。输入 l 和 r，请求出闭区间 $[l,r]$ 里，最长的一段不含有神奇数的连续区间长度。$x,y,l,r&lt;=10^{18},x&gt;=2,y&gt;=2$，如 $3\\ 5\\ 10\\ 22$，在 $[10,22]$ 区间内，$x=3,y=5$ 的条件下，区间内 [14] 是神奇数，所以最长的区间是 $[15,22]$ 长度为 $8$，如 $2，3，1，10$，在 $[1,10]$ 区间内，$x=2，y=3$ 的条件下，$2，3，4，5，7，9$ 都是神奇数，所以最长的区间只有长度 $1$。\n实现栈，使得 添加、删除、max 操作的复杂度为 O(1)。\n对于一个字符串，请设计一个算法，只在字符串的单词间做逆序调整，也就是说，字符串由一些由空格分隔的部分组成，你需要将这些部分逆序。给定一个原字符串 A 和它的长度，请返回逆序后的字符串。\n对于一个字符串，请设计一个算法，将字符串的长度为 len 的前缀平移到字符串的最后。\n寻找字符串中第一个只出现一次的字符；\n将字符串连续重复出现的字符删到只剩一个，这个可以用双指针，时间复杂度 n，空间复杂度 1。\n常用排序算法的时间和空间复杂度\n平衡二叉树是什么\n归并排序 (手写代码)\n快速排序 (手写代码)\n快速排序 + 二分查找\n手写快排 (easy)\n打印数组的组合数。\n打印螺旋数组；\n把一个 bst 转化成一个双向链表。\n把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，不能申请额外的空间。例如 AbcDeFGhi -&gt;bceiADFG\n排序二叉树转双向链表。（Code）\n描述 Dijkstra 最短路径算法\n插入排序 (手写代码)\n数列中找第 k 大的数字（与快排或堆排序有关）\n数据解压缩，3(a4(ab)) -&gt; aababababaababababaabababab；\n数组有只有一个数出现一次，其他数都出现三次，找出那个数。\n旋转数组\n最少时间复杂度求数组中第 k 大的数。（Code）\n最短路径代码。\n最长公共子串（动态规划有关）；\n最长公共子序列\n有一堆无向好友列表 1-2， 3-4, 2-3 之类的，问能不能把这些用户划分两组，组内都不互为好友。\n有序数组寻找和为某数的一对数字；\n正数数组，找三个数使积最小，问有多少种选择。\n母鸡、公鸡和小鸡问题：公鸡五块一只，母鸡三块一只，小鸡一块三只，用 100 元买 100 只鸡的所有方法。\n求 double 类型的二进制 1 的个数。\n求二叉树最近公共祖先 (leetcode 原题)\n求连续子数组最大乘积，还让考虑边界问题（最后问了：连乘有可能导致溢出，存不下了）\n用一个队列，将每个二叉树的 root 先放入队列。\n用数组实现队列，各操作的复杂度分析。\n用速度不同的指针可以判断链表中是否有环，问两速度满足怎样的关系可以保证发现环。\n直接插入排序写代码\n看段代码，问输出是啥。(就是段求二进制中 1 的个数)\n矩阵求最长连续递增的路径长度\n矩阵求最长连续递增的路径长度。\n第一题是链表倒数第 k 节点；第二题是二叉树打印路径，第三题是矩阵中将 0 元素所在行列全置 0 的最优空间解法\n第二轮是写出一个算法输出二叉树的 s 序列，何为 s 序列，比如现在有个二叉树 1-2,3-4,5 6,7 这是一颗完全二叉树， S 序列输出就是按照 1237654 这个顺序输出，用两个栈就能实现比较简单。\n算法题，也只记得一个了：存在一个数组，大小 98，里面的元素均为在 [1,100]，且无重复， 不申请额外空间的情况下，在时间复杂度为 O(N) 情况下，找出缺失的两个元素值。\n给一个 n*n 的矩阵，矩阵中满足每行每列都是递增的，要查找矩阵是否存在某个数.(leetcode 原题)\n给一个数组，只有一个元素出现了一次，其他都出现了两次，找出出现一次的数。\n给一个数组，数组种存在一种数，它的左边都比它小，右边都比它大，找出所有这些数的位置。\n给一个股票，n 天的价格，只能两次买入卖出，而且只能只能先卖再买，问最多赚多少钱？\n给一个股票，n 天的价格，只能进行一次买入和卖出，问最多赚多少钱？\n给一个股票，n 天的价格，可以买入卖出 k 次，而且只能只能先卖再买，问最多赚多少钱？\n给一个股票，n 天的价格，可以无限次买入卖出，问最多赚多少钱？\n给了一个链表，第 1 个结点标号为 1，把链表中标号在 M 到 N 区间的部分反转。\n给你一个无重复的数组输出全排列。\n给你一颗二叉树按层输出每一层输出后都换行\n给出一个二维矩阵，从（0,0）出发走到右下角，只能向右或向下走，找到一条路径，是这条路径上的总和最大。\n给出一段代码问代码作用（二进制数据 1 的个数）\n给出一颗二叉树，两个叶节点，找到这两个叶节点互连通的一条最短路径。\n给定一个数组，只有一个元素出现了一次，其他都出现了 3 次，找出出现一次的数。\n给定一个数组，有两个元素出现了一次，其他都出现了两次，找出两个出现一次的数。\n给定一个正整数向量，判断这个向量是否存在一个片段，使得反转这个片段后能够使该向量升序排列。如：[1, 2, 4, 3]，就可以通过反转 [4, 3] 使得向量变为[1, 2, 3, 4]。\n给定二叉树的先序跟后序遍历，能不能将二叉树重建（不能，因为先序：父节点 - 左节点 - 右节点，后序：左节点 - 右节点 - 父节点，两者的拓扑序列是一样的，所以无法建立）\n给定循环递增数组 $a=[7,8,9,1,2,3]$ 和一个值 $k=2$, 返回该值得再数组中的下标。\n给定数组 A[]={1,4,7,…} 和一个数 T。求和为 T 的 A 中的数最少要几个。A 中的数可复用。 我写了个递归，面试官不建议使用，因为效率不高。但没有反对。\n给定数组，寻找 next big（堆排序有关）；\n给我一个数组［1，2，5，10，20，50，100］，可以从里面取若干个数，要求得出和为 100 的不同取法有多少？（说出思路）\n统计数列中的逆序对（归并排序有关）；\n编程题：实现求正整数平方根整数部分的函数（使用梯度下降）\n翻转二叉树（Code）\n若干个二叉树，如何按照层序遍历\n设 rand （ s ， t ）返回 [s,t] 之间的随机小数，利用该函数在一个半径为 R 的圆内找随机 n 个点，并给出时间复杂度分析。\n输入一个大长方形，长宽 ab，和一堆小长方形。选择两个小长方形，它能放进大长方形，而这个小长方形面积和最大。\n输入两个正数数组，在两个数组分别选一个数，要求第一个数组选的数的下标小于第二个数组选的数的下标。使得两个数的乘积最大。\n输出字符串中的所有重复子串，例如：abcab，输出: a, b, ab\n连续子数组最大和\n迷宫的深度搜索、广度搜索；\n选取任意数据结构实现添加、删除、随机返回三个功能，分析复杂度。\n选择排序 (手写代码)\n链表上的快速排序。\n长度为 N 的序列 Sequence=abc…Z，问有多少不同的二叉树形态中序遍历是这个。（Code）\n问了一两个算法题，记不清了，只记得其中一个是：找数组中 2 个出现两次的数字，还有 3 个两次的数字\n问了一个 1 的平方加到 100 的平方结果\n非常经典的 0-1 背包问题\n字符串移位，给出字符串 abc##dfg##gh，实现将所有 #移至字符串串头。输出 ####abcdfggh（个人认为可以用后向移位，减少移位次数）\n给出一个二维矩阵，从（0,0）出发走到右下角，只能向右或向下走，找到一条路径，是这条路径上的总和最大。（个人认为使用动态规划或深度遍历）\n给出一颗二叉树，两个叶节点，找到这两个叶节点互连通的一条最短路径。（个人认为主要是找两个叶节点的最近公共祖先）\n\n智商题\n100 张牌，每次只能抽一张，抽过的牌会丢掉，怎么选出最大的牌。\n36 匹马，6 条跑道，选出最快 3 匹，最少赛多少场？\n5 个海盗抢到了 100 颗宝石，每一颗都一样的大小和价值连城。他们决定：抽签决定自己的号码（1，2，3，4，5）。首先，由 1 号提出分配方案（你抽到 1 号），然后大家 5 人进行表决，当且仅当超过半数的人同意时，按照他的提案进行分配，否则将被扔入大海喂鲨鱼。如果 1 号死后，再由 2 号提出分配方案，依此类推。条件：每颗宝石都是一样的价值。海盗都想保命，尽量多得宝石，尽量多杀人。问题：你会提出怎样的分配方案才能够使自己的收益最大化？\n一个人要过一座 80 米的桥，每走一米需要吃一颗豆子，他最多可以装 60 颗豆子，问最少需要吃多少颗豆子才能走完桥？证明一下为什么你给的答案是最少的？桥长 81 米呢？当桥长 n 米，最多装 m 颗的时候结果用公式怎么表示？\n一个绳子烧完需要 1 个小时，假设所有绳子的材质都不一样，也不均匀，怎么取出 1 小时加 15 分钟。\n把 1~9 这 9 个数填入九格宫里, 使每一横、竖、斜相等。\n有 100 个黑球，100 个白球。两个桶，桶的容量无限，每个球都可以任意放在任何一个桶中，没有限制，请设计一种分配方法，使得白黑球分配到两个桶之后, 某个人从某个桶中取出的球是白球的概率最大化。（这个人去第一个桶取球的概率是 1/2, 第二个桶也是 1/2）\n有 1 亿个货物，不能单个单个检测，只能通过两两对比来找出其中的次品，请设计一个算法来找出次品。\n有 25 匹马，5 个跑道，一次只能比 5 匹马，得到跑得最快的前 3，至少需要比几次？\n有 3 盏灯，房间外有 3 个开关，你只有 1 次机会进入房间，怎么判断哪个开关对应哪盏灯？\n给一堆螺母和螺栓，它们可以一一对应，但是现在顺序乱了，只能用螺母和螺栓比较，将它们一一对应起来。\n大数据\n\n100 亿数字，怎么统计前 100 大的？\n10 亿个 url，每个 url 大小小于 56B，要求去重，内存 4G。\n1KW 句子算相似度（还是那套分块 + hash / 建索引，但是因为本人不是做这个的，文本处理根本说一片空白，所以就不误导大家了），之后就是一直围绕大数据的题目不断深化。\nQ1：给定一个 1T 的单词文件，文件中每一行为一个单词，单词无序且有重复，当前有 5 台计算机。请问如何统计词频？\nQ2：每台计算机需要计算 200G 左右的文件，内存无法存放 200G 内容，那么如何统计这些文件的词频？\nQ3：如何将 1T 的文件均匀地分机器统计配给 5 台机器，且每台完词频生成的文件只需要拼接起来即可（即每台机器统计的单词不出现在其他机器中）\n一个大文件 A 和一个小文件 B，里面存出在的是单词，要求文件 B 中但不在文件 A 中的单词。然后大文件 A 是无法直接存到内存中的。\n一道题目是如果有一个人注册一个 qq，如何保证这个 qq 号码和之前已存在的 qq 号码不重复呢？\n扔硬币，连续出现两次正面即结束，问扔的次数期望\n有 100W 个集合，每个集合中的 word 是同义词，同义词具有传递性， 比如集合 1 中有 word a, 集合 2 中也有 word a, 则集合 1，2 中所有词都是同义词，对这 100W 个集合进行归并，同义词都在一个集合当中。\n有几个 G 的文本，每行记录了访问 ip 的 log ，如何快速统计 ip 出现次数最高的 10 个 ip，如果只用 linux 指令又该怎么解决；\n海量数据的 topk 问题\nhadoop+spark+yarn 大数据处理【具体内容很多，若要详细了解需要花费很长时间】\n\n计算机基础\n1:Linux 下的一些指令，$$（进程 id），$?（上一条命令退出时状态），怎么查看进程，按照内存大小，CPU 占用排序等等。\n2:Linux 的命令：pwd、ln、which\n3:Linux 线程通信\n4:hash 表是怎么实现的？有冲突的时候怎么处理？\n5:linux 文件词频统计\n6: 介绍一下 hash，怎么解决冲突。\n7: 你说一下 hashmap 的原理\n8: 内存泄露出现原因。\n9: 悲观锁乐观锁\n10: 把两个表按 id 合并怎么搞？\n11: 数据库 transaction\n12: 浅拷贝深拷贝\n13: 第二题是两题 sql ，涉及 join,group by,max,min,sum,count 等操作的结合，以及同个题目多种写法。\n14: 线程安全是什么意思？新线程什么情况下会影响原有线程？\n答: 并发基础知识 — 线程安全性，参见 https://www.cnblogs.com/tcming/p/6711506.html\n15: 网络基础 TCP 三次握手\n答：参见 https://blog.csdn.net/qq_18425655/article/details/52163228\n16: 计算机网络：描述他发一句 helloworld 到我这边显示，中间经历了哪些过程，我从应用层开始一层层往下分析答的，主要说 http 和 tcp，网络层和链路层有些忘，但主要的几个协议和子网划分什么的也答了，面试官比较满意\n17: 词向量的推导，混合高斯，linux 硬链接，三次握手，linuxinode\n18: 进程线程的区别\n答：(1) 进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。\n(2) 线程是进程的实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。\n(3) 一个进程可以有多个线程，多个线程也可以并发执行\n19：说一下在浏览器地址栏输入 url 之后的一系列过程？\n答：参见 https://blog.csdn.net/lamiant/article/details/54947281\n​         DNS 解析过程，参见 https://www.zhihu.com/question/23042131\n​         ARP 解析过程，参见 https://blog.csdn.net/wswit/article/details/52578878\n20：fork 过程，fork,vfork 以及 clone 的区别（从源码分析）？&lt;腾讯面试&gt;\n21：僵尸进程，怎么避免僵尸进程？&lt;腾讯面试&gt;\n参考博客：https://www.cnblogs.com/Anker/p/3271773.html\n22：从汇编层解释一下引用？&lt;腾讯面试&gt;\n23：中断的作用？&lt;腾讯面试&gt;\n24：tcp 连接关闭过程，time-wait 的作用，如果此时系统中有很多 time-wait 连接，你该怎么做？\n参考博客：https://blog.csdn.net/yusiguyuan/article/details/21445883\n以及博客：https://segmentfault.com/a/1190000003509876\n25：DDos 攻击原理？&lt;腾讯面试&gt;\n26：数据库引擎？&lt;腾讯面试&gt;\n27：数据库三个重要范式？&lt;腾讯面试&gt;\n28：网络层，数据链路层，运输层的设备以及协议有哪些？&lt;腾讯面试&gt;\n29：网络层，数据链路层，传输层的寻址方式分别是什么？&lt;腾讯面试&gt;\n30：AVL 树，B + 树，红黑树?&lt;腾讯面试&gt;\n31: 数据库索引，事务？&lt;腾讯面试&gt;\n概率题\n\n100 人坐飞机，第一个乘客在座位中随便选一个坐下，第 100 人正确坐到自己坐位的概率是？\nX 是一个以 p 的概率产生 1,1-p 的概率产生 0 的随机变量，利用 X 产生 1/2 概率是 0,1/2 概率是 1 的随机变量。\nX，Y 均服存于 [0,1] 的均匀分布，求 X+Y。\n一个国家重男轻女，只要生了女孩就继续生，直到生出男孩为止，问这个国家的男女比例？\n一个有 7 个格子的环，三种颜色染色，相邻不能颜色重复，问多少种方案\n一个袋子里有很多种颜色的球，其中抽红球的概率为 1/4，现在有放回地抽 10 个球，其中 7 个球为红球的概率是多少？\n一枚硬币，扔了一亿次都是正面朝上，再扔一次反面朝上的概率是多少？\n一道概率题，54 张牌，平均分成三堆，大小王在同一堆的概率？\n一道概率题，一个六位的密码，由 0~9 组成，问你正过来看和倒过来看密码是一样的概率。\n一道组合数学题。10 盏灯，灭三盏，两头的必须亮着，不能灭掉相邻的两盏灯，问组合数？\n三个硬币，分别是正正，反反，正反。随机抛一个硬币，结果是正面，问选的是那个硬币\n个人玩游戏，100 个球，每次挑 5 个，如何保证必胜。52 张牌，四个人抽，黑桃 A 和红桃 A 同时在一个人手里的概率。\n好像是问有 70% 的人喜欢玩游戏，30% 的人不喜欢玩游戏，现在推送的资源必须是 50% 游戏，50% 非游戏。问怎么分配比较合理。\n有 n 个 elements 和 1 个 Compare(A, B) 函数，用 Compare 函数作为排序算法中的比较算子给 elements 排序。Compare 函数有 p 的可能比较错。排序完取 Top m 个元素，本来就在 Top m 并被正确分在 Top m 的元素个数是 x。问 x 的数学期望。\n有两个随机数产生器，R1 以 0.7 的概率产生 1，以 0.3 的概率产生 0，而 R2 以 0.3 的概率产生 1，0.7 的概率产生 0. 问如何组合这两种产生器，使新得到的随机数产生器以 0.5 的概率产生 1，0.5 的概率产生 0。随机数产生器可复用。\n有两枚硬币 A 和 B，A 正面的概率为 0.6，B 正面的概率为 0.5. 现在扔了一枚硬币显示为正面，问：该枚硬币是 A 的概率是多少？\n概率题：有种癌症，早期的治愈率为 0.8，中期的治愈率为 0.5，晚期的治愈率为 0.2. 若早期没治好就会转为中期，中期没治好就会变成晚期。现在有一个人被诊断为癌症早期，然后被治愈了，问他被误诊为癌症的概率是多少？\n给一个函数，返回 0 和 1，概率为 p 和 1-p，请你实现一个函数，使得返回 01 概率一样。\n给定一个分类器 p，它有 0.5 的概率输出 1，0.5 的概率输出 0。Q1：如何生成一个分类器使该分类器输出 1 的概率为 0.25，输出 0 的概率为 0.75？Q2：如何生成一个分类器使该分类器输出 1 的概率为 0.3，输出 0 的概率为 0.7？\n问了一个概率题 54 张牌，分成 6 份，每份 9 张牌，大小王在一起的概率\n\nHR 常问问题\n\n为什么不读博、对读博报以什么态度。\n为什么选择百度，谷歌百度都给你 offer 你选哪个。\n为什么选择跨专业学计算机？\n为什么选择阿里\n以后可能要学习很多新技术，你怎么看。\n你平时喜欢做什么？看过哪些书？最近在看什么书？\n你觉得最有挑战的项目是什么。\n你觉得最难忘的事情是什么？\n你认为你的优（缺）点是什么。\n你还有什么想问的？\n加班怎么看。\n印象最深刻的事？\n压力最大的情况是什么时候。\n在面试过程中觉得自己那些当面有进步\n场景分析题，有一个任务给你，要求一个月完成，但是以目前的能力一个月完成不了，现在你知道有一个同事擅长这部分工作，但是他有自己的活，帮助你就可能耽误他的进度，问你咋办。\n大学令你觉得最不爽的事情是什么\n如何学习的？\n如何看待加班。\n实习期间项目，在组内担任的角色，是否熟悉其他组员的工作。\n家庭教育观念？\n家里什么情况？独生子女？\n将来的职业规划？\n工作地点\n工作地点的问题\n平时有什么兴趣爱好。\n我觉得我会先去专心钻研技术，到达一定的\n最后问了一下我兴趣爱好\n有什么问题问我。\n有没其他 offer\n有没有想过去创业公司\n现在在哪里实习？实习主要做些什么？\n简单介绍一下自己\n聊聊 offer 情况，有什么考虑之类的。\n聊聊实验室生活。\n能不能来北京\n自己有什么优点缺点？\n自己本科生和研究生相比有哪些进步\n要求用两个字评价大学生涯。\n讲一下你觉得你突出的地方，有亮点的地方。\n评价一下你自己的优点缺点？\n详细介绍项目。\n说下你的优缺点\n说说你的经历。\n说说你自己的性格。\n说说研究生阶段最有成就的事，遇到问题具体怎么解决的。\n请你说一下你对应聘该岗位的优势。\n遇到的最大挫折是什么。\n问你的职业规划，遇到挑战怎么处理，有没有之前和同事发生过较大分歧。\n\n开放题\n\n2016 年每个项目有个上线和下线时间段，统计每天在线的项目数量\n一堆问题和答案的 pair，算它们的相关性\n一面现场面，自我介绍加挑一个项目细讲，还有场景题，第一题是 QQ 添加好友按名称搜索时，怎么区别广告号，诈骗号；\n为什么之前没有深度网络出现（数据量不够 + 机器性能）\n为今日头条设计一个热门评论系统，支持实时更新。\n从项目中在哪一方面体会最深。\n假设一个文档，连续的 K 个词，认为是一个时间窗口，一个时间窗口的词有关系，如何得到所有的时间窗口。\n假设你拥有一切搜索数据，问怎么在不同场景下进行推荐，具体场景忘了（核心点：共线性、语义相似度、主题聚类等等）\n假设有 100W 个单词，如何存储（我答的是 trie 树，面试官问每个节点会有很多子节点，每个子节点是一个指针，占用 8 个字节，如何节省空间，我说不知道，面试官提示双数组 trie 树）\n假设要对一场 nba 球赛进行自动解说，会遇到哪些困难，又该怎么解决呢？\n做过哪些项目？项目中遇到哪些难点，你是怎样解决的？\n关于集群调度的一些经验 trick 掌握多少；\n分词时，为了提高效率，怎么存储词典？（键树）如何压缩存储？\n在微信的场景下，如何判断用户的职业？开放问题\n场景题如何鉴别淘宝上卖假货的商家，价格维度可以用什么策略等\n如何做一个新闻推荐\n如何在语料中寻找频繁出现的字串，分析复杂度。\n如何用尽可能少的样本训练模型同时又保证模型的性能；\n如何预测双十一支付宝的负载峰值。\n对推荐算法的未来看法。\n平面上有 n 个点，让你设计一个数据结构，能够返回这个这 n 个点中距离某特定点最近的一个点。一开始讲了下 kd 树，然而太复杂面试官不满意，就讲了一个类似 GeoHash 的方案。\n建立一个数据结构，基于此写一段程序用于存储 sparse vector，同时编写一个函数实现两个 sparse vector 的相加运算\n很多单词，如何计算单词之间的相似度（或者对单词进行分类）\n怎么预测降雨量。\n我只有一大批实体词， 如何对他们进行聚类（无监督聚类）， 如何找出这些词中， 哪些词之间有关系， 是强关系还是弱关系， 具体是什么关系，（如刘德华和朱丽倩 属于娱乐分类， 是强关系， 关系为夫妻）\n拼车软件是如何定价的以及如何优化。\n推荐算法（基于用户的协同过滤，基于内容的协同过滤）\n推荐系统的冷启动问题如何解决\n文本挖掘中，分词算法？如何选取特征？如何进行相似度计算，文本聚类结果如何评估？\n无给定条件，预测蔬菜价格。\n有 100W 个集合，每个集合中有一些词，对于每个集合，找出他是哪些集合的真子集。\n有一堆已经分好的词，如何去发现新的词？\n比赛相关问题提特征特征选择等\n海量的 item 算文本相似度的优化方法；\n特征工程经验。\n用两分钟介绍自己的项目，创新点在哪里。\n用户给三个 item（query），如何给出查询网页。\n第三题是如何鉴别实施诈骗的 QQ 用户；\n第二题是微信朋友圈内容的安全鉴别；\n第四题是如何做反作弊，例如公众号的刷阅读量。\n系统设计题，给一个 query，如何快速从 10 亿个 query 中找出和它最相似的 （面试官说可以对每个 query 找 1000 个最相似的，存起来，每天离线更新）\n线性代数：特征线性依赖，出现冗余，会导致什么问题？\n给一堆数据找找到最佳拟合的直线，数据有较多噪声\n给你一个系统（面试官好像是无人车部门的），后台的逻辑已经实现了，但是前端加载很慢，怎么检测。\n给你两个文件 a 和 b，大小大概 100M，两个文件每行一个整数，要求找到两个文件中相同的整数，存到文件 c 里，问我怎样尽快的完成这项工作？\n给出一个算法实现如何确定快递邮件上的地址，要求从国家到省市到县到乡镇的一个识别，要求效率高（有陷阱，比如有的人把县写到市的前面，有人喜欢写地域名称的省略词比如安徽省写成安徽或者皖）。\n给定淘宝上同类目同价格范围的两个商品 A 和 B，如何利用淘宝已有的用户、商品数据、搜索数据、评论数据、用户行为数据等所有能拿到的数据进行建模，判断 A 和 B 统计平均性价比高低。统计平均性价比的衡量标准是大量曝光，购买者多则高。\n给很多单词，统计某个子串出现次数，我给的方法还是用 Trie，只不过一个单词要分成多个插入到 Trie 数中就行了。\n给很多单词，要求统计出现某个前缀出现次数。\n统计全球会弹钢琴的人数，我用机器学习的思路答的，面试官还比较满意\n自己项目中有哪些可以迁移到其他领域的东西。\n讲了讲自己在深度学习的认识，问的问题是几个具体场景的设计，包括怎么从海量数据中提取热点问题。\n设计 LRU 系统\n设计一个合理的电梯调度策略，调度两个电梯 ，考虑满足基本的接送需求，满足能耗最小，满足用户等待时间最短\n设计一个系统可以实时统计任意 ip 在过去一个小时的访问量；\n设计一个结构存取稀疏矩阵（面试官最后告诉我了一个极度压缩的存法，相同行或列存偏差，我当时没听懂，还不懂装懂，最后还是没记住）\n设计实现一个 git diff\n说一下最能代表你技术水平的项目吧？\n项目：具体问了特征怎么做的。\n（难到我了，我想的方法不好，面试告诉我了他的想法，类似于一个进程调度问题，每一时刻只可能有一个用户按按钮，把这条指令接收，判断当前电梯能否满足，能满足就执行，不能满足则放入一个队列里，实际情况还要细化）\n\n\n全文完\n本文由 简悦 SimpRead 优化，用以提升阅读体验\n使用了 全新的简悦词法分析引擎 beta，点击查看详细说明\n"},{"title":"bytedance 面筋集合","url":"/article/bytedance-%E9%9D%A2%E7%AD%8B%E9%9B%86%E5%90%88/","content":"提前批的，面试拖了好久，今天刚面完交叉面，虽然还没有意向书，也先发下面经，回馈下牛友\n面的是上海的ailab\n一面\n1、上来直接问论文，他基本上没有问啥细节，主要是我在讲\n2、一道算法题\n稀疏向量的点乘 要求：尽量高效地实现，需要同时考虑时空复杂度。\n代码是当时写的，不一定bug free\n`#include &lt;iostream&gt;``using` `namespace` `std;``struct` `Node&#123;``    ``int` `index;``    ``int` `value;``&#125;;` `int` `func(Node[] v1, Node[] v2)&#123;``    ``int` `p1 = 0, p2 = 0;``    ``int` `ret = 0;``    ``int` `len1 = ``sizeof``(v1) / ``sizeof``(Node);``    ``int` `len2 = ``sizeof``(v2) / ``sizeof``(Node)；``    ``while``(p1&lt;len1 &amp;&amp; p2&lt;len2)&#123;``        ``int` `index1 = v1[p1].index, index2 = v2[p2].index;``        ``if``(index1 == index2)&#123;``            ``ret += v1[p1].value * v2[p2].value;``            ``p1++;``            ``p2++;``        ``&#125;``else` `if` `(index1 &lt; index2)&#123;``            ``p1++;``        ``&#125;``else``&#123;``            ``p2++;``        ``&#125;``    ``&#125;``    ``return` `ret;``&#125;` `int` `main() &#123;``    ``cout &lt;&lt; ``&quot;Hello World!&quot;` `&lt;&lt; endl;``&#125;`\n二面\n1、先问项目的一些细节\n2、深度学些基础\nsmoothL1\n$$\n\\operatorname{smooth}{L{1}}(x)=\\left{\\begin{array}{ll}{0.5 x^{2}} &amp; {\\text { if }|x|&lt;1} \\ {|x|-0.5} &amp; {\\text { otherwise }}\\end{array}\\right.\n$$\n\n相比于L1损失函数，可以收敛得更快。\n相比于L2损失函数，对离群点、异常值不敏感，梯度变化相对更小，训练时不容易跑飞。\n\n\n\n\n\nfpn的结构\n特征金字塔是处理多尺度物体检测问题的一个基础组成部分。然而，最近基于深度学习的物体检测算法考虑到计算量和内存限制都尽量避免采用特征金字塔的方式。在这篇文章中，利用深度卷积网络本身固有的多尺度、层次结构来构造特征金字塔，它的好处是只会带来极小的额外消耗。具体的，本文构造了一种自顶向下、带有侧向连接的层次结构来构建各个尺度的高层语义特征。这种方法称之为Feature Pyramid Network (FPN)。FPN可以作为一种通用的特征提取器，并且在多个任务上带来了显著的性能提升。将FPN应用于Faster RCNN，在COCO上达到了最佳的单模型性能。另外，FPN的推理速度在GPU上可以达到5FPS，因此是一种检测性能高，同时推理速度能达到实际使用的方法。\n\nroi pooling和roi align的区别\n\n\n\n\n\n\n3、数据结构基础\n链表判断是否有环\n归并排序描述\n二叉排序树时间复杂度\n\n如果二叉排序树是平衡的，则n个节点的二叉排序树的高度为Log2n+1,其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。因此，为了获得较好的查找性能，就要构造一棵平衡的二叉排序树。\n\n4、算法题\nleetcode958  判断是否是完全二叉树\n三面\n1、问比赛，主要是我在介绍\n2、介绍下cascade rcnn\n3、算法题\nleetcode3 最长不重复子串\n交叉面\n1、论文讲下，没有提问题\n2、RPN介绍一下\n![image-20190829204113463](/Users/xiongz/Library/Application Support/typora-user-images/image-20190829204113463.png)\n![image-20190829204039728](/Users/xiongz/Library/Application Support/typora-user-images/image-20190829204039728.png)\n3、inception介绍一下\n4、depthwise 卷积\n5、shufflenet\n\n\n\n\n对分类，分割检测，视频理解哪方面比较熟悉？\n\n答：对分类，分割比较熟悉\n\n\n那我们问一下检测方面的问题吧（我：？？？），你了解faster rcnn吗，大致介绍一下\n\n\n再问一个分割检测方面的，了解nms吗，大致介绍一下\n\n\n\n同一个人可能有好几个框(每一个框都带有一个分类器得分)\n\n而我们的目标是一个人只保留一个最优的框：\n于是我们就要用到非极大值抑制，来抑制那些冗余的框： 抑制的过程是一个迭代-遍历-消除的过程。\n（1）将所有框的得分排序，选中最高分及其对应的框：\n\n（2）遍历其余的框，如果和当前最高分框的重叠面积(IOU)大于一定阈值，我们就将框删除。\n\n（3）从未处理的框中继续选一个得分最高的，重复上述过程。\n\nimport numpy as npdef py_cpu_nms(dets, thresh):    &quot;&quot;&quot;Pure Python NMS baseline.&quot;&quot;&quot;    x1 = dets[:, 0]    y1 = dets[:, 1]    x2 = dets[:, 2]    y2 = dets[:, 3]    scores = dets[:, 4]    areas = (x2 - x1 + 1) * (y2 - y1 + 1)    order = scores.argsort()[::-1]    keep = []    while order.size &gt; 0:        i = order[0]        keep.append(i)        xx1 = np.maximum(x1[i], x1[order[1:]])        yy1 = np.maximum(y1[i], y1[order[1:]])        xx2 = np.minimum(x2[i], x2[order[1:]])        yy2 = np.minimum(y2[i], y2[order[1:]])        w = np.maximum(0.0, xx2 - xx1 + 1)        h = np.maximum(0.0, yy2 - yy1 + 1)        inter = w * h        ovr = inter / (areas[i] + areas[order[1:]] - inter)        inds = np.where(ovr &lt;= thresh)[0]        order = order[inds + 1]    return keep\n\n\n\n模型训练过拟合怎么办\n\n\n\n\n数据角度： 数据增强、增大数据量\n模型角度：换简单的网络，更换backbone，添加dropout，添加BN\n损失角度：添加正则项、加大正则项的权重\n\n\n\nBN为什么防止过拟合呢？\n\n\n大概意思是：在训练中，BN的使用使得一个mini-batch中的所有样本都被关联在了一起，因此网络不会从某一个训练样本中生成确定的结果。\n意思就是同样一个样本的输出不再仅仅取决于样本本身，也取决于跟这个样本属于同一个mini-batch的其它样本。同一个样本跟不同的样本组成一个mini-batch，它们的输出是不同的（仅限于训练阶段，在inference阶段是没有这种情况的）。我把这个理解成一种数据增强：同样一个样本在超平面上被拉扯，每次拉扯的方向的大小均有不同。不同于数据增强的是，这种拉扯是贯穿数据流过神经网络的整个过程的，意味着神经网络每一层的输入都被数据增强处理了。\n\n但是我回答的是BN为啥work的原因\n\n包括BN原论文解释的改善ICS现象，但是今年年初MIT的一篇论文《How Does Batch Normalizetion Help Optimization》推翻了这个结论，该论文认为\n\nBN带来的性能提升与ICS的减少无关。 并且在一定程度上认为BN并不能减少 ICS。\n发现了BN使得优化问题的曲面更加平滑，这使得梯度更容易预测以及允许更大范围的学习率和更快的网络vonvergence。证明了BN提升了模型的LOSS的Lipschitzness和梯度的Lipschitzness（β-smoothness）。**换个说法：**引入了 BN 后，损失函数相对于激活函数值的梯度幅值更小，也即损失函数更加利普希兹。损失函数相对于激活函数值的二阶项幅值更小，也即损失函数更加贝塔平滑。同理，损失函数相对于权重的梯度幅值也更小。 权重的最优解与初始解的距离也更小，也即神经网络更快就可以训练到最佳表现。（参考：https://www.zhihu.com/collection/226366658?page=4）\n提出了除了BN外，还有其他方式同样可以达到类似平滑效应，有些甚至效果更好。\n\n\n算法题：判断一棵树是不是完全二叉树\n#File Name : 是否为完全二叉树.pyclass Node(object):    def __init__(self,val=None):        self.val = val        self.left = None        self.right = None        def isCBT(head):    if not head:        return True    isLeaf = False    queue = [head]    while queue:        head = queue.pop(0)        left = head.left        right = head.right        if (not left and right) or (isLeaf and (left or right)):            # （not left） and  right 右边存在 左边不存在            #  或者是进入到全是叶节点状态后 有左或者右            # 这两种情况都会返回F            return False        if left:            queue.append(left)        if right:            queue.append(right)        if not left or not right:            isLeaf = True    return True\n问：AI lab业务偏多还是research偏多 面试官说：都会做，比较好的一点就是公司大中台战略，本身公司的业务场景就很多，所以有很多落地的工作可以做\n问：AI lab的扩招情况，发展态势？AI lab的规模？\n\n你投的哪个城市，我是目前在上海工作，如果你有兴趣的话可以到上海来\n\n二面 视频面（60min）2019/7/17\n自我介绍\n实习的工作是如何改进的\n为什么不用L1而用L2loss监督\nsobel算子介绍一下\nsobel核的参数为什么里面-1 -2，改变了参数后会发生什么事情？\n面试官本身是想让我回答不同的参数就能实现不同的功能效果，例如高斯模糊，腐蚀，锐化，膨胀等等\n讲一下Focal loss，它解决了一个什么东西？如何解决的?\n\n解决正负样本不均衡的问题：\nFocal Loss：\n在onestage的网络中，正负样本达到1:1000，这就会出现两个问题：1.样本不平衡   2.负样本主导loss。虽然负样本的loss小（因为大量的负样本是easy example，大量负样本是准确率很高的第0类），但个数众多，加起来的loss甚至大于了正样本的loss\n$$\n\\mathrm{FL}\\left(p_{\\mathrm{t}}\\right)=-\\alpha_{\\mathrm{t}}\\left(1-p_{\\mathrm{t}}\\right)^{\\gamma} \\log \\left(p_{\\mathrm{t}}\\right)\n$$\nfocal loss先解决了样本不平衡的问题，即在CE上加权重，当class为1的时候，乘以权重$\\alpha$，当class为0的时候，乘以权重$1-\\alpha$，这是最基本的解决样本不平衡的方法，也就是在loss计算时乘以权重。注意下面的图：$\\alpha$下面有个坐标t，也就是说$\\alpha$针对不同类别，值并不一样\n实际上就是在CE前加了一个$(1-p_t)^\\gamma$，也就是说，如果你的准确率越高，$\\gamma$ 次方的值越小，整个loss的值也就越小。也就是说，$\\gamma $ 次方就是用来衰减的，准确率越高的样本衰减越多，越低的衰减的越少，这样整个loss就是由准确率较低的样本主导了。对于onestage的网络，loss由负样本主导，但这些负样本大多是准确率很高的，经过focal loss后就变成了正负样本共同主导，或者说是概率低的主导。这一点和ohem很像，ohem是让loss大的进行训练。\nOHEM：\n\n\n从图中可以看出，本文的亮点在于在每次迭代中，较少训练样本下，如何hard negative mining，来提升效果。即针对Fast-RCNN框架，在每次minibatch（1张或者2张）训练时加入在线筛选hard region的策略，达到新的SoA。需要注意的是，这个OHEM适合于batch size（images）较少，但每张image的examples很多的情况。（thousands of candidate examples，这里的example可以理解为instance、region或者proposal）  这是一次ML经典算法bootstrapping在DL中的完美“嵌入”。\n具体来说：\n1 将Fast RCNN分成两个components：ConvNet和RoINet. ConvNet为共享的底层卷积层，RoINet为RoI Pooling后的层，包括全连接层；\n2 对于每张输入图像，经前向传播，用ConvNet获得feature maps（这里为RoI Pooling层的输入）；\n3 将事先计算好的proposals，经RoI Pooling层投影到feature maps上，获取固定的特征输出作为全连接层的输入；需要注意的是，论文说，为了减少显存以及后向传播的时间，这里的RoINet是有两个的，它们共享权重，RoINet1是只读（只进行forward），RoINet2进行forward和backward：\n\ta 将原图的所有props扔到RoINet1，计算它们的loss（这里有两个loss：cls和det）；\n\tb 根据loss从高到低排序，以及利用NMS，来选出前K个props（K由论文里的N和B参数决定）\n\t\t为什么要用NMS? 显然对于那些高度overlap的props经RoI的投影后，\n\t\t其在feature maps上的位置和大小是差不多一样的，容易导致loss double counting问题\n\tc 将选出的K个props（可以理解成hard examples）扔到RoINet2，\n\t这时的RoINet2和Fast RCNN的RoINet一样，计算K个props的loss，并回传梯度/残差给ConvNet，来更新整个网络\n\t论文提及到可以用一种简单的方式来完成hard mining：\n\t在原有的Fast-RCNN里的loss layer里面对所有的props计算其loss，根据loss对其进行排序，（这里可以选用NMS），选出K个hard examples（即props），反向传播时，只对这K个props的梯度/残差回传，而其他的props的梯度/残差设为0即可。由于这样做，容易导致显存显著增加，迭代时间增加，这对显卡容量少的童鞋来说，简直是噩梦。\n\t为什么说是online？\n\t论文的任务是region-based object detection，其examples是对props来说的，即使每次迭代的图像数为1，它的props还是会很多，即使hard mining后\n\t为什么要hard mining：\n\t1 减少fg和bg的ratio，而且不需要人为设计这个ratio；\n\t2 加速收敛，减少显存需要这些硬件的条件依赖；\n\t3 hard mining已经证实了是一种booststrapping的方式， 尤其当数据集较大而且较难的时候；\n\t4 eliminates several heuristics and hyperparameters in common use by automatically selecting hard examples, thus simplifying training。\n\t放宽了定义negative example的bg_lo threshold，即从[0.1, 0.5)变化到[0, 0.5)。\n\t取消了正负样本在mini-batch里的ratio（原Fast-RCNN的ratio为1:3）?\n\n\n和难例挖掘OHEM有什么区别\n\n3:1是负样本比上正样本\n\n\n\n\n\n讲一下你熟悉的优化器，说一下区别或发展史\n\n答：只简单讲了adam和SGD，没复习到\n具体参考https://www.cnblogs.com/ljygoodgoodstudydaydayup/p/7294671.html\n\n算法题：一个整数数组A，求Ai-Aj的最大值Max，i&lt;j，\n\nc++的解法及思路： https://blog.csdn.net/fkyyly/article/details/83930343\ndef f(arr):    if len(arr)==0 or len(arr)==1:        return 0    if len(arr)==2:        return arr[0]-arr[1]    p1 = 0    p2 = 1    max = arr[p1]-arr[p2]    n = len(arr)    while p2&lt;n:        while p2&lt;n and arr[p2]&lt;arr[p1]:            if arr[p1]-arr[p2]&gt;max:                max = arr[p1]-arr[p2]            p2 += 1        p1 = p2        p2 += 1    return max\n\n时间复杂度空间复杂度是多少\n\n答：O(n)，O(1)\n\n一个图片中心逆时针旋转30度后，求最小外接矩形长和宽，说一下有哪些解决方法\n\n答：第一种初中数学，几何知识；第二种，求解仿射变换矩阵（2x3），然后和原图相乘，就得到变换后的图片，也就知道了最小外接矩形的长和宽\n具体参考https://blog.csdn.net/flyyufenfei/article/details/80208361\n\n有什么想问的\n\n问：这个提前批的面试流程，有几面\n答：至少三面，没面过的不影响正式秋招\n问：老师您在公司做的什么方面呢\n答：广告方面的图像，cv-ad\n三面 主管面 视频面 （30min）2019/7/23\n\n\n自我介绍\n\n\n介绍一下简历上比赛经历\n\n\n介绍一下简历上最有含金量的工作\n\n\n1x1卷积的作用\n\n用来降维或者升维 （GoogLeNet、mobileNet）\n增加非线性\n\n\n\n经典分类网络backbone\n\n\n讲一下inception系列\n\n\n经典分割网络\n\n\n没有提问环节（感觉凉了呀）\n\n\n\n编程题：\n1.非递减数组中查询某个目标值出现个数。解法：二分查找左右边界。\ndef find(nums, target):    if not nums:        return 0    left = 0    right = len(nums)-1    while left &lt; right:        mid = (left+right)//2        if nums[mid] &gt;= target:            right = mid\t\telse            left = mid+1\tif right == 0 and nums[0] != target:        return 0    a = left        left, right = 0, len(nums)-1    while left &lt; right:        mid = (left+right+1)//2        if nums[mid] &lt;= target:            left = mid        else:            right = mid-1    return left-a+1\n2.leetcode 124 二叉树最大路径和\ndef maxpath(root):    def h(root):        if not root:            return 0        left = h(root.left)        right = h(root.right)        self.ans = max(self.ans, root.val+left+right)        return max(0, root.val + max(left, right))\tself.ans = -float(&#x27;inf&#x27;)    h(root)    return self.ans\n概率题：一个圆上三个点，组成锐角三角形概率。现场没算出来。\n\n1/4\n\n\n\n逻辑回归是什么？sigmoid的作用是什么？解释最大似然。先验概率与后验概率。\n对于回归问题，可以使用一个线性回归模型来做$y = wx+b$，对于分类问题，就可以用一个函数将事数值的 $y$ 转换成成离散值1/0。sigmoid函数就可以实现将其转换为一个概率数值。\n$$\nsigmoid(z) = \\frac{1}{1+e^{-z}}\n$$\n$$\np(Y=1|x) = \\frac{1}{1+e^{-wx+b}} \\\np(Y=0|x) = 1 - p(Y=1|x)\n$$\n最大似然估计\n模型的参数是未知的，但是是客观存在的一个定值。MLE是通过采样来估计概率分布参数的方法。\n假设有训练集合D，$D_c$ 是这个训练集合中的c个样本组成的集合。那么参数$\\theta_c$对于数据集合$D_c$ 的似然是\n$P(D_c|\\theta_c) = \\Pi_{x\\in D_c} P(x|\\theta_c)$\n简单的来讲，极大似然估计就是在所有的$\\theta$中找到使得所有可能出现的值出现的可能性最大。\n先验\n$p(c|x)$\n$p©$ 先验\n$p(x|c)$ 后验概率\n\n\n决策树分裂节点的标准与对应的算法。gbdt的gb是什么意思，如何体现。bagging与boosting的区别。gbdt里如何知道每个特征的重要性。\n\nID3 --&gt; 信息增益\nC4.5 --&gt; 信息增益比\nGB  梯度提升\nGBDT（Gradient Boosting Decison Tree）中的树都是回归树，GBDT用来做回归预测，调整后也可以用于分类（设定阈值，大于阈值为正例，反之为负例），可以发现多种有区分性的特征以及特征组合。GBDT是把所有树的结论累加起来做最终结论的，GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差(负梯度)，这个残差就是一个加预测值后能得真实值的累加量。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学。 Boosting的最大好处在于，每一步的残差计算其实变相地增大了分错instance的权重，而已经分对的instance则都趋向于0。这样后面的树就能越来越专注那些前面被分错的instance。\n缺点:Boost是一个串行过程，不好并行化，而且计算复杂度高，同时不太适合高维稀疏特征\n\n\n\n取样方式（样本权重）\nBagging是均匀选取，样本的权重相等\nBoosting根据错误率取样，错误率越大则权重越大\nBagging随机选择训练集，训练集之间相互独立\nBoosting的各轮训练集的选择与前面各轮的学习结果有关\nBagging各个预测函数没有权重，可以并行生成，\nBoosting有权重，顺序生成\nBagging是减少variance\nBoosting是减少bias\nBagging 是 Bootstrap Aggregating的简称，意思就是再取样 (Bootstrap) 然后在每个样本上训练出来的模型取平均，所以是降低模型的 variance.\nBoosting 则是迭代算法，每一次迭代都根据上一次迭代的预测结果对样本进行加权，所以随着迭代不不断进行，误差会越来越小，所以模型的 bias 会不不断降低。这种算法无法并行。\n\n\n\n\n\n为什么svm的loss不能直接用梯度下降要用对偶？说说你知道的优化算法。\n\n核技巧应用到支持向量机，其基本想法就是通过一个非线性变换将输入空间\n(欧氏空间 R n 或离散集合)对应于一个特征空间(希尔伯特空间  )，使得在输 入空间 R n 中的超曲面模型对应于特征空间  中的超平面模型(支持向量机).这 样，分类问题的学习任务通过在特征空间中求解线性支持向量机就可以完成\n核函数K(x,z)给定的条件下，可以利用解线性分类问题的方法 求解非线性分类问题的支持向量机.学习是隐式地在特征空间进行的，不需要显 式地定义特征空间和映射函数.这样的技巧称为核技巧，它是巧妙地利用线性分 类学习方法与核函数解决非线性问题的技术.在实际应用中，往往依赖领域知识 直接选择核函数，核函数选择的有效性需要通过实验验证\n\n\n\n优化方法\n\n1、梯度下降法\n梯度下降法是最早最简单的，也是最为常用的最优化算法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度未必是最快的。梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为“最速下降法”。最速下降法越接近目标值，步长越小，前进越慢。\n在机器学习中，基于基本的梯度下降法发展了两种梯度下降方法，分别为随即梯度下降法和批量梯度下降法。\n批量梯度下降：最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。\n随机梯度下降法：最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向，但是大的整体的方向是向着全局最优解，最终的结果往往是在全局最优解附近，使用于大规模训练样本情况。\n2、牛顿和拟牛顿法\n从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法更快。如果更通俗得到说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前的位置选一个坡度最大的方向走一步，牛牛顿法在选择方向时，不仅会考虑坡度是否足够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说是牛顿法比梯度下降法看的更远一点，能更快地走到最底部。\n优点：二阶收敛，收敛速度更快；\n缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的hessian矩阵的逆矩阵，计算比较复杂。\n拟牛顿法\n拟牛顿法的基本思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺点，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。拟牛顿法和最速下降法一样只要每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优与最速下降法，尤其对于困难的问题，另外，因为拟牛顿法不需要二阶倒数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。\n3、共轭梯度法\n共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解决大型非线性最优化最有效的算法之一。在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有步收敛性，稳定性高，而且不需要任何外来参数。\n4、启发式优化方法\n启发式方法是指人在解决优化问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时，利用过去的经验，选择已经行之有效的方法，而不是系统地、以确定的步骤去寻求答案。启发式优化方法种类繁多，包括经典的模拟退火方法，遗传算法、蚁群算法以及粒子群算法等等。\n还有一种特殊的优化算法被称之多目标优化算法，它主要针对同时优化多个目标（两个及两个以上）的优化问题，这方面比较经典的算法有NSGAII算法、MOEA/D算法以及人工免疫算法等。\n5、EM算法\nEM算法是一类算法的总称。EM算法分为E-step和M-step两步。EM算法的应用范围很广，基本机器学习需要迭代优化参数的模型在优化时都可以使用EM算法。\nEM算法的思想和过程\nE-step：E的全称是Exception，即期望的意思。E-step也是获取期望的过程。根据现有的模型，计算各个观测数据输入到模型中的结果。这个过程称为期望值计算过程，即E过程。\nM-step：M的全称是Maximization，即最大化的意思。M-step也是期望最大化的过程。得到一轮期望值以后，重新计算模型参数，以最大化期望值。这个过程为最大化过程，即M过程。\n最大化的意思是我们在使用这个模型时希望我们定义的函数能使得到的结果最大化，而结果越大越接近我们希望得到的结果。我们优化的目标也就是这些能得到最大值的函数。\n常见的EM算法有：隐含马尔科夫模型的训练方法Baum-Welch算法；最大熵模型的训练方法GIS算法等。\nEM算法结果\nEM算法不一定能保证获得全局最优解，但如果我们优化的目标函数是一个凸函数，那么一定能保证得到全局最优解。否则可能获得局部最优解。因为如果优化的目标函数有多个峰值点，则如果优化到某个不是最高的峰值点处，则会无法再继续下去，这样获得的是局部最优解。\n总结\nEM算法只需要输入一些训练数据，同时定义一个最大化函数，接下来经过若干次迭代，就可以蓄念出我们需要的模型了\n\n\n\nPCA和LDA的区别\n\nhttps://www.jianshu.com/p/982c8f6760de\nPCA**\n总结一下，我们就可以梳理出整一个PCA降维的流程，归纳如下，\n（1）样本去中心化\n（2）计算样本的协方差矩阵$XX^{T}$\n（3）对协方差矩阵做特征值分解\n（4）取最大的$d’$ 个特征值所对应的特征向量\n（5）计算投影矩阵\nLDA\n从降维的层面考虑，其也是在寻找一个投影矩阵，使得投影之后数据样本，同类的接近，而不同类的远离。\nLDA的中心思想就是最大化类间距离以及最小化类内距离\n\n总结一下，我们就可以梳理出整一个LDA用于降维的流程，归纳如下，\n（1）计算每个类别的均值$\\mu_i$，全局样本均值$\\mu$\n（2）计算类内散度矩阵$S_w$，全局散度矩阵$S_t$，类间散度矩阵$S_b$\n（3）对矩阵$S_w^{-1}S_b$做特征值分解\n（4）取最大的$d^{’}$个特征值所对应的特征向量\n（5）计算投影矩阵\n比较\n\nPCA为非监督降维，LDA为有监督降维\nPCA希望投影后的数据方差尽可能的大（最大可分性），因为其假设方差越多，则所包含的信息越多；而LDA则希望投影后相同类别的组内方差小，而组间方差大。LDA能合理运用标签信息，使得投影后的维度具有判别性，不同类别的数据尽可能的分开。\n举个简单的例子，在语音识别领域，如果单纯用PCA降维，则可能功能仅仅是过滤掉了噪声，还是无法很好的区别人声，但如果有标签识别，用LDA进行降维，则降维后的数据会使得每个人的声音都具有可分性，同样的原理也适用于脸部特征识别。所以，可以归纳总结为有标签就尽可能的利用标签的数据（LDA），而对于纯粹的非监督任务，则还是得用PCA进行数据降维。\n\n\n\n\n二面：\n编程题：正则表达式匹配。剑指offer和leetcode都有。\n.可以匹配任意个前面的字符\n+可以匹配任意一个字符\ndef isMatch(s, p):    dp = [[False] * (len(s)+1) for _ in range(len(p)+1)]    dp[0][0] = True        for i in range(1, len(p)+1):    \tif p[i-1] == &#x27;*&#x27; and dp[i-2][0]:            dp[i] = True        for i in range(len(p)+1):        for j in range(len(s)+1):            if p[i-1] == s[j-1] or p[i-1] == &#x27;.&#x27;:                dp[i][j] = dp[i-1][j-1]            elif p[i-1] == &#x27;*&#x27;:                if p[i-2] == &#x27;.&#x27; or p[i-2] == s[j-1]:                    dp[i][j] = dp[i-2][j] or dp[i-1][j-1] or dp[i][j-1]                else:                    dp[i][j] = dp[i-2][j]    return dp[-1][-1]\n概率题：真硬币m个，假币n个。假币只有正面。真币投掷正面概率为p。其中某硬币投掷k次都是正面，求它为真币概率。\n知识点：\n1.pooling是什么，有哪些作用。\n2.梯度爆炸与消失产生原理与解决方法。\n3.解决过拟合的方法有哪些。\n4.输入特征归一化有哪些方式，有什么好处。svm需不需要？决策树需不需要？\n\n1,避免训练得到的模型权重过小,引起数值计算不稳定;\n2,使参数优化时能以较快的速度收敛.\n归一化时可以采用对应维度均值与方差.\n\n5.1x1卷积的作用。\n\n1x1 卷积在图像处理的角度，乍一看好像没什么意义，但在 CNN 网络中，能实现降维，减少 weights 参数数量，能够实现升维，来拓宽 feature maps，在不改变 feature maps 的 size 的前提下，实现各通道之间的线性组合，实际上是通道像素之间的线性组合，后接非线性的激活函数，增加更多样的非线性特征。这就是为什么 GoogLeNet 用 1x1 卷积来降维，减少了计算量，但模型效果却没有降低，此外网络深度更深。可以说 1x1 卷积很 nice.\n\n6.什么是特征向量与特征值。怎么理解它们代表的意义。\n\n\n特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么，可以将每一个特征向量理解为一个线性的子空间\n\n7.知道什么是k-means？k-means是否一定收敛。\n\nk-means一定收敛\n\n8.tcp三次握手。\n进程线程区别\n\n根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位\n在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。\n所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）\n内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。\n包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。\n进程是资源分配最小单位，线程是程序执行的最小单位；\n进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，线程没有独立的地址空间，它使用相同的地址空间共享数据；\nCPU切换一个线程比切换进程花费小；\n创建一个线程比进程开销小；\n线程占用的资源要⽐进程少很多。\n线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行；（但多线程程序处理好同步与互斥是个难点）\n多进程程序更安全，生命力更强，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）；\n进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换；\n\n\n先简短的自我介绍\n​     1.数据不平衡问题的解决方法\n​     2.如何修改根据样本的不均衡确定Loss的权重\n​     3.介绍过采样和下采样的方法以及会遇到哪些潜在的问题\n​     4.画出ROC曲线和PR曲线，并介绍二者的区别和应用场景\n​     5.天平平衡问题(先放置一个质量为m的砝码，在从[1,2,4,8,16…,2^(n-1)]的砝码里挑选，使天平平衡)\n\n2 --&gt; 10\n3 --&gt; 11\n\n​     6.IoU代码\n二面:\n​     面试官依旧很nice，人很好\n​     自我介绍\n​     1.介绍自己做过的项目，数据有没有进行预处理，用到哪些模型，什么框架，做了什么改进和提升（讲了2个）\n​     2.Momentum、Adagrad、Adam、SGD、RMSPROP的原理和公式，以及各自的好处\n​     3.卷积层、池化层相关原理和反向传播的过程\n​     4.BatchNorm层的相关原理及好处\n​     5.编程实现梯度下降逼近根号x，设计损失函数，模拟梯度下降的过程。\n$y = \\sqrt{x}$\n​     6.TF、pytorch框架相关\n​     7.Mysql相关 答得不好。。 也没细问\n三面：\n​     自我介绍\n​     1.重点介绍一个项目，是问的最细的（比如涉及到opencv 透视转换的原理，指出透视转换矩阵的作用），细到怀疑人生\n​     2.写出Yolov3的损失函数\n​     3.二元交叉熵如何解决多分类问题\n​     4.写出Softmax、Sigmoid公式和交叉熵损失函数公式\n​     5.ResNet为何设计残差结构以及如何解决梯度消失问题，需写公式证明\n\n\n\n​     6.编程：编辑距离  leetcode原题\n​     7.有没有想问面试官的问题\n\n面试内容:\n1.kaggle比赛:\n标签相关性分析，数据增强，特征融合不同方式及其优缺点，attention（channel和pixel\n两种方式的具体实现），2D CNN全套，损失函数该如何设计，fine grained有哪些解决方法\n2.常规目标检测\n发展过来的前世今生，yolo全套,ssd,faster rcnn具体细节，代码实现，工程中需要考虑的实际问题\n3.非常规目标检测\nRRPN，R2CNN（感觉面试官不是很了解这个方向，所以一直是我在说），还有我自己的框架\n4.anchor free框架\n基本思想，不同网络的具体对比，hourglass结构的好处，损失函数，我自己的框架具体结构，和sota比性能如何（map更高速度更快），新的损失函数为什么这么设计\n5.3D卷积\n和2D卷积的区别，主要存在问题，如何加速运算，视频理解的sota方法，还有什么方向可以改进\n6.某大型项目\n实施细节（面试官对这个很感兴趣），公然po到网上担心引起问题，故不详细展开\n7.算法题\n每一次面试都是我讲完论文项目实习，就快一个小时了，所以算法题也没怎么做比较难的，很快写完了。\n总结:\n1.注重对sota方法的了解程度，需要大量看最新顶级的论文\n2.注重对具体问题的分析与解决，有的方法实际上项目的时候并不适用（考虑清楚为什么）\n3.注重原理的理解而不是方法看起来有多fancy，原理至上，所以一定要理解透彻。\n\n一面\n项目\n一个数字序列重排找比它大的下一个\n两个智力题：抛硬币上下面概率不等，怎么制定规则使他公平\n1000瓶药水 一瓶有毒 小白鼠喝了有毒的会有反应 十个小白鼠 怎么找到有毒的那瓶\n\n题目：1000 瓶无色无味的药水，其中有一瓶毒药，10只小白鼠拿过来做实验。喝了无毒的药水第二天没事儿，喝了有毒的药水后第二天会死亡。如何在一天之内(第二天)找出这瓶有毒的药水？\n第一次看这个问题完全没思路，应该有很巧妙的解法吧，后来还是百度一下，才明白怎么回事。\n思路就是用二进制，2^10=1024，也就是10只小白鼠最多能验出1024瓶药水，哪个有毒。小白鼠编号，1-10。瓶子也编号，1-1000，然后把瓶子的编号转变为二进制数。如果第几位是1，就把这瓶水给第几个小白鼠喝。最后大概每个小白鼠喝500瓶药水的混合液。如果还不懂，下面列几个数字解释一下。\n瓶子编号 二进制数 第几个小白鼠喝\n1 0000000001 1\n2 0000000010 2\n3 0000000011 1，2\n4 0000000100 3\n5 0000000101 1，3\n大概就是这意思，再反过来，假如1号和3号小白鼠死了，死的小白鼠用1表示，再写成2进制数：0000000101，转化为十进制数是5，从上面列出来的也可以看出1，3都喝了5号瓶的水，所以就是第五瓶水有毒。\n解决方案\n1）我们将1000瓶液体编号1~1000，然后将编号转化为10位二进制，如1号就是0000000001；\n2）将十只小白鼠编号1~10；\n3）将液体的二进制编号上为1的位数给对应的小白鼠喝，如液体编号为 1111100000，那就是1~5号小白鼠不喝这瓶液体，6~10号小白鼠喝这瓶液体；\n4）一星期后观察小白鼠的死亡情况，如果1~5号小白鼠死亡，6~10号小白鼠存活，那么有毒的那瓶液体对应的二进制编码为 0000011111；\n5）将第四步得到的二进制编码转化为十进制，这里是31号，因此我们可以推断出编号为31的液体是被污染的。\n\n问我有什么想问他的\n我说你为什么不问我知识点\n他说看以前记录问过了……就考察别的\n原来头条会存档面试记录…\n二面\n项目 根据项目问了一些epoll 消息类型有哪几种\n事件触发回掉函数是在tcp协议哪一步里（没懂\n代码：五子棋 没棋子0 白棋1 黑旗-1 判断黑旗赢了没\n三面\n代码题\n无序数组找中位数（用了部分快排 但是没调对\n\n一面：\n\\1. 讲实习做的检测的项目，讲ocr比赛的项目, 针对项目提了些问题\n\\3. BN层作用， dropout作用\n\\3. nms伪代码\n\\4. iou代码\n\\5. 最大不重复字串\n\\6. 单链表排序\n二面：\n\\1. 讲实习做的检测的项目，Faster RCNN, RetinaNet, Yolo-v3在检测超小物体遇到的问题\n\\2. Yolov1-Yolov3改进区别，问的很细\n\\2. 元学习图像分类的过程，问为什么用validation的梯度更新模型就可以见效泛化误差，\n这个没有细想过，答的不太好\n\\3. SGD的动量的作用，问为什么可以减小震荡，为什么震荡小就更容易收敛，\n这个也答的不太好\n\\4. Adam说一下，估计梯度的一阶和二阶，然后用二阶估计来缩放每个位置的学习率，\n问为什么可以对学习率缩放，从数值的角度答了一下\n\\5.  编程题: 从左到右增，从上到下增的矩阵查找，忘了考虑多个值的情况\n三面：\n\\1. 讲元学习基于优化的方法是怎么做的，大概说了下自己做的工作\n\\2. 实习做的检测的项目，Retinanet和yolov3 anchor box的区别，yolo3里train有没有iout_thresh\n\\3. 01矩阵中1的最大连通面积\n\\4. 有多个高维向量，再新给一个如何快速查找相似的， 答了类原型，先哈希再比较\n\\5. 如何等概率产生半径为1的圆内坐标(x,y)， 就是拒绝采样\n今天问hr, 说方向不太match，基本是挂了。\n出的编程题都不难，基本10分钟内就写完了。感觉可能还是理解不够深入，原理性的东西答的不太好。\n渣硕一个，之前看了些别人的面经，今天也写一个回馈一下社区。。。\n感觉太难了，半个月前面了旷视研究员两面也没消息了，我决定秋招完2年内就转行，不干程序员了，立帖为证。\n\n作者：天才儿童\nhttps://www.nowcoder.com/discuss/215883?type=post&amp;order=time&amp;pos=&amp;page=2&amp;subType=2来源：牛客网\n1、算法题：n个人之间存在m个关系对，关系具有传递性，假如A关注B，B关注C，那么A就间接关注了C。如果一个人被除他之外的所有人都直接或间接关注，那么这个人就是抖音红人，求抖音红人的总数。\n2、介绍一个你的项目。\n3、特征选择有哪些方法（介绍项目时涉及到了特征相关性分析，因此问了这个）。\n4、FM是否也能起到自动特征选择的作用，为什么。\n5、GBDT的原理，和随机森林等算法做比较。\n二面：\n1、svm损失函数推导。\n2、朴素贝叶斯写公式。\n3、算法题：两个单链表找到第一个公共结点。\n4、算法题：由0和1组成的二维矩阵，找出1的最大连通域，计算其面积。\n三面：\n1、算法题：长度为n的字符串中包含m个不同的字符，找出包含这m个不同字符的最小子串。\n2、如果实现c++中的vector，只需push_back和查找两个功能，底层如何实现。\n3、如果用数组实现，数组初始容量为n，每次push到容量上限之后都扩容到原来的两倍，现在push进去m个数，m远大于n，求相比于m的时间复杂度。\n4、A和B比赛，A、B获胜的概率分别是0.6、0.4，如果你是A，3局2胜和5局3胜你会选择哪个。\n5、如果A和B比赛无数局，A获胜的概率是多少。\n6、有两张表，第一张表有n个专有名词，比如今日头条、抖音等，第二张表有m条query，比如今日头条是怎样的应用、有多少人喜欢刷抖音等，如何统计表1中所有名词在表2中出现的频次。\n7、一个用户在搜索框输入query之后，如何知道他是否是在找视频。\n8、如何计算一个微博账户的权威分数。\n9、介绍一下xgboost有哪些特点。\n10、xgboost和GBDT的分裂方式你认为哪个好。\n四面：\n1、c++中指针和引用的区别。\n2、如何从用户态进入内核态。\n3、非线性分类算法有哪些。\n4、如何判断一个算法是线性的还是非线性的。\n5、算法题：下一个全排列。\n6、算法题：长度为n的数组中有一个数字出现了n/2次，快速找到这个数。\n7、介绍一个你参加的比赛。\n每一面之后都是在第二天就接到的下一面的预约电话。\n前两面的算法题需要写出代码，但是不用过测试用例，三四面只用说思路。\n28号下午第四面，今天晚上快7点的时候接到了offer call，通完电话后加了hr小姐姐微信之后给我发了意向书。（一开始是qq邮箱，结果qq邮箱居然把我的意向书拒收了，然后发了网易邮箱。。。）\n当时在牛客上面找的前辈内推，记得推的是广告系统，今天告诉我给我分配到了搜索团队，四面的面试官就是我的leader。（在这里非常感谢牛客内推的前辈🙏）\n明天回家，今天收到意向书，真的难掩心中的激动和喜悦😭虽然是计算机科班，但并不是机器学习科班，基础可以说是非常薄弱，字节offer对于我来说真的太难得。\n明天网易笔试的时候我正好在回家的飞机上，本来感觉挺遗憾，现在感觉无所谓了😂\n\n作者：南风哥哥\nhttps://www.nowcoder.com/discuss/207092?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2来源：牛客网\n一面：\n怎么推测抖音用户是男性还是女性？怎么确认判断结果的靠谱程度？\n分类问题的指标？准确度、召回率、PR曲线\n相关系数怎么计算？讲一讲协方差和它的意义？\n详细介绍一下实习经历？有没有场景落地？\n特征选择的方法？Lasso回归、相关系数等\n为什么要用正则化？解释了奥卡姆剃刀\nL1正则化与L2正则化的区别？解释了参数先验和拉格朗日乘子法\n手撕代码：\n求股票的最大利润，例如[1, 3, 1, 8, 10, 3]，只能买卖一次，计算最大收益\n能买卖无数次，计算最大收益\n只能买卖两次，计算最大收益\n二面：\n一定要走算法岗吗？还是大数据也OK？\n简单说一下最有成就感的项目案例？介绍了比赛经历\n简单说一下对假设检验的理解？没答上来。。。\n抽样一般有哪些方法？答偏了，讲了欠采样、过采样\n解释MCMC采样？讲了马尔可夫链、蒙特卡洛方法，改进版的M-H采样、吉布斯采样\n与计算机相关的课程有哪些？数据结构、计算机网络、操作系统。。。嗯。。。都没学过\n说几个常用排序算法的时间复杂度、空间复杂度、稳定性？\nLinux系统的常用命令？\nSQL如何取出成绩表中各科的前三名？\n\nselect * from (  select subject,name,score,ROW_NUMBER() over(PARTITION by subject order by score desc)  \tas num from #score ) T where T.num &lt;= 3 order by subject \n\n对什么语言比较熟？C++、Python\n手撕代码：\n排序数组中绝对值不同的个数\n字符串转整数\n三面：\n前面两面聊的怎么样？\n为什么想做算法？\n讲一下实习经历？大概用了什么方法？\n抛一个不均匀硬币五次，两次正三次反，下一次正的概率p1是多少？\n抛一个不均匀硬币五十次，二十次正三十次反，下一次正的概率p2是多少？\n为什么概率是0.4?解释极大似然估计，求导计算出p1=p2=0.4\n如果真实的概率是p，为什么你会觉得p2更接近p？\n机器学习训练中，数据分为几份？\n验证集和测试集的区别？\n\n训练集用于训练模型参数，测试集用于估计模型对样本的泛化误差，验证集用于“训练”模型的超参数。\n\n手撕代码：\n1，2，…，N中，字符1出现的次数\n判断a+b&gt;c?要考虑溢出\n感受：一面问的是基础题，基本都答上来了。二面开始被虐，计算机基础太薄弱，统计学知识也很欠缺，面试官的评价是“虽然都有了解，但不系统”。三面感觉面试官是个大佬，简单的问题会一直深挖，着重对知识的理解程度。\n总结：欠缺的地方还有很多，一点一点补吧\n\n作者：Neymarkim\nhttps://www.nowcoder.com/discuss/192689?type=post&amp;order=time&amp;pos=&amp;page=2&amp;subType=2来源：牛客网\n2.lightgbm GBDT xgb，问的超级细，可能持续了7 8分钟，XGB残差怎么用一次和二次梯度求，分裂点怎么求，思想原理是什么。XGB实际使用中重要的超参数，你们比赛中用的目标函数是什么，为什么lightgbm速度更快，其并行计算如何实现（这点没回答上）\n3.bagging  boosting 的区别，谁是更关注方差 ，谁是更关注偏差\n4.如何防止过拟合,项目中用过哪些手段\n5.W2V 的原理 ，两种生成方式，W2V的思想到底是什么，为什么要这样做，W2V的缺点，W2V中所用的softmax 比起普通softmax有何区别，为什么能减少计算量（我并不是搞自然语言的，这一波问的我有点捉襟见肘，只是勉强回答了，面试官很好，我没回答清楚地就给我讲，引导我）\n6.embeding的方法 FM FFM deep FM\n7.attention (毕竟是 attention is all you need 基本都会问)\n8.给他讲做的CTR比赛，主要问怎么做特征，onehot 特征多了会有什么问题，为什么有时会导致效果下降（我回答的是onehot 特征占用维度太高，可能会湮没其他一些重要的特征）\n可能还有一些问题记不起来了，反正真的就是抓住一个点，不停地深入\n9.模型的容量问题\n10.编程，比较简单的二分法\n一面 1H35min 可真是太恐怖了，但整体体验很好，面试官会给你讨论，给你讲\n来源：牛客网\n1.开门见山，一道概率题，真的懵了，先问我bagging  boosting 的区别，我愉快的回答了，然后题就来了，bagging 中随机有放回采样，假如一共有N个样本 采样了N次，得到N个采样数据，去重后有X个数据  求E（X），我只列出了暴力计算的方法，是有简单的我没想出来,各位大神知道的可以讲讲\n\n\nresnet VGG介绍 主要特色\n\n\n1*1的卷积核 有什么用\n\n\nmax pooling 梯度传导\n\n\n5.如何防止梯度消失，为什么会有梯度消失\n\n\n6.又是做题，数据结构的，找出一颗完全二叉树最后一个节点，时间复杂度要求 logN的平方\n\n\n\ndef f(root):    left = getdepth(root.left)    right = getdepth(root.right)    while left &lt; right:\t\tcur = cur.left        left = getdepth(root.left)        right = getdepth(root.right)    if left == right:        cur = right:        while cur.right:            cur = cur.right        return cur\treturn cur        \n\nHR面  5.21\n二面10分钟后就是HR面，问问基本情况，但问的还是很多，从实习的时间，工作的兴趣和期望，自我感觉的优缺点，曾经面临的困难，抗压能力等等吧\nHR小姐姐一来就说她们不会刷人，只要我确定能去就能发OFFER，当时比较激动，连小姐姐声音好不好听都记不得了，我想肯定是很好听的。\n\n作者：Ococococ\nhttps://www.nowcoder.com/discuss/212382?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2来源：牛客网\n2.这个项目要是你应该怎么做？\nOneclass模型？你知道哪些？普通svm能做oneclass吗？为什么？应该怎么才能做？\n用过抖音么？怎么分析新老用户活跃度差异？\n你会c++？讲几个关键字？\nC++的异常？\n水库抽样，我虽然听说过但还是不会，卒。\n1-5的随机数发生器怎么生成1-7的？当时脑子抽了，明明想了一个正确的答案不敢说。\n肯定是凉了，给我机会我不中用啊。\n希望下午的拼多多能有个面试机会吧。\n\n作者：不瘦20.5斤不改名\nhttps://www.nowcoder.com/discuss/215858?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2来源：牛客网\n1进程和线程\n2编译原理，什么鬼，不懂\n3队列和栈\n4pytorch和tensorflow的区别\n5项目里的问题，比价常规\n6缓解过拟合的方法\n7代码题，手撕实现图像的resize和rotate90度\n二面：\n1.项目\n2.代码：找出数组里的任意峰值，需要优化到O(logn)，\n最长不重复字符串\n三面：\n1实习经历\n2小目标检测有哪些trick\n3smoothl1的好处\n4代码题\n有一个1000w的视频库，每个视频3-5分钟。 新来一个视频，我们需要去这1000w的视频库里查询，是否存在相同视频。 1 选择使用什么样的特征 。 2 设计一个好的index，使得查询尽可能快 （这1000w视频可以离线处理）\n写一个函数，输入是N个文件，每个文件中是很多float的数值，文件内部无序。输出是一个有序的大文件，内存约束2个G，磁盘可以随便用，具体怎么实现比较高效\n一面面的比较烂，没想到自己能进二面，后面两面比较顺，等了一个周今天总算收到意向书，希望大家早日拿到心仪的offer\n\n作者：水煮鱼201906300703978\nhttps://www.nowcoder.com/discuss/209478?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2来源：牛客网\n整体面试一面二面二面，每轮都会写写代码，但是都维持在leetcode上easy和medium的难度，基本上刷个200来道，都不会有太大问题。我面试之前也去刷了牛客网上的题。\n细节上，设计到机器学校的一些知识，我的复习策略就是疯狂看面经，看技术博客。\n印象深的问题有：\n1.给你M个正样本，N个负样本，以及他们的预测值P，求AUC。（写完之后接问：AUC究竟在衡量模型什么能力？如果现在所有预测值都*1.2，AUC是否会变化？）\n这一题印象深刻是因为平时在计算auc的时候，很多同学都知道是roc曲线的面积，但是对auc具体的含义了解不多。\n2.Attention\n考虑到最近Attention的火爆和字节跳动的主要技术优势，attention这一个技术热点是一定要复习的（然而我没仔细看，非常后悔，面完之后从头到尾看了一遍）。\n3.BatchNorm\n这一个问题其实我有用过，我也知道原理，但是当面试问具体公示的时候，还是愣了一下，但是BN无疑是一个很火的应用，必须要会。\n其他的例如softmax与cross entropy的推导，过拟合与正则化，BiLSTM，Gradient Explosion，Top N，特征选择都是常规问题就不仔细说了。\n整体面试体验真的非常好，面试官很nice，一面二面的面试官，问得很仔细，我对问题理解错了给我纠正之后让我再思考，因为是视频面，反而不紧张。三面的姐姐问的最详细，但是很和善。大家面试的时候放松心态，做足准备就好，谋事在人，成事在天，不必太过紧张。如果面试中遇到思路卡壳可以一点一点解释，不用着急。\n最终hr面之后拿到了offer，字节跳动data部，然后跟技术人员又聊了聊技术。跟家里谈了谈之后，决定接受offer。\n有一个问题想问问大家，字节跳动data部是一个怎么样的部门呢？算是核心部门吗？\n希望大家都能获得自己理想的offer！秋招加油！\n\n作者：越陵殇\nhttps://www.nowcoder.com/discuss/211174?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2来源：牛客网\n还问了人像分割比赛中的设计思路和改进策略，训练方式之类的，面试官比较懂这一块，聊得挺融洽的。\n深度学习相关\nloss(x,y)=max(x,y)，求该函数分别对x和y的偏导怎么计算？（参照max pooliing的求梯度解释）；\nBN的实现？\nBN的作用？\nBN训练期间和测试期间的区别？\nBN中的batch怎么选择？https://zhuanlan.zhihu.com/p/61725100\n\n普通卷的参数量如何计算？\n\n如果换成depthwise conv呢？\n大小为3*3，padding=0，stride=1的卷积核在经过2次计算后感受野为多少？参考：https://zhuanlan.zhihu.com/p/31004121\n\n减小过拟合的方法有哪些？\nYOLO v3的loss函数（讲错了，当时一紧张就讲成了Faster RCNN的loss函数，脑子发热了，难受~）\nKL散度有了解吗？\nsmooth L1函数的作用为什么效果更好？\n一些发散性的题目\n不规则图形的面积如何计算？\n算法：\n给定一个二维数组，其中包含元素为0~9，要求矩阵中所有元素为0的行和列，并将所有0元素所在的行和列也全部更新为0。\n\n1、自我介绍，聊相关内容，主要是一篇小论文以及相关领域内的其他论文\n2、聊项目，yolo检测相关\n3、问检测中能提升速度但不损失性能的操作有哪些，用过的没用过都行\n4、编程题：稀疏向量的点乘。先要我自定义存储的结构体，然后写函数头，再编程，本来要我用template但我不会就算了\nclass Node():    def __init__(self, x, y, val):        self.x = x        self.y = y        self.val = valdef matrixDotMult(m1, m2, m, n):    ans = 0\ti, j = 0, 0    while i &lt; len(m1) and j &lt; len(m2):        if m1[i].x == m2.[j].x and m1[i].y == m2[j].y:            ans += m1[i].val * m2[j].val            i += 1            j += 1        elif m1[i].x &lt;= m2[j].x and m1[i].y &lt; m2[j].y:            i += 1        else:            j += 1    return ans         \n二面：\n1、自我介绍，还是聊论文，但问的点和一面的不一样。\n2、一道数学题，A、B两人投硬币，谁先投到正面谁就赢，求先投的人赢的概率  2/3\n3、LR、SVM的公式推导\n4、特征点的匹配机制有哪些\n5、深度学习中评价指标的解释，mAP、PR曲线、AUC\n\n\n\n\n6、编程题：链表反转，迭代+递归两种都要写\ndef reverse(head):    if not head or head.next:        return head    t = reverse(head.next)    head.next.next, head.next = head, None    return tdef reverse(head):    p = head    prev = None    while p:\t\tt = p.next        p.next = prev        prev = p        p = t  return prev\n三面：（居然还有三面！二面的时候感觉凉透了）\n全程问项目，不问很深的技术，只是让你讲项目细节、效果如何，感觉是来验证简历真假的，问完就结束了\n没有编程题\n7.25更新，收到了感谢信，已凉\n\n一面：\n二叉树镜像\nLRU Cache\nclass Node():    def __init__(self, key=None, val=None):        self.val = val        self.key = key        self.next = None        self.prev = Noneclass LRUCache(object):    def __init__(self, capacity):        &quot;&quot;&quot;        :type capacity: int        &quot;&quot;&quot;        self.head = Node()        self.tail = Node()        self.head.next = self.tail        self.tail.prev = self.head        self.dic = &#123;&#125;        self.cnt = capacity    def move2tail(self, node):                node.next.prev = node.prev        node.prev.next = node.next                node.next = self.tail        node.prev = self.tail.prev        node.next.prev = node        node.prev.next = node                    def get(self, key):        &quot;&quot;&quot;        :type key: int        :rtype: int        &quot;&quot;&quot;        if key not in self.dic:            return -1        val = self.dic[key].val        self.move2tail(self.dic[key])        return val            def put(self, key, value):        &quot;&quot;&quot;        :type key: int        :type value: int        :rtype: None        &quot;&quot;&quot;        if key in self.dic:            self.dic[key].val = value            self.move2tail(self.dic[key])        else:            if len(self.dic) == self.cnt:                self.dic.pop(self.head.next.val)                self.head.next = self.head.next.next                self.head.next.prev = self.head                            t = Node(key, value)            self.dic[key] = t                                    t.next = self.tail            t.prev = self.tail.prev            t.next.prev = t            t.prev.next = t        \n全排列稍微变形了一下\n二面：\nLFU Cache\nclass LFUCache:    def __init__(self, capacity: int):        self.capacity = capacity        self.cache = &#123;&#125;        self.freq_key = &#123;&#125;    def get(self, key: int, new=False) -&gt; int:              if key not in self.cache:            return -1                # 找出当前key的频率并加1        for freq in self.freq_key:            if key in self.freq_key[freq]:                self.freq_key[freq].remove(key)                if not self.freq_key[freq]:                    self.freq_key.pop(freq)                self.freq_key.setdefault(freq+1, []).append(key)                break                        return self.cache.get(key)    def put(self, key: int, value: int) -&gt; None:        if self.capacity &lt;= 0:            return        if key not in self.cache:            if len(self.cache) == self.capacity:                                # 弹出频率最小的第一个元素，并移除                pop_key = self.freq_key[min(self.freq_key)].pop(0)                self.cache.pop(pop_key)                            self.cache[key] = value            self.freq_key.setdefault(1, []).append(key)        else:            self.cache[key] = value            self.get(key)\n三面：\n一个圆形的时钟，一个点从12点出发，每秒可以顺时针走一步也可以逆时针走一步，问N秒后回到12点有多少种走法\ndef ways(n):    dp = [[0]*60 for _ in range(n+1)]    dp[0][0] = 1        for i in range(1, n+1):        for j in range(60):            dp[i][j] = dp[i-1][(j-1+n)%60] + dp[i-1][(j+1)%60]    return dp[n][0]\nN个人，有2N只手，彼此握手，问形成的环的期望数（一个人可以左手握右手形成一个环，两个人交叉握手和正对着握手，都可以形成一个环）。\n\n记绳子数为$N$时，环的个数为随机变量$X_N$，期望为$\\mu_N=E{X_N}$。显然，$X_N$可能的取值为$1, 2, \\dots, N$。直接的想法是计算$X_N$的概率分布$P{X_N=m}$然后再求期望，但显然过于复杂。考虑如下的思路：先随机选取两个绳头系在一起，有且只有两种结果：a. 这两个绳头属于一根绳子，于是形成了一个环，而剩下的$N-1$根绳子归结为规模为$N-1$的问题；b. 这两个绳头属于不同的绳子，于是这两根绳子形成了一根绳子，和剩下$N-2$共同构成了规模为$N-1$的问题。记a、b发生的概率分别为$P{a}, P{b}$，则有\n$$\n\\mu_{N}=\\left(\\mu_{N-1}+1\\right) P{a}+\\mu_{N-1} P{b}\n$$\n下面计算a、b发生的概率。选这两个绳头时，第一个可以任选。而从剩下$2N-1$个绳头中选择第二个时，只有一种选择会产生情况a，即选中和第一个绳头属于同一根绳子的绳头；剩下$2N-2$种选择将产生情况b。于是:\n$$\n\\begin{aligned} P{a} &amp;=\\frac{1}{2 N-1} \\ \\ P{b} &amp;=\\frac{2 N-2}{2 N-1} \\end{aligned}\n$$\n$$\n\\mu_{N}=\\frac{1}{2 N-1}\\left(\\mu_{N-1}+1\\right)+\\frac{2 N-2}{2 N-1} \\mu_{N-1}\n$$\n$$\n\\mu_{N}=\\mu_{N-1}+\\frac{1}{2 N-1}\n$$\n$$\n\\mu_{N}=\\sum_{n=1}^{N} \\frac{1}{2 n-1}\n$$\n\n\nTCP 四次挥手，滑动窗口\n\n滑动窗口协议（Sliding Window Protocol），属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。\nTCP通过滑动窗口的概念来进行流量控制。设想在发送端发送数据的速度很快而接收端接收速度却很慢的情况下，为了保证数据不丢失，显然需要进行流量控制， 协调好通信双方的工作节奏。所谓滑动窗口，可以理解成接收端所能提供的缓冲区大小。TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓 冲区。由于窗口由16位bit所定义，所以接收端TCP 能最大提供65535个字节的缓冲。由此，可以利用窗口大小和第一个数据的序列号计算出最大可接收的数据序列号。\n\nPython GIL\n\nGuido van Rossum（吉多·范罗苏姆）创建python时就只考虑到单核cpu，解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁， 于是有了GIL这把超级大锁。因为cpython解析只允许拥有GIL全局解析器锁才能运行程序，这样就保证了保证同一个时刻只允许一个线程可以使用cpu。由于大量的程序开发者接收了这套机制,现在代码量越来越多,已经不容易通过c代码去解决这个问题。\n————————————————\n即全局解释器所（global interpreter lock），每个线程在执行时候都需要先获取GIL，保证同一时刻只有一个线程可以执行代码，即同一时刻只有一个线程使用CPU，也就是说多线程并不是真正意义上的同时执行\n问题1: 什么时候会释放Gil锁,\n答 :\n1 遇到像 i/o操作这种 会有时间空闲情况 造成cpu闲置的情况会释放Gil\n2 会有一个专门ticks进行计数 一旦ticks数值达到100 这个时候释放Gil锁 线程之间开始竞争Gil锁(说明:\nticks这个数值可以进行设置来延长或者缩减获得Gil锁的线程使用cpu的时间)\nGil锁  : 保证同一时刻只有一个线程能使用到cpu\n互斥锁 : 多线程时,保证修改共享数据时有序的修改,不会产生数据修改混\n\n2轮：\nC++和python里的future是分别是干啥的\n\n要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。\nPython提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。举例说明如下：\n\n3轮：\n看你做过爬虫，知道有哪些反爬虫的机制 = = （这个问题问的贼多，跟面试官探讨了很久，提了好几个方案都看他不是很满意）\n\n通过UA 识别爬虫 有些爬虫的UA是特殊的，与正常浏览器的不一样，可通过识别特征UA，直接封掉爬虫请求\n设置IP访问频率，如果超过一定频率，弹出验证码 如果输入正确的验证码，则放行，如果没有输入，则拉入禁止一段时间，如果超过禁爬时间，再次出发验证码，则拉入黑名单。当然根据具体的业务，为不同场景设置不同阈值，比如登陆用户和非登陆用户，请求是否含有refer。\n通过并发识别爬虫 有些爬虫的并发是很高的，统计并发最高的IP，加入黑名单（或者直接封掉爬虫IP所在C段）\n请求的时间窗口过滤统计 爬虫爬取网页的频率都是比较固定的，不像人去访问网页，中间的间隔时间比较无规则，所以我们可以给每个IP地址建立一个时间窗口，记录IP地址最近12次访问时间，每记录一次就滑动一次窗口，比较最近访问时间和当前时间，如果间隔时间很长判断不是爬虫，清除时间窗口，如果间隔不长，就回溯计算指定时间段的访问频率，如果访问频率超过阀值，就转向验证码页面让用户填写验证码\n限制单个ip/api token的访问量 比如15分钟限制访问页面180次，具体标准可参考一些大型网站的公开api，如twitter api，对于抓取用户公开信息的爬虫要格外敏感\n识别出合法爬虫 对http头agent进行验证，是否标记为、百度的spider，严格一点的话应该判别来源IP是否为、baidu的爬虫IP，这些IP在网上都可以找到。校验出来IP不在白名单就可以阻止访问内容。\n蜜罐资源 爬虫解析离不开正则匹配，适当在页面添加一些正常浏览器浏览访问不到的资源，一旦有ip访问，过滤下头部是不是搜素引擎的蜘蛛，不是就可以直接封了。比如说隐式链接。\n\n\n策略1：设置下载延迟，比如数字设置为5秒，越大越安全\n策略2：禁止Cookie，某些网站会通过Cookie识别用户身份，禁用后使得服务器无法识别爬虫轨迹\n策略3：使用user agent池。也就是每次发送的时候随机从池中选择不一样的浏览器头信息，防止暴露爬虫身份\n策略4：使用IP池，这个需要大量的IP资源，可以通过抓取网上免费公开的IP建成自有的IP代理池。\n策略5：分布式爬取，这个是针对大型爬虫系统的，实现一个分布式的爬虫，主要为以下几个步骤：  1、基本的http抓取工具，如scrapy；  2、避免重复抓取网页，如Bloom Filter；  3、维护一个所有集群机器能够有效分享的分布式队列；  4、将分布式队列和Scrapy的结合；  5、后续处理，网页析取(如python-goose)，存储(如Mongodb)。\n策略6：模拟登录—浏览器登录的爬取 设置一个cookie处理对象，它负责将cookie添加到http请求中，并能从http响应中得到cookie，向网站登录页面发送一个请求Request, 包括登录url，POST请求的数据，Http header利用urllib2.urlopen发送请求，接收WEB服务器的Response。\n\n\n第一题，不能用系统自带的除法，要求用算法自己implement一个除法。\nif __name__ == &#x27;__main__&#x27;:    def div(a, b):        ans = 0        while a &gt;= b:            x = b            y = 1            while a &gt;= (x&lt;&lt;1):                x &lt;&lt;= 1                y &lt;&lt;= 1            ans += y            a -= x        return ans    print(div(3, 2))\n第二题，用O（n）的方法找到一个无序数组的中位数\ndef findmid(nums):    def swap(nums, i, j):        nums[i], nums[j] = nums[j], nums[i]    def quickFind(nums, target, left, right):        pivot = left        swap(nums, pivot, right)        l = left        r = right - 1        i = l        while i &lt;= r:            if nums[i] &lt; nums[right - 1]:                swap(nums, i, l)                l += 1            else:                swap(nums, i, r)                r -= 1        swap(nums, i, right)        if i == target:            return nums[i]        elif i &lt; target:            return quickFind(nums, target - i, i + 1, right)        return quickFind(nums, target, left, i - 1)    if not nums:        return None    n = len(nums)    if n % 2:        return quickFind(nums, n // 2, 0, n - 1)    else:        return (quickFind(nums, n // 2, 0, n - 1) + quickFind(nums, n // 2 - 1, 0, n - 1)) / 2if __name__ == &#x27;__main__&#x27;:    l = [[], [1], [1, 2], [1,2,3], [2,1,3]]    for i in l:        print(findmid(i))\n\n梯度爆炸梯度消失\n\bL1范数L2范数原，公式\nL1\n\n$$\nJ=J_{0}+\\alpha \\sum_{w}|w|\n$$\nL2\n\n$$\nJ=J_{0}+\\alpha \\sum_{w}w^2\n$$\n\n为什么能够处理过拟合\n\n奥卡姆剃刀原理，模型越简单越好\n相当于是对模型的解空间进行约束\n\n\n\nL1会趋向于产生少量的特征，而其它特征都是0。L2会选择更多的特征，这些特征都会趋近于0。L1在特征选择时非常有用，而L2只是一种防止过拟合的方法。在所有特征中只有少数特征起重要作用的情况下，选择L1范数比较合适，因为它能自动选择特征。而如果所有特征中，大部分特征都能起作用，而且起的作用很平均，那么使用L2范数也许更合适。\n过拟合\n训练过程中的损失减小，准确度提升，但是在测试的时候loss会增大，准确度减小。\n模型太过于复杂造成的，解决方法包括：\n数据方面：数据增广、减少数据的维度\n模型方面：用较简单的模型、使用BN、Dropout\n损失方面：添加增则项、加大增则项的权重、换一个损失\n训练方面：提前终止\nYolo ssd fast系列区别\n包括yolo 1-3（对于yolo的细节提问）\nssd 各种变体\n判断链表有环\ndef exisitCircle(head):    if not head:        return False    slow, fast = head, head    while fast and fast.next:        fast = fast.next.next        slow = slow.next        if fast == slow:            return True   return False\n二叉树中序遍历\ndef inorder(root):    l = []    cur = root    ans = []    while l or cur:        if cur:            l.append(cur)            cur = cur.left        else:            cur = l.pop()            ans.append(cur.val)            cur = cur.right    return ans\n","tags":["面试"]},{"title":"面经大杂烩","url":"/article/%E9%9D%A2%E7%BB%8F%E5%A4%A7%E6%9D%82%E7%83%A9/","content":"Q. 多线程中线程hang住是什么原因\nA.\nQ. TCP和UDP的区别? 都适用于那些场景？\nA. TCP是面向连接的，通过各种机制来保证数据传输的准确性。例如三次握手，四次挥手、滑动窗口、重传等等。UDP面向无连接，是一个无状态的传输协议，传输速度比TCP要快。由于没有TCP那样的可靠机制，他的连接是不可靠的。在网络状态不好的情况下，容易产生丢包。因此，在要求传输准确无误的场景下需要是用TCP协议，例如文件传输中http、https、FTP、pop、SMTP等协议，都需要保证传输的准确性。而在速度要求较高，准确度要求不高的情况下，可以使用UDP协议，例如一些语音、时频的传输，等\nref: https://www.cnblogs.com/williamjie/p/9390164.html\nQ. 什么时候用长连接什么时候用短连接?\nA. 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。\nQ. 曲折打印二叉树(写对)，\ndef zigzagTree(root):    if not root:        return root    stack = []    ans = []    stack.append(root)    leftToRight = True    while stack:        n = len(stack)        temp = []        for i in range(n):            p = stack.pop()            print(p.val, end=&#x27; &#x27;)            if leftToRight:                if p.left:                    temp.append(p.left)                if p.right:                    temp.append(p.right)            else:                if p.right:                    temp.append(p.right)                if p.left:                    temp.append(p.left)        print()        leftToRight = not leftToRight        stack.extend(temp)    return ans            \nQ. 全组合\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。示例:输入: n = 4, k = 2输出:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]\nclass Solution(object):    def combine(self, n, k):        &quot;&quot;&quot;        :type n: int        :type k: int        :rtype: List[List[int]]        &quot;&quot;&quot;        def dfs(ans, n, k, t, start):            if len(t) == k:                ans.append(copy.copy(t))                return                        for i in range(start, n+1):                t.append(i)                dfs(ans, n, k, t, i+1)                t.pop()                    ans = []        dfs(ans, n, k, [], 1)        return ans\nQ. 推导LR公式，LR的梯度下降，sigmoid函数\nA. https://www.cnblogs.com/lxs0731/p/8573044.html\nQ. 推导SVM公式\nA.\nQ. struct{uid 、loginTime、 logoutTime}，一个app的用户可能回登录和登出（并且只有一次登陆登出），给定用户登陆登出的数组，求在一天之内的在线人数的峰值，精确到秒。输出格式是：&lt;峰值出现时间startTime ，峰值结束时间endTime&gt;\nA. 一天总共有3600*24=86400秒。定义一个长度为86400的整数数组intdelta[86400]，每个整数对应这一秒的人数变化值，可能为正也可能为负。开始时将数组元素都初始化为0。然后依次读入每个用户的登录时间和退出时间，将与登录时间对应的整数值加1，将与退出时间对应的整数值减1。这样处理一遍后数组中存储了每秒中的人数变化情况。定义另外一个长度为86400的整数数组intonline_num[86400]，每个整数对应这一秒的论坛在线人数。假设一天开始时论坛在线人数为0，则第1秒的人数online_num[0]=delta[0]。第n+1秒的人数online_num[n]=online_num[n-1]+delta[n]。这样我们就获得了一天中任意时间的在线人数。\nQ. 1-25放在5*5格子里，每一行每一列都按照递增的顺序放，有多少种放法？\nQ. 有一个数组里有n个数，要求从中等概率的取出k个数。\nA. 类似于抽奖的时候，先抽后抽的概率都相等。可以把这个看成是一个无放回的抽奖。如果你还记得高中时候数学课本上抽奖（抽奖这种做法是不是等概率的）那个案例的话，你会瞬间秒懂。答案是肯定的，但也是相当简单的，就一句话，每次选中的元素跟当前选择长度的最后一个元素做交换，即可。最开始N个数字，第一次选了a[i]，那么就将a[i]与a[n-1]做交换，然后呢，再从a[0, 1, 2,……, n-2]中再随机选择，如果选中了a[k]，那么就将a[k]与a[n-2]做交换，然后从a[0, 1, 2,……, n-3]中再随机选择……直到选够M个数字，取出最后M个数字即可。这么做就省去了移动的时间成本，时间复杂度为O(n)，终于完工了。\n无需数组中求第k大的数\nQ. 链表的快排\nQ. 列举常见的一些范数及其应用场景，如 L0，L1，L2，L∞，Frobenius 范数\n\n\n\nQ. 简单介绍一下 sigmoid，relu，softplus，tanh，RBF 及其应用场景\nA.\nSigmoid:\n\nRelu:\n\nSoftplus:\n\ntanh:\n\n\n\n\nQ. 数值计算中的计算上溢与下溢问题，如 softmax 中的处理方式\nA.\n下溢： 当接近零的数被四舍五入为零时发生下溢。\n上溢：当大量级的数被近似为∞ 或−∞时发生上溢。进一步的运算通常会导致这些无限值变为非数字。\n\n①c和c++的结构体、类有什么区别\n概念：class和struct的语法基本相同，从声明到使用，都很相似，但是struct的约束要比class多，理论上，struct能做到的class都能做到，但class能做到的stuct却不一定做的到。\n类型：struct是值类型，class是引用类型，因此它们具有所有值类型和引用类型之间的差异。\n效率：由于堆栈的执行效率要比堆的执行效率高，但是堆栈资源却很有限，不适合处理逻辑复杂的大对象，因此struct常用来处理作为基类型对待的小对象，而class来处理某个商业逻辑。\n关系：struct不仅能继承也能被继承 ，而且可以实现接口，不过Class可以完全扩展。内部结构有区别，struct只能添加带参的构造函数，不能使用abstract和protected等修饰符，不能初始化实例字段。\n②计算机组成原理—层次化存储结构\n③int和malloc定义数组的区别\n④指针和引用的区别\n⑤深度学习中1*1卷积的作用\n⑤python中深拷贝 浅拷贝的区别\n⑥项目\n大概酱，15分钟的样子\nhttps://blog.csdn.net/u014451076/article/details/79156967/\n\n\n\n简历项目和比赛介绍，中间有问一些项目和比赛细节，问了一些延伸和开放性问题：\n\n\nAdam和SGD优化器哪个更好，好在哪里，哪个使模型更加容易发散?\n\n\nFPN作用\nhttps://www.jianshu.com/p/5a28ae9b365d\n\n\n讲下yolov3的架构，和two-stage的mask-rcnn有什么区别\n\n\n\n\n代码测试，求n个数里面前k个最大的数。 我最开始说用快排，面试说还有其他方法吗，我一紧张说了个时间复杂度更大的方法，面试官提醒我可以考虑树排序，但是我没学过，回答不上来，最后面试官说你本科没学过数据结构，那就先算了。\n\n\n问了几个机器学习算法，KNN和SVM的细节。 这里答的不好，太久没用传统机器学习算法，很多东西都忘了，中间一个简单的几何中常见距离计算方式(欧式距离)，我忘了居然答余弦距离。\n\n\n问了我有什么想问的。\n\n\n\n\nfaster rcnn、Mask rcnn的细节，faster rcnn的rpn结构介绍下，rpn的loss是什么，master rcnn和faster rcnn有什么区别和改进\n\nretinanet的结构和创新点，讲一下ssd和retinanet的区别\n\n\nresnet网络的创新，为什么能解决梯度消失问题，残差模块详细介绍下，为什么能解决网络层数加深带来的梯度消失和网络退化问题。\n从图像分类网络:resnet等，到目标检测和图像分割网络：faster rcnn、mask rcnn、ssd、yolov3等彻底掌握基础原理和细节，多看相关论文和博客。\n给定两矩形的左上角和右下角坐标，求两矩形的重叠区域面积（overlap），若不重叠，返回0。（其实就是计算IOU）。\n实现softmax，包括init，forward，backward。\n\n对图像做45度旋转，如何使图像完整不缺失，缺失和超出的部分如何处理？\n除了基本的的acc,loss，roc、auc有了解吗？\nROI Pooling和ROI Align的区别及演进\n离线图像增强与在线图像增强有什么区别\n\nPython和计算机常考基础\n\n装饰器怎么用\n深拷贝和浅拷贝的区别\n多线程和多进程的区别\n\n\nLinux和git命令操作基础\n\nlinux查找、查看文件的3个常用命令：which、find、wheresis。（这里应该是查找命令，当时也没听清楚，连就说了cat查看文件、which、find）\n统计文件夹下的文件个数:ls -l | grep “^_” | wc -l（这个操作，我之前用过很多次，但是没说的很清楚，不过意思应该表达清楚了）\n\n\ngit的一个操作（具体问题真的忘了）\n\n一面总结\n\nPython一些基础还是要搞清楚，向迭代器、深拷贝、浅拷贝，我之前都看过面经和用法，都还是忘了，真是不应该。\n地平线机器人面试真的问的很广，偏工程向，碰到不会的也不要太紧张，之后一定要去补课。\n自己要加强Python基础的一些技术盲点。\n以后面试表达要有针对性，可以引导面试官往自己熟悉的方向，但不要拓展太多。\n\n二面（70分钟）\n\n\n项目介绍\n\n项目细节，和由项目延伸的原理问题\n细粒度图像分类了解吗\n\n\n\n目标检测框架原理问题\n\n\nRPN结构讲下，RPN的loss有哪些，分类loss是二分类还是多分类\n\n\nROI Pooling是在RPN前面还是后面，讲下原理，有什么作用\n\n\nROI Polling和ROI Align的区别\n\n\nhttps://www.jianshu.com/p/9db81f1bb439\n\n\n\n\n\n\n\nMask RCNN基本结构讲下\n\n\n1*1卷积作用（降维－改变特征通道数，加入非线性）\n\n\nFaster RCNN的loss有哪些，分别讲下\n\n\n\n\nCNN的SOTA模型原理\n\nResNet结构讲下，它解决了什么问题\nInceptionV3结构讲下\n\n\n\nC/C++/Python基础\n\nPython装饰器解释下，基本要求是什么（参数为函数，返回为函数，本质是嵌套函数）\nC的结构体和C++类的区别(C结构体不能定义函数)\n__init__函数有什么用\nPython怎么继承父类的__init__函数（super操作）\n面向对象编程和面向过程编程区别\n\n\n\nLinux系统基础操作\n\n一些基本命令\n管道命令解释下\n统计文件夹下的文件个数:ls -l | grep “^_” | wc -l\n\n\n\ngit相关操作\n\ngit熟不熟悉，平常怎么用\n除了commit、pull等基本命令，还用过哪些\n\n\n\n嵌入式Linux系统\n\ntensorflow安装是源码安装还是pip/conda安装，交叉编译用过吗\ncmake语法了解吗\n数据增强用了哪些，为什么用\n\n\n\n\n图像分割结果，如果边缘信息本来是直线的，但是分割出来效果线确是弯的，怎么解决（有点记不清了）\n\n一面\n\nPower(a,n) 常规递归方法写完让写一个O（1）的方法\n岛计数问题 dfs\n哪些处理过拟合的办法：正则，剪枝，dropout\nCNN里面能自然起到防止过拟合的办法\nbagging vs boosting简述\nSGD每步做什么，为什么能online learning\nLogistic Regression损失函数，怎么来的\n\n二面\n\nCNN反向传播细节，怎么过全联接层、池化层、卷积层\nAdam优化器的迭代公式\nCNN多分类损失函数 softmax\n字符串最小编辑路径\n\n三面\n\n线性回归R^2公式及意义\np-value意义，怎么算？怎么做单边检验\n随机过程 稳态是什么\n时间序列 常用模型，arima模型的公式？自回归在机器学习中的应用？\n计算几何分布期望\n熟悉什么机器学习算法（SVM），写损失函数（hinge+正则）\n找完全二叉树最后一个节点\n找字典序的第k个数\n\n百度\n\n一面\n\n项目相关\n给定一个m*n的矩形，他能包含的不同面积的矩形的数量，返回【面积，对应的计数】\n给定一个树，树的每一个中间节点都会他相邻的父节点有连接，求根节点到叶子结点的最大路径和\n给定一个硬币，抛出正面的概率为p，反面的概率为1-p。用这枚硬币，生成一个等概率返回1和0的方法\n\n二面\n\n整个二面提出了一些比较开放性的问题\n数据清洗有哪些方法\n对缺失的数据改如何处理\n交叉熵的含义\n演示如何对决策树进行划分\n决策树划分的时候，如果遇到了缺失数据改如何处理\n数组中的逆序对数\n如何将数据转换为概率\n为什么用softmax可以转换为概率，而不直接用$\\frac{wx_i}{\\sum_{x_j}{wx_j}}$\n如何用svm实现learning2rank\n\n题目：\n已知一随机发生器，产生0的概率是p，产生1的概率是1-p，现在要你构造一个发生器，\n使得它构造0和1的概率均为1/2\n解决方案：\n这是随机概率发生器的典型题目。\n由于需要产生1/2，而用1位0，或1位1无法产生等概率，因此，考虑将随机数扩展成2位：\n00 pp\n01 p(1-p)\n10 (1-p)p\n11 (1-p)(1-p)\n有上述分析知道，01和10是等概率的，因此我们只需要产生01和10就行了。\n于是可以，遇到00和11就丢弃，只记录01和10。可以令，01表示0,10表示1，则等概率1/2产生0和1了。\n扩展：\n已知一随机发生器，产生0的概率是p，产生1的概率是1-p，现在要你构造一个发生器，\n使得它构造0和1的概率均为1/2；构造一个发生器，使得它构造1、2、3的概率均为1/3；…，\n构造一个发生器，使得它构造1、2、3、…n的概率均为1/n，要求复杂度最低。\n解答：\n对n=2，认为01表示0、10表示1，等概率，其他情况放弃\n对n=3，认为001表示1、010表示2，100表示3，等概率，其他情况放弃\n对n=4，认为0001表示1、0010表示2，0100表示3，1000表示4，等概率，其他情况放弃\n首先是1/2的情况，我们一次性生成两个数值，如果是00或者11丢弃，否则留下，01为1，10为0，他们的概率都是p*(1-p)是相等的，所以等概率了。然后是1/n的情况了，我们以5为例，此时我们取x=2，因为C(2x,x)=C(4,2)=6是比5大的最小的x，此时我们就是一次性生成4位二进制，把1出现个数不是2的都丢弃，这时候剩下六个:0011,0101,0110,1001,1010,1100，取最小的5个，即丢弃1100，那么我们对于前5个分别编号1到5，这时候他们的概率都是pp(1-p)*(1-p)相等了。\n关键是找那个最小的x，使得C(2x,x)&gt;=n这样能提升查找效率\n\n2、给一个无序数组，将数组分成两堆，使得两堆数的平均值相差最大。口述思路就好\n3、神经网络中解决过拟合的方法？\n4、神经网络中的优化器有哪些？常用的优化器你是如何进行选择的？\n二面30min：\n1、介绍简历上的项目\n2、常用的机器学习算法用过哪些？介绍lr的一个原理\n3、手写一个二叉排序树的建立过程，写完后拍照发微信\n4、点击率预估模型了解过哪些？\nhr面：\n1、自我介绍\n2、你对工作地点的偏好？\n3、工作内容的偏好？\n4、反问：拼多多的新人培养和晋升机制是什么？\n\n秋招记录-百度核心搜索部\n一面：\n1、链表反转\n2、字符串的最长公共子序列（输出该子序列，用的动态规划）\n动态规划的思路：\npackage DynamicProgramming;public class LongestCommonSubSequence &#123;    public static int[][] findLongestSubStrDP(String str1,String str2)&#123;        char[] char1 = str1.toCharArray();        char[] char2 = str2.toCharArray();        int[][] dp = new int[char1.length][char2.length];        for(int i=0;i&lt;char1.length;i++)&#123;            for(int j=0;j&lt;char2.length;j++)&#123;                if(i==0)&#123;                    dp[i][j] = (char2[j] == char1[i] ? 1:0);                &#125;                else if(j==0)&#123;                    dp[i][j] = (char2[j] == char1[i] ? 1:0);                &#125;                else&#123;                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);                    if(char1[i] == char2[j])                        dp[i][j] = Math.max(dp[i][j],dp[i-1][j-1] + 1);                &#125;            &#125;        &#125;        return dp;    &#125;    public static String lcse(String str1,String str2,int[][] dp)&#123;        char[] char1 = str1.toCharArray();        char[] char2 = str2.toCharArray();        int m = char1.length-1;        int n = char2.length-1;        char[] res = new char[dp[m][n]];        int index = res.length-1;        while(index &gt;= 0)&#123;            if(n&gt;0 &amp;&amp; dp[m][n] == dp[m][n-1])                n--;            else if(m&gt;0 &amp;&amp; dp[m-1][n] == dp[m][n])                m--;            else&#123;                res[index--] = char1[m];                m--;                n--;            &#125;        &#125;        return String.valueOf(res);    &#125;    public static void main(String[] args)&#123;        String str1 = &quot;1A2C3D4B56&quot;;        String str2 = &quot;B1D23CA45B6A&quot;;        int[][] dp = findLongestSubStrDP(str1,str2);        String res = lcse(str1,str2,dp);        System.out.println(res);    &#125;&#125;\n3、介绍项目\n4、XGBOOst和GBDT的区别。\n• 传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。\n• 传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。\n• xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。\n• Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。实际应用中，一般把eta设置得小一点，然后迭代次数设置得大一点。（补充：传统GBDT的实现也有学习速率）\n• 列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。\n• 对缺失值的处理。对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向。\n• xgboost工具支持并行。boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。\n• 可并行的近似直方图算法。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。\n二面：\n1、介绍项目\n2、RNN简单介绍一下，BPTT推导\n3、后面又写了三层神经网络的推导\n4、python中的dict，如何按照值去排序（面试官想考的是lambda函数）\n5、python中，如何交换两个数的值，x，y = y，x\n6、强化学习和监督学习的区别\n1）强化学习是一个多次决策的过程，可以形成一个决策链，即西瓜书上种西瓜的例子；监督学习只是一个一次决策的过程。\n2）有监督学习的训练样本是有标签的，强化学习的训练是没有标签的，它是通过环境给出的奖惩来学习。\n3）监督学习的学习目标是跟给定的标签越接近越好，而强化学习不是，它希望能够获得的reward越大越好。\n7、强化学习DQN有哪些改进方向\nDouble -DQN／优先经验回放／Dueling-DQN\n8、神经网络里面的损失函数有哪些\n我写了交叉熵和平方损失，用python实现一个交叉熵函数，考虑的严谨一些\n9、机器学习中常见的激活函数有哪些？\n10、为什么通常需要零均值\nSigmoid 的输出不是0均值的，这是我们不希望的，因为这会导致后层的神经元的输入是非0均值的信号，这会对梯度产生影响：假设后层神经元的输入都为正(e.g. x&gt;0 elementwise in ),那么对w求局部梯度则都为正，这样在反向传播的过程中w要么都往正方向更新，要么都往负方向更新，导致有一种捆绑的效果，使得收敛缓慢。\n11、如果逻辑回归的所有样本的都是正样本， 那么它学出来的超平面是怎样的？\n所有数据点分布在超平面的一侧\n12、你本科学习的方向有点怪(信息管理与信息系统和金融学的双学位)，前两份实习也有点瞎找的感觉，你是如何思考的?\n13、树的前序遍历和zigzag遍历（非递归）。\nzigzag遍历：两个栈\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if(root == null)            return res;        Stack&lt;TreeNode&gt; level = new Stack&lt;TreeNode&gt;();        level.push(root);        boolean flag = true;        while(!level.isEmpty())&#123;            Stack&lt;TreeNode&gt; tmp = level;            level = new Stack&lt;TreeNode&gt;();            List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;();            while(!tmp.isEmpty())&#123;                TreeNode t = tmp.pop();                temp.add(t.val);                if(flag)&#123;                    if(t.left != null)                        level.push(t.left);                    if(t.right != null)                        level.push(t.right);                &#125;                else&#123;                    if(t.right != null)                        level.push(t.right);                    if(t.left != null)                        level.push(t.left);                                    &#125;            &#125;            flag = !flag;            res.add(temp);        &#125;        return res;    &#125;&#125;\n三面：\n1、自我介绍\n2、项目探讨\n3、自己的职业规划是怎样的\n4、你找工作更看重的是哪一个方面\n5、对硬性条件的要求\n6、业务交流\n\n知乎连续面了三面，第三面挂了，不过还是学习到了不少的东西。\n一面：\n1、介绍项目\n2、一个数组，所有数组都出现了两次，只有一个数出现了一次，返回这个数\n这个题很简单，两个相同的数的异或是0，因此所有数求异或，剩下的数即为我们要求的数。\nclass Solution &#123;    public int singleNumber(int[] nums) &#123;        int res = 0;        for(int i=0;i&lt;nums.length;i++)            res ^= nums[I];        return res;    &#125;&#125;\n3、一个数组，一个数出现了超过一半次数，返回这个数\n这里用到的就是两两消除的思路。\nclass Solution &#123;    public int majorityElement(int[] nums) &#123;        if(nums==null || nums.length==0)            return -1;        int res = nums[0];        int count = 1;        for(int i=1;i&lt;nums.length;i++)&#123;            if(res == nums[I])                count++;            else&#123;                if(count==0)&#123;                    count ++;                    res = nums[I];                &#125;                else                    count--;            &#125;        &#125;        return res;    &#125;&#125;\n4、将除法的结果用字符串返回，如果能够除尽，则返回相除的结果，如果不能除尽，则无限循环部分用[]标记。\n这里我采用了队列和Map的做法，使用map记录每个除数出现的位置，如果出现了相同的除数，则表明出现了无限循环部分。如果除数变成了0，则说明除尽了。\nimport java.util.*;public class DivideTwoInteger &#123;    public static void divide(int p1,int p2)&#123;        Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();        int intPart = p1 / p2;        int reminder = p1 % p2;        if(reminder == 0)&#123;            System.out.println(&quot;&quot; + intPart);            return;        &#125;        Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();        map.put(reminder,0);        int index = 0;        while(true)&#123;            queue.offer(reminder * 10 / p2);            reminder = reminder * 10 % p2;            if(map.containsKey(reminder) || reminder==0)                break;            else                map.put(reminder,++index);        &#125;        StringBuilder stb = new StringBuilder();        stb.append(intPart + &quot;&quot;);        stb.append(&quot;.&quot;);        if(reminder == 0)&#123;            while(!queue.isEmpty())                stb.append(queue.poll() + &quot;&quot;);            System.out.println(stb.toString());        &#125;        else&#123;            int pos = map.get(reminder);            index = 0;            while(index &lt; pos)                stb.append(queue.poll() + &quot;&quot;);            stb.append(&quot;[&quot;);            while(!queue.isEmpty())                stb.append(queue.poll() + &quot;&quot;);            stb.append(&quot;]&quot;);            System.out.println(stb.toString());        &#125;    &#125;    public static void main(String[] args)&#123;        divide(1,3);        divide(100,3);        divide(6,3);        divide(10,4);    &#125;&#125;\n5、介绍下DeepFM\n二面：\n1、介绍项目\n2、word2vec的原理简单介绍下\n有关word2vec的原理，大家可以看https://blog.csdn.net/itplus/article/details/37969519\n3、DeepFM介绍下\n4、FM推导\n\n5、数组排序，假设数组排序后的位次和排序前的位次绝对值差值小于K，有什么比快排好的算法？\n堆排序，建堆的过程是KlogK。我开始说用堆排序，先将数组的前K+1个元素建堆，然后每次出去一个进来一个，完成排序。面试官问我，这样做是有序的么。我一开始说不一定，但仔细想想，一定是有序的。我们来分析一下。\n因为排序前和排序后，同一个数字的索引之差小于等于K。假设K=3，也就是说，索引为2的数，在排序后，最大位置不超过5。再假设我们当前找到的是排序后索引为2的数，且后面有一个数比这个要小。由于这个数不在堆中，因此这个数的排序前索引一定大于5，这与假设相矛盾。因此用堆排序一定能保证数组有序。\n6、树中两个节点的第一个的公共祖先。\n这个题Leetcode上有原题：https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/\n代码贴出来：\n/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        if(root==null || root == p || root== q)            return root;        TreeNode left = lowestCommonAncestor(root.left,p,q);        TreeNode right = lowestCommonAncestor(root.right,p,q);        if(left!=null &amp;&amp; right!=null) return root;        return left !=null?left:right!=null?right:null;    &#125;&#125;\n三面：\n1、介绍下项目\n2、word2vec里面的层次索引\n3、boosting和bagging的区别？\n1）样本选择上：\nBagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的.\nBoosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化.而权值是根据上一轮的分类结果进行调整.\n2）样例权重：\nBagging：使用均匀取样，每个样例的权重相等\nBoosting：根据错误率不断调整样例的权值，错误率越大则权重越大.\n3）预测函数：\nBagging：所有预测函数的权重相等.\nBoosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重.\n4）并行计算：\nBagging：各个预测函数可以并行生成\nBoosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果.\n4、bagging为什么能减小方差？\n参考博客：https://blog.csdn.net/shenxiaoming77/article/details/53894973\n\n可能不懂的地方看下面的公式就知道了：\n\n5、交叉熵损失函数，0-1分类的交叉熵损失函数的。什么是凸函数？0-1分类如果用平方损失为什么用交叉熵而不是平方损失？\n这里我们只回答最后一个问题，也就是说逻辑回归为什么不用平方损失？有两点原因：\n1）平方损失函数非凸函数。为什么非凸？凸函数二阶导数大于等于0，证明一下即可。\n2）但是会在h(wx)接近0和1的地方梯度很小，不容易学习。\n6、python里的gc和多线程。\n在Python中，为了解决内存泄露问题，采用了对象引用计数，并基于引用计数实现自动垃圾回收。\n\nThoughtWorks面试总的来说体验非常棒，尤其是算法加面的时候，面试官还给我点了美团外卖。\n笔试：一道小小的编程项目\nHR面：\n1、先介绍一下项目\n2、哪的人\n3、对户口是否有要求\n4、期望的薪资\n5、为什么不留美团要来TW。\n6、一个间断的英语面试，不过我说好几年没学习英语了，面试官就放弃了。\n技术面：\n1、根据笔试作业，提出新的需求，要自带电脑并接投影仪，面试官看着你写代码\n2、问项目\n可能面试官非算法面试官吧，也没问很多技术问题。\n三天后收到消息，拿到offer了，不过想要是算法工程师的话，需要进行一轮加面。如果加面不通过，可以给软件开发工程师的offer，不管怎样，也算秋招的第一个offer了嘛。\n加面：\n1、指针网络介绍\n2、指针网络／seq2seq的区别／你们的项目可不可以用seq2seq\n3、强化学习DQN介绍\n4、强化学习的应用场景\n这里我说了一个序列决策，比如新闻的分屏推荐\n5、完整介绍一下推荐系统\n先讲了协同过滤，后来发现讲不下去了，干脆直接讲ctr预估，从传统方法LR、FM、FFM、GBDT+LR到深度学习方法再到强化学习方法。\n6、DeepFM介绍\n7、Abtest是怎么做的\n8、Beam-Search介绍\n–\n秋招记录-美团留用面试\n\n两个字：细节。感觉凉凉\n只有一面交叉面\n1、自我介绍\n2、你的博客一般是什么内容的，多久更新一次\n3、回归问题的损失函数都有哪些？从哪些角度设计一个合理的损失函数？\nhttps://www.zhihu.com/question/68390722/answer/266034620\n4、哪些场景下的分类问题不适用于交叉熵损失函数？\n5、推荐系统中你认为最重要的环节是什么？我答的探索与利用。\n6、多臂老虎机中，有许多方法，比如e-greedy，timponson采样，UCB，这些方法都有哪些适用场景？\n7、L1和L2有什么区别，从数学角度解释L2为什么能提升模型的泛化能力。\nhttps://www.zhihu.com/question/35508851\nhttps://blog.csdn.net/zouxy09/article/details/24971995\n8、深度学习中，提升模型泛化能力的方法都有哪些？\n9、深度学习中，L2和dropout有哪些区别？\nhttps://blog.csdn.net/stdcoutzyx/article/details/49022443\n10、L1正则化有哪些好处？\n11、职业规划\n\n一面：\n1、链表反转\n2、如何预测一家店分品类的销量\n这里没有考虑到的一点是：商家可能存在的活动，比如折扣、满减活动、满赠活动等\n二面：\n1、介绍一个你了解的算法\n我讲了SVM。中间问了几个问题\n1）几何间隔是什么\n2）核函数的作用是什么\n2、类别变量，可以不用one-hot么？\n3、如果有一万个地理坐标，转换成1-10000的数，可以用决策树么？\n三面：\n1、问项目\n流程非常快。。。\n\n面试体验不错，就是等的时间有点久，一面等了一个小时，二面等了一个半小时。\n面试一共三轮：两轮技术面+一轮hr面\n结果7-10个工作日出，然后毕业生去贝壳有租房的福利，新人入职的话会有暴走活动、王者荣耀等活动。\n一面：\n1、先考一个二分查找，用python写\n2、用python实现一个读文件，同时对每一列特征进行最大-最小值标准化，再将数据写回文件\n3、一道hive题，题目有点忘记了\n4、用tensorflow实现线性回归，主要考察的是一个tf的一个实现思路\n5、leetcode42题，题解在：https://leetcode.com/problems/trapping-rain-water/solution/，我用了第二种方法解决，面试官说没问题。\n6、决策树的实现、ID3、C4.5、CART，把公式要记好\n7、CART回归树是怎么实现的\n8、CART分类树和ID3以及C4.5有什么区别。我回答的是CART只能是二叉树\n9、剪枝有哪几种方式\n10、树集成模型有哪几种实现方式：Bagging和Boosting，回答过程中又问到了很多细节。随即森林的随机体现在哪些方面，AdaBoost是如何改变样本权重，GBDT分类树拟合的是什么？等等。\n11、介绍满减神器项目\n一面主要考察了树模型，同时第一次在面试中直接手撕tensorflow、numpy和hive sql代码。\n二面：\n1、介绍项目，问了一些关于美团-满减神器的东西\n2、一道二分查找相关的题目，面试官说独家题目，需要我保密，这里就不贴出来了\n三面-hr面：\n1、你找工作主要看重的是什么？\n2、介绍满减神器项目\n3、你手里有offer了么？\n4、你在项目中的不足之处有哪些？\n5、你最期望的工作方向是什么？\n\n上午面了一点资讯\n一面：\n1、问简历\n2、防止过拟合的方法\n3、DeepFm模型介绍一下\n4、判断是否是回文链表\n5、链表反转\n6、spark任务运行中，发生了数据倾斜，这种情况下你一般如何处理\n二面：\n1、问简历\n2、Dueling DQN和DQN有什么区别\n3、快速排序\n三面：\n1、介绍下DeepFM\n2、信息流采样，有n份数据，但是n的长度并不知道，设计一个采样算法，使得每份被选择的概率是相同的。\n考虑这样是不是可以，总是以1/i的概率去选择每一次遍历的对象，比如从1,2,3,…,N， 每一次遍历到x时，总是以1/x的概率去选择它。\n一开始选择第一个数据，并以概率1/2选择第二个数据,以1/3选择第三个数据，也就是说设结果为result，遍历第一个时result = 1,第二个以1/2的概率替让result = 2,这样一直遍历概率性的替换下去，最终的result就是你的结果。被选择的概率就是1/n。\n第x个数被选择的概率 = x被选择的概率 * (x+1没被选择的概率) * (x+2没有被选择的概率) …(N没有被选择的概率)\n被选择的概率 = 1/2  * 2/3 * 3/4 * 4/5 …* (n-1/n) 我想你知道答案了吧？ 对！ 是1/n.这样就可以在不知道N的大小的情况下等概率的去选择任意一个对象了！\n3、判断两个链表中是否有相同节点\nhttps://blog.csdn.net/Audience_/article/details/77648916\n4、模型在线下评估和线上使用时，往往出现线上实际效果不如线下效果的情况，请分析可能的原因。\n\n一面：\n1、简历\n2、c++中的stoi，用java实现了一下\n3、一道概率问题\n二面：\n1、介绍简历\n2、python中 a=1，b=1，那么a is b返回的是true还是false\nhttps://blog.csdn.net/weixin_35653315/article/details/71640473\n3、linux中，进程的子进程挂掉了，那么这个父进程会不会dump\n4、在CTR预估问题中，假设训练数据的正负样本数为1:4，测试数据中的正负样本数也为1:4，那么此时模型对测试集，学到的平均点击率为1/（1+4）,假设此时采取了欠采样策略，使正负样本数为1:1，对同样的测试集进行预测，平均点击率应该是多少？（样本量很大，初始总样本数为10亿）\n5、early stop对参数有什么影响？\n\n一面：\n1、介绍项目\n2、如何做一个依存分析，不会。。\n3、FM、DeepFM介绍一下\n4、介绍一下常用的CTR算法，从传统算法到深度学习算法。具体介绍一下Wide&amp;Deep模型\n5、计算树的深度\n6、旋转数组的二分查找\n7、Word2Vec模型的原理，使用哈夫曼树的原因是什么？word2vec的输入输出层是什么样的？\n二面：\n1、聊了一下人生的规划\n2、聊了一下猫眼在做的事情\n3、海量数据如何求中位数？数据无法放入内存，只需考虑空间复杂度，不需要考虑时间复杂度。\n4、朴素贝叶斯分类\n三面：\n全程怼项目，有一个问题问的比较好，你对你项目本身有没有信心，你对做好这个项目有没有信心。\n\n总体感觉问简历项目居多，其他方面问的比较少，可能我不太符合这么一个需求吧，面试官说在搜索推荐领域，理解用户的需求是十分重要的，因此可能自然语言处理需要有一定的基础吧。\n一面：\n1、问简历\n2、主要有几道算法题吧：\n大数相乘\n动态规划题\n有重复数字的排序数组的二分搜索问题。\n二面：\n1、问简历项目\n2、有负数存在的排序数组，按照数的绝对值进行排序\n3、介绍了一下搜狗搜索这边主要负责的事情\n三面：\n1、问项目，主要问了你在这个项目中的主要职责是什么\n2、从一个矩阵的左上角到右下角，只能向右或向下，一共有多少种走法？有比动态规划时间复杂度更低的算法么？如果有，时间复杂度是多少？\n3、如果在上面问题的基础上允许向左走，但是一条路径中每一个位置只能经过一次，问一共有多少种走法，我答了回溯法，问回溯法的复杂度是多少？\n4、有什么问题想问我？\n\n一面：\n1、问项目\n2、然后是三道笔试题，笔试题做完之后就结束了，笔试题三道题：\n1）子数组最大和\n2）堆排序\n3）数组中出现次数最多的K个数\n二面：\n1、包含重复数字的无序数组，找到所有加和等于target的索引对。\n2、三色旗问题 ，这道题没答上来，已经决定要凉凉了。\nhttps://blog.csdn.net/u011200844/article/details/43227301\n3、后面问了一些项目。\n\n面试从一点到八点，只面了两面，一面在中关村软件园国际会议中心，通过一面之后打车到滴滴楼下的咖啡厅进行二三面，由于时间太晚了，所以三面的话可能到节后再安排。这里先补充一二面面经。\n一面：\n1、介绍项目\n2、介绍下Adam优化器\n3、链表反转\n4、判断链表是否有环\n5、两个字符串的最小编辑距离\n6、python装饰器的原理\n7、python的迭代器\n8、Deepfm的原理，DeepFM是一个模型还是代表了一类模型，DeepFM对FM做了什么样的改进，FM的公式如何化简并求解梯度\n9、逻辑回归的损失函数，逻辑回归的损失函数为什么是logloss，背后服从的分布是什么？\n二面：\n1、spark sql 和 hive的区别是什么？spark sql和hive哪个更快一些，为什么？\n2、强化学习中有value-based 和 policy-based，这两种的优缺点分别是什么？应用场景分别是什么？\n3、介绍一下简历中的强化学习推荐项目\n4、介绍一下简历中的生成模型\n5、介绍一下常见的优化器\n6、如何判断神经网络的过拟合是否发生， 有什么解决方法\n7、介绍下drop-out 和 batch-normalization\n8、wide &amp; deep是怎么训练的，两部分用的优化器是一样的么？\n9、25匹马，有一条只能5匹马比赛的赛道，我们无法计时，只能看到马的排名，如何用最短的次数找出跑的最快的5匹马\n10、一条无限长的直线，有两个机器人，两个机器人执行同一段代码，这一段代码中只有几条语句：right代表向右走，left代表向左走，if arrived else代表另一个机器人是否走过这个地方。goto代表代码的跳转，请写一段代码确保两个机器人能够相遇。\n三面：\n1、介绍项目\n2、介绍一下常见的分类模型，以及他们的优缺点以及应用场景\n3、GBDT和XGBoost介绍一下，XGBoost做了哪些改进\n4、二叉树的前序遍历\n5、有一个序列，数字依次不断的添加进来，设计一个数据结构，能够快速返回这堆数字的中位数。(考虑堆排序、二叉排序树）\n6、强化学习中的value-based和policy-based的区别以及使用场景\n7、项目中目前的不足以及未来的展望，以及项目中遇到的最大的困难。\n8、梯度下降和拟牛顿法的区别。\n三面有一些题目想不起来了，面试官最后加了微信，希望能够有一个好结果\n\n压哨被内推了拼多多，应该是8月底笔试，然后很早就收到了笔试通过的通知，然而人在北京，因此没有选择去上海面试，所以到十月才接到电话面试的通知。\n总流程一共两轮电话面和一轮hr面，总体流程相对轻松，目前已到offer call阶段。\n有些忘记了，先写一些能记住的吧\n一面45min：\n1、介绍简历上的项目\n2、给一个无序数组，将数组分成两堆，使得两堆数的平均值相差最大。口述思路就好\n3、神经网络中解决过拟合的方法？\n1、L1正则化\nL1正则化算法用来防止过拟合时，是在损失函数上加入∣∣w∣∣ ||w||∣∣w∣∣，如下式所示：\n在优化损失函数的时候L1正则化会产生稀疏矩阵，导致一部分w为0，注意这也是L1正则化的核心思想。产生稀疏矩阵之后，一部分w为0，一部分不为0，这样即可对特征进行选择。选择比较重要、明显的特征作为分类和预测的依据，抛弃那些不重要的特征。\n2、L2正则化\nL2正则化算法用来防止过拟合时，是在算是函数上加上∣∣w∣∣2 ||w||^2∣∣w∣∣\n2\n,如下式所示：\n不同于L1正则化，L2正则化则是趋向于把所有参数w都变得比较小，一般认为参数w比较小的时候，模型比较简单。直观上来说，L2正则化的解都比较小，抗扰动能力强。在求解过程中，L2通常倾向让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。参数足够小，数据偏移得多一点也不会对结果造成什么影响，可以说“抗扰动能力强”。\n3、BN算法\nBatch Normalization有两个功能，一个是可以加快训练和收敛速度，另外一个是可以防止过拟合。\nBN算法是如何加快训练和收敛速度的呢？\nBN算法在实际使用的时候会把特征给强制性的归到均值为0，方差为1的数学模型下。深度网络在训练的过程中，如果每层的数据分布都不一样的话，将会导致网络非常难收敛和训练，而如果能把每层的数据转换到均值为0，方差为1的状态下，一方面，数据的分布是相同的，训练会比较容易收敛，另一方面，均值为0，方差为1的状态下，在梯度计算时会产生比较大的梯度值，可以加快参数的训练，更直观的来说，是把数据从饱和区直接拉到非饱和区。更进一步，这也可以很好的控制梯度爆炸和梯度消失现象，因为这两种现象都和梯度有关。\nBN最大的优点为允许网络使用较大的学习速率进行训练，加快网络的训练速度。\nBN算法时如何防止过拟合的？\n在这里摘录一段国外大神的解释：\nWhen training with Batch Normalization, a training example is seen in conjunction with other examples in the mini-batch, and the training network no longer producing deterministic values for a given training example. In our experiments, we found this effect to be advantageous to the generalization of the network.\n大概意思是：在训练中，BN的使用使得一个mini-batch中的所有样本都被关联在了一起，因此网络不会从某一个训练样本中生成确定的结果。\n这句话什么意思呢？意思就是同样一个样本的输出不再仅仅取决于样本本身，也取决于跟这个样本属于同一个mini-batch的其它样本。同一个样本跟不同的样本组成一个mini-batch，它们的输出是不同的（仅限于训练阶段，在inference阶段是没有这种情况的）。我把这个理解成一种数据增强：同样一个样本在超平面上被拉扯，每次拉扯的方向的大小均有不同。不同于数据增强的是，这种拉扯是贯穿数据流过神经网络的整个过程的，意味着神经网络每一层的输入都被数据增强处理了。\n相比于Dropout、L1、L2正则化来说，BN算法防止过拟合效果没那末明显。\n4、Dropout算法\nDropout为什么能够防止过拟合呢？\n最直观的原因其实就是：防止参数过分依赖训练数据，增加参数对数据集的泛化能力。因为在实际训练的时候，每个参数都有可能被随机的Drop掉，所以参数不会过分的依赖某一个特征的数据，而且不同参数之间的相互关联性也大大减弱，这些操作都可以增加泛化能力。\n更为深入的来讲，Dropout其实是一种分布式表示：\n分布式表征（Distributed Representation），是人工神经网络研究的一个核心思想。那什么是分布式表征呢？简单来说，就是当我们表达一个概念时，神经元和概念之间不是一对一对应映射（map）存储的，它们之间的关系是多对多。具体而言，就是一个概念可以用多个神经元共同定义表达，同时一个神经元也可以参与多个不同概念的表达，只不过所占的权重不同罢了。\n举例来说，对于“小红汽车”这个概念，如果用分布式特征地表达，那么就可能是一个神经元代表大小（形状：小），一个神经元代表颜色（颜色：红），还有一个神经元代表车的类别（类别：汽车）。只有当这三个神经元同时被激活时，就可以比较准确地描述我们要表达的物体。\n分布式表征表示有很多优点。其中最重要的一点，莫过于当部分神经元发生故障时，信息的表达不会出现覆灭性的破坏。比如，我们常在影视作品中看到这样的场景，仇人相见分外眼红，一人（A）发狠地说，“你化成灰，我都认识你（B）！”这里并不是说B真的“化成灰”了，而是说，虽然时过境迁，物是人非，当事人B外表也变了很多（对于识别人A来说，B在其大脑中的信息存储是残缺的），但没有关系，只要B的部分核心特征还在，那A还是能够把B认得清清楚楚、真真切切！人类的大脑还是真的厉害啊！\n再借用某大牛博主的一段话：\n在学习阶段，以概率p主动临时性地忽略掉部分隐藏节点。这一操作的好处在于，在较大程度上减小了网络的大小，而在这个“残缺”的网络中，让神经网络学习数据中的局部特征（即部分分布式特征）。在多个“残缺”之网（相当于多个简单网络）中实施特征，总要比仅在单个健全网络上进行特征学习，其泛化能力来得更加健壮。这里的“泛化”，实际上就是适应各种情况的能力。如果神经网络仅仅在训练集合上表现好（好比“窝里横”），而在应对其他新情况表现不佳，就表明陷入“过拟合（Overfitting）”状态，其实就是泛化能力差。\n经过交叉验证，隐含节点dropout率等于0.5的时候效果最好，原因是0.5的时候dropout随机生成的网络结构最多。\n4、神经网络中的优化器有哪些？常用的优化器你是如何进行选择的？\n二面30min：\n1、介绍简历上的项目\n2、常用的机器学习算法用过哪些？介绍lr的一个原理\n3、手写一个二叉排序树的建立过程，写完后拍照发微信\n4、点击率预估模型了解过哪些？\nhr面：\n1、自我介绍\n2、你对工作地点的偏好？\n3、工作内容的偏好？\n4、反问：拼多多的新人培养和晋升机制是什么？\n\n9.15笔试，10.30面试，这波操作666哈哈哈，不过面试体验还不错，聊的也蛮开心。\n一面：\n1、简单聊了下简历\n2、说一下deepfm模型的结构，与wide &amp; deep相比，优点在哪里？\n3、说一下fm和lr的区别，fm相对于lr有什么优点\n4、过拟合的解决方式有哪些，l1和l2正则化都有哪些不同，各自有什么优缺点\n5、一个字符串假设为ABCDEF，传入一个字典，代表子串的权重，比如A是5，ABCD是100，有的子串不在字典中，权重为0，求使得子串权重和最大的字符串分割方式。\n二面：\n二面跟我的方向完全不同，所以也没有聊太多的理论性的东西，代码题也没有考。主要聊了一下简历上的项目，同时提出了几个业务问题，考察一下我个人对这个问题的思考。\n三面：\n1、聊了一下简历上的项目\n2、介绍一下XGBoost的原理、LR的损失函数\n3、简单介绍一下CNN和RNN的原理\n4、给你一个视频推荐的任务，你如何考虑采取的算法，该系统中最重要的点是什么\n5、给一个字符串，返回最长数字子串的长度\n6、一张扑克牌54张，抽两张，一红一黑的概率\nhr面：\n1、手里的offer\n2、如何考虑手中的offer\n3、对于爱奇艺，有怎样的认识和顾虑\n\n用了同学的白金内推码，所以直接进入了面试，全程都在写题！机器学习的问题非常少！\n一面：\n1、介绍项目\n2、强化学习PG的推导\n3、强化学习DQN，DDQN，AC，DDPG的区别\n4、n个[0,n)的数，求每个数的出现次数（不能开辟额外空间）\n这里关键是看清楚题意，n个数，然后是左闭右开的区间，也就是说每个数都不会大于等于n，那么思路就来了：如果我们给一个索引下的数不管加上多少个n，那么这个数对n取余的话，我们就能知道这个数原来是多少；另一方面，如果一个数出现一次，我们就在对应索引位置下的数加上n，那么每个数对应索引位置上的数对n取商的话，就是这个数出现的次数。这样就做到了没有开辟额外的空间。代码现场直接略过了。\n5、K个有序数组，找一个长度最小的区间，在这个区间里至少包含每个数组各一个数。\n分析：初始化带下为K的最小堆，K个数字是每个数组中的最小值，设置变量max记录k个数字中的最大值，删除堆顶元素，将原堆顶元素对应的数组中下一个元素加入到堆中，调整堆，并且记录当前区间范围为（max-min），重复执行直到某个数组所有值都被删除。\npackage ByteDance;/*给定K个有序数组，求一个最小长度的区间【s,t】，使得每个数组中最少有一个元素在这个区间内。如果有多个长度相等的区间满足条件，则选择起始点s最小的那一个。 */class HeapNode&#123;    public int value;    public int arrNum;    public int index;    public HeapNode(int value,int arrNum,int index)&#123;        this.value = value;        this.arrNum = arrNum;        this.index = index;    &#125;&#125;public class minScope &#123;    public void modifyHeap(HeapNode[] heap,int index,int heapSize)&#123;        HeapNode temp = heap[index];        int child = index * 2 + 1;        while(child &lt; heapSize)&#123;            if(child + 1 &lt; heapSize &amp;&amp; heap[child + 1].value &lt; heap[child].value)                child = child + 1;            if(temp.value &gt; heap[child].value)&#123;                heap[index] = heap[child];                index = child;            &#125;            else                break;            child = 2 * index + 1;        &#125;        heap[index] = temp;    &#125;    public void getMinScope(int[][] matrix)&#123;        int heapSize = matrix.length;        HeapNode[] heap = new HeapNode[heapSize];        int max = Integer.MIN_VALUE;        for(int i=0;i&lt;heapSize;i++)&#123;            heap[i] = new HeapNode(matrix[i][0],i,0);            max = Math.max(heap[i].value,max);        &#125;        for(int i=heapSize / 2 - 1;i&gt;=0;i--)&#123;            modifyHeap(heap,i,heapSize);        &#125;        int min = heap[0].value;        int res = max - min;        int tempMax = max;        int tempMin = min;        while(heap[0].index &lt; matrix[heap[0].arrNum].length)&#123;            if(heap[0].index == matrix[heap[0].arrNum].length-1)&#123;                System.out.println(&quot;最小范围为：&quot; + tempMin + &quot;:&quot; + tempMax);                break;            &#125;            heap[0].value = matrix[heap[0].arrNum][++heap[0].index];            if(max&lt;heap[0].value)                max = heap[0].value;            modifyHeap(heap,0,heapSize);            min = heap[0].value;            if(max - min &lt; res)&#123;                res = max - min;                tempMax = max;                tempMin = min;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        int[][] martix = new int[][]&#123;&#123;1,3,5&#125;,&#123;4,8&#125;,&#123;2,5&#125;&#125;;        new minScope().getMinScope(martix);    &#125;&#125;\n二面\n1、介绍DQN的项目\n2、数组的全排列（空间复杂度O（1））\n数组中有重复元素，所以我们需要一个Set保存已经出现过的排列。因此我先写了一个回溯的方法，可是空间复杂度比较高，面试官说能不能用O（1）的空间复杂度，全排列直接print出来就行。即我们不需要保存已经出现过什么排列。这需要对数组先进性排序：\nclass Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();        if(nums==null || nums.length==0) return res;        boolean[] used = new boolean[nums.length];        Arrays.sort(nums);        backtracking(nums,used,new ArrayList&lt;Integer&gt;(),res);        return res;    &#125;        public static void backtracking(int[] nums,boolean[] used,ArrayList&lt;Integer&gt; arr,List&lt;List&lt;Integer&gt;&gt; res)&#123;        if(arr.size() == nums.length)            res.add(new ArrayList&lt;Integer&gt;(arr));        else&#123;            for(int i=0;i&lt;nums.length;i++)&#123;                if(used[i]) continue;                if(i&gt;0 &amp;&amp; nums[i-1]==nums[i] &amp;&amp; used[i-1]) continue;                used[i] = true;                arr.add(nums[i]);                backtracking(nums,used,arr,res);                arr.remove(arr.size()-1);                used[i] = false;            &#125;        &#125;    &#125;&#125;\n3、两堆钞票，尽可能均分（利用背包问题的思想）\n想了半天，写出来一个深度优先搜索的算法。面试官提示我可以考虑从背包问题的角度出发，但最后也没想出来。\n背包问题的思路，参考我们之前写过的文章：https://www.jianshu.com/p/25f4a183ede5\npackage ByteDance;public class Package &#123;    private final int MIN = Integer.MIN_VALUE;    public void test() &#123;        int[] w = &#123;3, 2, 2&#125;;        int[] v = &#123;5, 10, 20&#125;;        knapsackOptimal(5, w, v);    &#125;    /**     * 01背包-容量压缩     *     * @param c      包容量     * @param weight 各物品质量     * @param value  各物品价值     */    public void knapsackOptimal(int c, int[] weight, int[] value) &#123;        int n = weight.length; //物品数量        int[] w = new int[n + 1];        int[] v = new int[n + 1];        int[][] G = new int[n + 1][c + 1];        for (int i = 1; i &lt; n + 1; i++) &#123;            w[i] = weight[i - 1];            v[i] = value[i - 1];        &#125;        //初始化values[0...c]=0————在不超过背包容量的情况下，最多能获得多少价值        //原因：如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了        int[] values = new int[c + 1];        //初始化values[0]=0，其它全为负无穷————解决在恰好装满背包的情况下，最多能获得多少价值的问题        //原因：只有容量为0的背包可以什么物品都不装就能装满，此时价值为0，其它容量背包均无合法的解，属于未定义的状态，应该被赋值为负无穷        /*for (int i = 1; i &lt; values.length; i++) &#123;            values[i] = MIN;        &#125;*/        for (int i = 1; i &lt; n + 1; i++) &#123;            for (int t = c; t &gt;= w[i]; t--) &#123;                if (values[t] &lt; values[t - w[i]] + v[i]) &#123;                    values[t] = values[t - w[i]] + v[i];                    G[i][t] = 1;                &#125;            &#125;        &#125;        System.out.println(&quot;最大价值为： &quot; + values[c]);        System.out.print(&quot;装入背包的物品编号为： &quot;);        /*        输出顺序:逆序输出物品编号        注意：这里另外开辟数组G[i][v],标记上一个状态的位置        G[i][v] = 1:表示物品i放入背包了，上一状态为G[i - 1][v - w[i]]        G[i][v] = 0:表示物品i没有放入背包，上一状态为G[i - 1][v]        */        int i = n;        int j = c;        while (i &gt; 0) &#123;            if (G[i][j] == 1) &#123;                System.out.print(i + &quot; &quot;);                j -= w[i];            &#125;            i--;        &#125;    &#125;&#125;\n三面：\n1、无向无环图中，最短路径的最大值（O(n^3)的解法)\n这里考察的其实就是Floyd算法。哎，只可惜自己当时没有复习图的相关算法，完全不会写呀。\n算法思想原理：Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。\n从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。\npublic class Floyd &#123;        int[][] Matrix;    char[]  Nodes;        private final int INF = Integer.MAX_VALUE;        public Floyd(char[] Nodes, int[][] Matrix)&#123;        this.Nodes = Nodes;        this.Matrix = Matrix;    &#125;        public void floyd()&#123;                int[][] distance = new int[Nodes.length][Nodes.length];                // 初始化距离矩阵        for(int i=0; i&lt;Nodes.length; i++)&#123;            for(int j=0; j&lt;Nodes.length; j++)&#123;                distance[i][j] = Matrix[i][j];            &#125;        &#125;                //循环更新矩阵的值        for(int k=0; k&lt;Nodes.length; k++)&#123;            for(int i=0; i&lt;Nodes.length; i++)&#123;                for(int j=0; j&lt;Nodes.length; j++)&#123;                    int temp = (distance[i][k] == INF || distance[k][j] == INF) ? INF : distance[i][k] + distance[k][j];                    if(distance[i][j] &gt; temp)&#123;                        distance[i][j] = temp;                    &#125;                &#125;            &#125;        &#125;                // 打印floyd最短路径的结果        System.out.printf(&quot;floyd: \\n&quot;);        for (int i = 0; i &lt; Nodes.length; i++) &#123;            for (int j = 0; j &lt; Nodes.length; j++)                System.out.printf(&quot;%12d  &quot;, distance[i][j]);            System.out.printf(&quot;\\n&quot;);        &#125;    &#125;\n2、LSTM的公式\n3、RNN为什么出现梯度消失\n4、BPTT的推导。\n\n下面推荐一些资料帮你更好的进行复习吧：\n1、《统计机器学习》经典中的经典，建议至少读两遍！\n2、《百面机器学习》对一些面试常见问题进行了总结和梳理\n3、深度学习500问：https://github.com/scutan90/DeepLearning-500-questions/\n4、SVM：http://blog.pluskid.org/?page_id=683\n5、李宏毅深度学习课：https://www.bilibili.com/video/av9770302?from=search&amp;seid=9066694202064136038\n6、李宏毅强化学习课：https://www.bilibili.com/video/av24724071?from=search&amp;seid=11841282802558935758\n7、李宏毅机器学习课：https://www.bilibili.com/video/av35932863?from=search&amp;seid=7464664329294734466\n8、线性代数的本质：https://www.bilibili.com/video/av44855426?from=search&amp;seid=15873340646320697328\n作者：文哥的学习日记链接：https://www.jianshu.com/p/dd5ad361c3f5来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n面试\n我在去年校招参加了十几家公司的面试，收获了10个左右的offer，总体感觉是：公司对于算法工程师的要求越来越高。面试主要考察的点有以下几个方面：\n1、实习、论文、比赛：面试官一般会让你先进行自我介绍，然后会根据你简历上写的实习经历、论文、比赛经历进行展开。所以简历上的东西一定要是你亲身经历过的，可以按照STAR法则进行讲解。在这过程中，面试官会从算法理解、业务理解等多个方面考察你。\n2、深度学习/机器学习基础：在聊完简历项目之后，往往会考察一些算法的基础。常考的是过拟合的解决、正则项、boosting模型等等，这一块需要你对深度学习/机器学习基础有所了解，同时对常见的模型有深入的认识和理解。对于简单的公式也需要理解和掌握推导(LR、普通神经网络反向传播、RNN和LSTM的前向传播、SVM、XGBoost等等）。\n3、手撕代码：手撕代码题各公司的难度不一样，不过一般leetcode的中等难度的题就可以。小编建议，大家一定要把数组、链表、二叉树和动态规划的题目掌握好。\n4、智力题：常考的就是概率计算问题。\n5、业务理解：这一块小编觉得是非常难的，一般会给你一个场景，让你设计一套算法流程，或者问你对于当前你的项目，后续的工作方向等等。\n6、其他：其他的面试官可能会考察一些工程上的问题如多进程、多线程等、spark／hive等等。\n作者：文哥的学习日记链接：https://www.jianshu.com/p/dd5ad361c3f5来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n\n1、常见的机器学习优化器\n1.1 gradient descent\n1.1.1 全量梯度下降(Batch gradient descent)\n每次使用全量的训练集样本来更新模型参数，即θ=θ−η⋅∇θJ(θ)。\n优点:每次更新都会朝着正确的方向进行，最后能够保证收敛于极值点(凸函数收敛于全局极值点，非凸函数可能会收敛于局部极值点)，\n缺点:在于每次学习时间过长，并且如果训练集很大以至于需要消耗大量的内存，并且全量梯度下降不能进行在线模型参数更新。\n1.1.2 随机梯度下降(Stochastic gradient descent)\n随机梯度下降算法每次从训练集中随机选择一个样本来进行学习，即:θ=θ−η⋅∇θJ(θ;xi;yi)\n优点：随机梯度下降算法每次只随机选择一个样本来更新模型参数，因此每次的学习是非常快速的，并且可以进行在线更新。\n缺点：每次更新可能并不会按照正确的方向进行，因此可以带来优化波动，不过从另一个方面来看，随机梯度下降所带来的波动有个好处就是，对于类似盆地区域（即很多局部极小值点）那么这个波动的特点可能会使得优化的方向从当前的局部极小值点跳到另一个更好的局部极小值点，这样便可能对于非凸函数，最终收敛于一个较好的局部极值点，甚至全局极值点。 由于波动，因此会使得迭代次数增多，即收敛速度变慢。\n1.1.3 小批量梯度下降(Mini-batch gradient descent)\nMini-batch梯度下降综合了batch梯度下降与stochastic梯度下降，在每次更新速度与更新次数中间取得一个平衡，其每次更新从训练集中随机选择m,m&lt;&lt;n\n个样本进行学习，即：\nθ=θ−η⋅∇θJ(θ;xi:i+m;yi:i+m)\n优点： 相对于随机梯度下降，Mini-batch梯度下降降低了收敛波动性，即降低了参数更新的方差，使得更新更加稳定。相对于全量梯度下降，其提高了每次学习的速度。并且其不用担心内存瓶颈从而可以利用矩阵运算进行高效计算。\n1.1.4 梯度下降法的问题和挑战\n学习率设定：学习率的设定带来的挑战有三方面。首先，选择一个合理的学习率很难，如果学习速率过小，则会导致收敛速度很慢。如果学习速率过大，那么其会阻碍收敛，即在极值点附近会振荡。其次，学习速率调整很难，我们一般使用某种事先设定的策略或者在每次迭代中衰减一个较小的阈值。无论哪种调整方法，都需要事先进行固定设置，这边便无法自适应每次学习的数据集特点。最后，模型所有的参数每次更新都是使用相同的学习速率。如果数据特征是稀疏的或者每个特征有着不同的取值统计特征与空间，那么便不能在每次更新中每个参数使用相同的学习速率，那些很少出现的特征应该使用一个相对较大的学习速率。\n局部极小和鞍点：对于非凸目标函数，容易陷入那些次优的局部极值点或者鞍点中。\n1.2 Momentum\n如果在峡谷地区(某些方向较另一些方向上陡峭得多，常见于局部极值点)，SGD会在这些地方附近振荡，从而导致收敛速度慢。这种情况下，动量(Momentum)便可以解决。动量在参数更新项中加上一次更新量(即动量项,相当于指数加权平均),即：\nνt=γνt−1+η ∇θJ(θ)\nθ=θ−νt\n其作用如下图所示：\n\n没有动量\n\n有动量\n优点：对方向一致的参数能够加速学习，对梯度改变方向的参数能够减少其更新，因此就是momentum能够在相关方向上加速学习，抑制振荡，从而加速收敛。\n缺点：比较难学习一个较好的学习率。\n1.3 Adagrad\n在前面介绍的算法中，每个模型参数θi使用相同的学习速率η，而Adagrad在每一个更新步骤中对于每一个模型参数θi使用不同的学习速率ηi。其更新方程为：\n\n其中，Gt∈Rd×d是一个对角矩阵，其中第i行的对角元素eii为过去到当前第i个参数θi的梯度的平方和，epsilon是一个平滑参数，为了使得分母不为0。\n进一步，将所有Gt,ii,gt,i的元素写成向量Gt,gt,这样便可以使用向量点乘操作：\n\n优点：在于它能够为每个参数自适应不同的学习速率，而一般的人工都是设定为0.01。\n缺点：在于需要计算参数梯度序列平方和，并且学习速率趋势是不断衰减最终达到一个非常小的值。\n1.4 RMSprop\n为了降低Adagrad中学习速率衰减过快的问题，RMSprop使用指数加权平均来代替历史梯度的平方和：\n\nRmsprop的的效果如下图所示，对梯度较大的方向减小其学习速率，相反的，在梯度较小的方向上增加其学习速率。\n\n优点：RMSprop改进了Adagrad学习速率衰减过快的问题，同时其适用于处理非平稳。\n缺点：依然依赖一个全局学习率。\n1.5 Adam\nAdam 算法结合了 Momentum 和 RMSprop 梯度下降法，并且是一种极其常\n用的学习算法，被证明能有效适用于不同神经网络，适用于广泛的结构。其计算方式如下：\n\n上式中使用的是经过偏差修正后的指数加权平均数：\n\n\n2、常见的过拟合解决方法\n2.1 L1和L2正则化\nL1和L2正则化来避免过拟合是大家都知道的事情，而且我们都知道L1正则化可以得到稀疏解，L2正则化可以得到平滑解，这是为什么呢？有几种解释吧，可以参考文献8（https://blog.csdn.net/f156207495/article/details/82794151） 。主要有几个方面：\n1)直观的从图像上观察结论\n2)通过对梯度的求解进行解释\n3)通过L1正则和L2正则假设的参数先验上进行解释。\n2.2 数据增强\n通俗得讲，数据增强即需要得到更多的符合要求的数据，即和已有的数据是独立同分布的，或者近似独立同分布的。一般有以下方法：\n1)从数据源头采集更多数据\n2)复制原有数据并加上随机噪声\n3)重采样\n4)根据当前数据集估计数据分布参数，使用该分布产生更多数据等\n2.3 Early stopping\nEarly stopping便是一种迭代次数截断的方法来防止过拟合的方法，即在模型对训练数据集迭代收敛之前停止迭代来防止过拟合。\nEarly stopping可以得到与L2类似的参数平滑效果，可以通过定性和定量两个方面进行分析，具体参考文献10:http://www.friskit.me/2017/03/27/l2-equals-to-stop-early/\n2.4 dropout\ndropout是指在深度学习网络的训练过程中，对于神经网络单元，按照一定的概率将其暂时从网络中丢弃。dropout为什么能防止过拟合，可以通过以下几个方面来解释：\n\n它强迫一个神经单元，和随机挑选出来的其他神经单元共同工作，达到好的效果。消除减弱了神经元节点间的联合适应性，增强了泛化能力。\n类似于bagging的集成效果\n对于每一个dropout后的网络，进行训练时，相当于做了Data Augmentation，因为，总可以找到一个样本，使得在原始的网络上也能达到dropout单元后的效果。 比如，对于某一层，dropout一些单元后，形成的结果是(1.5,0,2.5,0,1,2,0)，其中0是被drop的单元，那么总能找到一个样本，使得结果也是如此。这样，每一次dropout其实都相当于增加了样本。\n\n2.5 交叉验证\n交叉验证的基本思想就是将原始数据（dataset）进行分组，一部分做为训练集来训练模型，另一部分做为测试集来评价模型。我们常用的交叉验证方法有简单交叉验证、S折交叉验证和留一交叉验证。\n2.6 决策树剪枝\n在决策树学习中将已生成的树进行简化的过程称为剪枝。又分为前剪枝和后剪枝，这里我们就不细细介绍了。\n3、CTR预估 &amp; 推荐系统\n3.1 FM的原理及化简\nFM的计算公式如下：\n\n化简过程如下：\n\n求导结果如下：\n\n3.2 FFM的原理\n在FFM中，每一维特征 xi，针对其它特征的每一种field fj，都会学习一个隐向量 vi,fj。因此，隐向量不仅与特征相关，也与field相关。\n假设样本的 n个特征属于f个field，那么FFM的二次项有 nf个隐向量。而在FM模型中，每一维特征的隐向量只有一个。FM可以看作FFM的特例，是把所有特征都归属到一个field时的FFM模型。根据FFM的field敏感特性，可以导出其模型方程。\n\n可以看到，如果隐向量的长度为 k，那么FFM的二次参数有 nfk 个，远多于FM模型的 nk个。此外，由于隐向量与field相关，FFM二次项并不能够化简，其预测复杂度是 O(kn2)。\nFFM将问题定义为分类问题，使用的是logistic loss，同时加入了正则项(这里是分类类别为-1和1时候的log loss)\n\n3.3 wide &amp; deep的原理\nwide &amp; deep的结构如下：\n\nWide Part\nWide Part其实是一个广义的线性模型，使用特征包括\nraw input(原始特征)和cross-product transformation(组合特征)\nDeep Part\n\nDeep Part通过学习一个低纬度的dense representation（也叫做embedding vector）对于每一个query和item，来泛化给你推荐一些字符上看起来不那么相关，但是你可能也是需要的。比如说：你想要炸鸡，Embedding Space中，炸鸡和汉堡很接近，所以也会给你推荐汉堡。\nEmbedding vectors被随机初始化，并根据最终的loss来反向训练更新。这些低维度的dense embedding vectors被作为第一个隐藏层的输入。隐藏层的激活函数通常使用ReLU。\n模型的训练\n模型的最终输出为：\n\n通过联合训练方式进行训练。之前面试问到两个部分是否可以用不同的优化器，论文中给出的是：Wide组件是用FTRL（Follow-the-regularized-leader） + L1正则化学习。Deep组件是用AdaGrad来学习。\n3.4 DeepFM的原理\n先来看一下DeepFM的模型结构：\n\nDeepFM包含两部分：神经网络部分与因子分解机部分，分别负责低阶特征的提取和高阶特征的提取。这两部分共享同样的输入。DeepFM的预测结果可以写为：\n\nFM部分\nFM部分的详细结构如下：\n\nFM的输出公式为：\n\n深度部分\n\n深度部分是一个前馈神经网络。与图像或者语音这类输入不同，图像语音的输入一般是连续而且密集的，然而用于CTR的输入一般是及其稀疏的。因此需要重新设计网络结构。具体实现中为，在第一层隐含层之前，引入一个嵌入层来完成将输入向量压缩到低维稠密向量。\n\n嵌入层(embedding layer)的结构如上图所示。当前网络结构有两个有趣的特性，1）尽管不同field的输入长度不同，但是embedding之后向量的长度均为K。2)在FM里得到的隐变量Vik现在作为了嵌入层网络的权重。\n4、Batch Normalization\n4.1 为什么要做BN\n我们首先来思考一个问题，为什么神经网络需要对输入做标准化处理？原因在于神经网络本身就是为了学习数据的分布，如果训练集和测试集的分布不同，那么导致学习的神经网络泛化性能大大降低。同时，我们在使用mini-batch对神经网络进行训练时，不同的batch的数据的分布也有可能不同，那么网络就要在每次迭代都去学习适应不同的分布，这样将会大大降低网络的训练速度。因此我们需要对输入数据进行标准化处理。\n对于深度网络的训练是一个复杂的过程，只要网络的前面几层发生微小的改变，那么后面几层就会被累积放大下去。一旦网络某一层的输入数据的分布发生改变，那么这一层网络就需要去适应学习这个新的数据分布，所以如果训练过程中，训练数据的分布一直在发生变化，那么将会影响网络的训练速度。\n我们知道网络一旦train起来，那么参数就要发生更新，除了输入层的数据外(因为输入层数据，我们已经人为的为每个样本归一化)，后面网络每一层的输入数据分布是一直在发生变化的，因为在训练的时候，前面层训练参数的更新将导致后面层输入数据分布的变化。我们把网络中间层在训练过程中，数据分布的改变称之为：Internal Covariate Shift。为了解决Internal Covariate Shift，便有了Batch Normalization的诞生。\n4.2 如何做BN(训练和预测)\n训练阶段\n训练阶段对每一层，BN的计算过程如下：\n\n可以看到，在BN的计算过程中，不仅仅有标准化的操作，还有最后一步，被称为变换重构。为什么要增加这一步呢？其实如果是仅仅使用上面的归一化公式，对网络某一层A的输出数据做归一化，然后送入网络下一层B，这样是会影响到本层网络A所学习到的特征的。打个比方，比如我网络中间某一层学习到特征数据本身就分布在S型激活函数的两侧，你强制把它给我归一化处理、标准差也限制在了1，把数据变换成分布于s函数的中间部分，这样就相当于我这一层网络所学习到的特征分布被你搞坏了。于是我们增加了变换重构，保留了网络所学习到的特征。\n预测阶段\n一个网络一旦训练完了，就没有了min-batch这个概念了。测试阶段我们一般只输入一个测试样本，看看结果而已。因此测试样本，前向传导的时候，上面的均值u、标准差σ 要哪里来？其实网络一旦训练完毕，参数都是固定的，这个时候即使是每批训练样本进入网络，那么BN层计算的均值u、和标准差都是固定不变的。\n因此在预测阶段，对于均值来说直接计算所有训练batch u值的平均值；然后对于标准偏差采用训练阶段每个batch σB的无偏估计，过程如下：\nj\n\n5、集成学习\n5.1 Bagging\nBagging即套袋法，其算法过程如下：\n1、从原始样本集中抽取训练集.每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）.共进行k轮抽取，得到k个训练集.（k个训练集相互独立）\n2、每次使用一个训练集得到一个模型，k个训练集共得到k个模型.（注：根据具体问题采用不同的分类或回归方法，如决策树、神经网络等）\n3、对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果.\n5.2 Boosting\nBoosting是一族可将弱学习器提升为强学习器的算法。关于Boosting的两个核心问题：\n1、在每一轮如何改变训练数据的权值或概率分布？\n通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样本的权值，而误分的样本在后续受到更多的关注.\n2、通过什么方式来组合弱分类器？\n通过加法模型将弱分类器进行线性组合，比如AdaBoost通过加权多数表决的方式，即增大错误率小的分类器的权值，同时减小错误率较大的分类器的权值。而提升树通过拟合残差的方式逐步减小残差，将每一步生成的模型叠加得到最终模型。\n5.3 Bagging和Boosting的方差-偏差分析\n我们都知道，Bagging主要降低的是模型的方差，而Boosting主要减小的是模型的偏差，这是为什么呢？\n这里我们主要引用参考文献13中的解释：\n\n5.4 Stacking\nstacking 就是当用初始训练数据学习出若干个基学习器后，将这几个学习器的预测结果作为新的训练集，来学习一个新的学习器。\n\n在stacking的模型训练阶段，二级模型的训练集是使用一级模型产生的，如果直接使用一级模型对初始的训练集样本进行预测来产生二级模型的训练集，这样会有极大的过拟合的风险，因此一般是用训练一级模型未使用的样本来产生二级模型的训练集，交叉验证方法是比较常用的方法。\nStacking的二级模型的训练样本的shape应该是训练集长度 * 基分类器个数，因此对于每个一级模型来说的，通过下面的图示来产生部分该模型对应的部分，最后进行横向拼接：\n\n而对于二级模型的测试集来说，由于每次交叉验证的过程中都要进行一次预测，假设我们是5折交叉验证，那么对于每个一级模型来说，得到的shape是测试集行数 * 交叉验证折数，此时的做法是，对axis=1方向取平均值，以得到测试集行数 * 1 的测试数据，最后将每个一级模型的结果进行横向拼接，得到二级模型的测试样本的shape是测试集行数 * 基分类器个数，可以跟训练集保持一致：\n\n6、梯度消失、爆炸及解决方案\n想必大家对梯度消失和梯度爆炸的概念都很了解了，这里我们只谈一谈如何避免梯度消失和爆炸。\n6.1 预训练加微调\n该方案的基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，此过程就是逐层“预训练”（pre-training）；在预训练完成后，再对整个网络进行“微调”（fine-tunning）。此思想相当于是先寻找局部最优，然后整合起来寻找全局最优，此方法有一定的好处，但是目前应用的不是很多了。\n6.2 梯度裁切\n梯度剪切这个方案主要是针对梯度爆炸提出的，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。\n6.3 正则化\n正则化在一定程度上也可以避免梯度爆炸的问题，比较常见的是l1\n正则和l2正则。\n6.4 relu、leakrelu、elu等激活函数\nrelu\nrelu的数学表达式为f(x) = max(0, x)，图像如下：\n\n我们可以很容易看出，relu函数的导数在正数部分是恒等于1的，因此在深层网络中使用relu激活函数就不会导致梯度消失和爆炸的问题。但由于负数部分恒为0，会导致一些神经元无法激活。\nleak relu\nleakrelu就是为了解决relu的0区间带来的影响，其数学表达为：f(x)=max(k∗x,x)。其中k是leak系数，一般选择0.01或者0.02，或者通过学习而来，其图像如下：\n\nelu\nelu激活函数也是为了解决relu的0区间带来的影响，其表达式为：\n\n其图像如下：\n\n6.5 batch normalization\n有关batch normalization内容，可以参考本文的第四部分。多说一句，我们可以理解BN将输出从饱和区拉倒了非饱和区。 尤其在使用sigmoid激活函数或者tanh激活函数时，这个作用更加明显。\n6.6 残差结构\n在一定深度下，深层网络的训练误差大于浅层网络的训练误差，我们称之为网络退化问题。而残差结构有效的解决了这个问题，使得深层网络的训练效果好于浅层网络。\nResNet中的残差块如下图所示：\n\n我们可以看出此时将A网络的输出误差应该与B网络相同（暂时不考虑网络中的维度大小的细节），因为残差块的输出为F(x) + x,如果将网络中的参数置为0，则F(x)=0,因此得到的输出为0+x=x。因此使用ResNet结构搭建的深度网络至少与浅层网络具有相同的拟合能力，不会出现之前的网络退化问题。\n6.7 LSTM\nLSTM主要解决的是循环神经网络中的梯度消失问题，传统RNN中为什么会出现梯度消失或爆炸，以及LSTM是如何解决的，参考文献14 和 15.\nRNN梯度消失和爆炸的原因：https://zhuanlan.zhihu.com/p/28687529\nLSTM如何解决梯度消失问题：https://zhuanlan.zhihu.com/p/28749444\n另外还有一个常见的问题就是，LSTM和RNN中为什么选择tanh作为激活函数，而非relu。可以参考文献16。\n参考文献\n1、梯度下降优化算法综述：https://blog.csdn.net/heyongluoyao8/article/details/52478715\n2、各优化算法的优缺点整理：https://blog.csdn.net/zhouhong0284/article/details/80232412\n3、详解机器学习中的梯度消失、爆炸原因及其解决方法：https://blog.csdn.net/qq_25737169/article/details/78847691\n4、深度学习（二十九）Batch Normalization 学习笔记：https://blog.csdn.net/hjimce/article/details/50866313\n5、基础 | batchnorm原理及代码详解：https://blog.csdn.net/qq_25737169/article/details/79048516\n6、BN论文：https://arxiv.org/abs/1502.03167\n7、ResNet学习笔记：https://zhuanlan.zhihu.com/p/32085715\n8、为什么L1稀疏，L2平滑？：：https://blog.csdn.net/f156207495/article/details/82794151\n9、l1 相比于 l2 为什么容易获得稀疏解？：https://www.zhihu.com/question/37096933\n10、http://www.friskit.me/2017/03/27/l2-equals-to-stop-early/：http://www.friskit.me/2017/03/27/l2-equals-to-stop-early/\n11、CNN中的dropout理解：https://blog.csdn.net/dod_jdi/article/details/78379781\n12、整理一份万字机器学习资料！：https://www.jianshu.com/p/70e04c02985c\n13、bagging与boosting两种集成模型的偏差bias以及方差variance 的理解：https://blog.csdn.net/shenxiaoming77/article/details/53894973\n14、RNN梯度消失和爆炸的原因：https://zhuanlan.zhihu.com/p/28687529\n15、LSTM如何解决梯度消失问题：https://zhuanlan.zhihu.com/p/28749444\n16、RNN中为什么要采用tanh而不是ReLu作为激活函数？：https://www.zhihu.com/question/61265076\n17、ResNet学习笔记：https://zhuanlan.zhihu.com/p/32085715\n2012年ImageNet比赛的获胜模型AlexNet论文中提出的避免过拟合的方法。其操作方法如下图所示。\n\n\n\n在训练中以概率P(一般为50%)关掉一部分神经元，如图中的虚线的箭头。那么对于某些输出，并不是所有神经元会参与到前向和反向传播中。\n在预测的时候，将使用所有的神经元，但是会将其输出乘以0.5\n\n\n\n​     Dropout的意义在于，减小了不同神经元的依赖度。有些中间输出，在给定的训练集上，可能发生只依赖某些神经元的情况，这就会造成对训练集的过拟合。而随机关掉一些神经元，可以让更多神经元参与到最终的输出当中。我觉得dropout方法也可以看成，联合很多规模比较小的网络的预测结果，去获取最终的预测。\nbatchnormalization的推理过程：\n\n\n\n深度哈希的进一步优化： 多层索引：\n\n\n\n\n\n这种编码方式有以下优势：减少查询下发次数，之前多个倒排表的查询必然需要下发多次查询，这样将会带来多余的查询解释以及不必要的时间开销，将每一段加上一个段序号后可以保证检索的准确性的同时，只用下发一次查询；同时该种检索策略还能方便后续的命中段数统数，现有的检索框架支持多关键字的查询，以及命中关键字个数的统计功能，所以本研究中拟采用此种方式进行实验。\n回答：\n1）归一化；2）kmeans（加速）；3）计算当前样本距离每个中心点的距离；4）求最近的中心店，进行归类。\nkmeans的k值如何选取；\n\n轮廓系数：\n轮廓系数（Silhouette Coefficient）结合了聚类的凝聚度（Cohesion）和分离度（Separation），用于评估聚类的效果。该值处于-1~1之间，值越大，表示聚类效果越好。具体计算方法如下：\n\n对于每个样本点i，计算点i与其同一个簇内的所有其他元素距离的平均值，记作a(i)，用于量化簇内的凝聚度。\n选取i外的一个簇b，计算i与b中所有点的平均距离，遍历所有其他簇，找到最近的这个平均距离,记作b(i)，即为i的邻居类，用于量化簇之间分离度。\n对于样本点i，轮廓系数s(i) = (b(i) – a(i))/max{a(i),b(i)}\n计算所有i的轮廓系数，求出平均值即为当前聚类的整体轮廓系数，度量数据聚类的紧密程度\n\n从上面的公式，不难发现若s(i)小于0，说明i与其簇内元素的平均距离小于最近的其他簇，表示聚类效果不好。如果a(i)趋于0，或者b(i)足够大，即a(i)&lt;&lt;b(i)，那么s(i)趋近与1，说明聚类效果比较好。\n\n2、如何生成一个随机点在圆内；\n3、给定一个随机数发生器在0~7之间，如何生成0~10之间的随机数；\n代码：\n两数之和；\n三数之和；\n四数之和。\n希望还有后期面试吧，最后祝愿大家都能拿到心仪的offer，加油~\n作者：Ariana0402\nhttps://www.nowcoder.com/discuss/178148来源：牛客网\n1、亿级文件，每一行是一个字符串，单个文件中，字符串没有重复，两个文件中取交集。露珠真不会，引导下说了hash的原理等。 \n\n2、亿级用户推荐视频。 \n\n3、高维稀疏的特征怎么处理。答降维。问会不会embedding，说听过word2wec里面解决词向量，但是具体不会。 \n\n4、xgboost什么的深入问了下。 \n\n5、代码题，很简单但露珠说了二分，代码写了很久，我真的好渣啊T,T。反转数组求最小。\n\n作者：919323\nhttps://www.nowcoder.com/discuss/178148来源：牛客网\n发表于 2019-04-14 22:07:49[回复(3)](javascript:void(0);)[赞(1)](javascript:void(0);)[分享](javascript:void(0);)[举报](javascript:void(0);)\nAriana0402  [](javascript:void(0);)：\n我答得也不全面。我答了1、xgb用二阶泰勒展开近似损失，gbdt用一阶泰勒展开近似损失。所以xgb更准确。2、xgb加入了正则项，加入了叶子结点数目及叶子结点取值的平方到损失函数里。3、xgb支持并行操作，这里的并行不是指树和树之间并行而是指挑选特征时的并行，xgb利用block思想，将每个特征的取值分成block形成候选分裂点，这一步可以在建树之前做，所以计算特征分裂点的时候是可以并列进行的。你可以再查查我答的也不全面。\n作者：越越保佑我\nhttps://www.nowcoder.com/discuss/128702来源：牛客网\n常用分类算法\nsvm\nlr\n调参一般调试哪些参数\n牛顿法 拟牛顿法\nlinux命令\n你遇到过最困难的事情是什么，怎么解决的\n除了ai 你了解哪些现在热门方向以及实现原理\n工作地点选择\n链表是否有环（手撕代码）\n平常怎么学习\n百度笔试题 普通箱和怪物箱\n作者：在路上91\nhttps://www.nowcoder.com/discuss/121706来源：牛客网\n2.面试官想让我手写svm推导，我问她是不是推到SMO算法之前就行了，然后说看样子很懂，那我们就不写了 \n\n3.手撕代码两个链表分别表示两个数，头指针为低位尾指针为高位，求和返回新链表 \n\n4.智力题.给两个砝码7g和2g，有140g盐，分成50g和90g两堆盐，天平用三次分出这两堆来 \n\n5.问我想做什么方向，我说推荐系统，然后就问了解多少说 \n\n6.接下来就是聊工作地点，性格，优势，以及将来怎么工作\n\n作者：政化天下666\nhttps://www.nowcoder.com/discuss/102895来源：牛客网\n单模型\n1、LR的损失函数的公式和函数\n2、LR的推导过程\n3、LR如何解决共线性，为什么深度学习不强调\n4、LR如何防止过拟合\n5、LR分布式训练怎么做\n6、LR为什么使用Sigmoid\n7、SVM的损失函数\n8、SVM的推导过程\n9、SVM怎么扩展到多分类问题\n10、SVM需要解决的重要数学问题是什么\n11、LR和SVM的区别\n12、Gini系数、信息增益、信息增益率的公式\n13、CART回归和分类时节点如何划分的\n14、决策树将一个特征全部乘以2会有什么影响\n15、反向传播算法的推导\n16、贝叶斯原理\n17、L_BFGS，DFP推导\n18、K means算法，如何选择k的个数\n19、DBSCAN介绍\n20、GMM算法\n21、UBM-GMM模型\n集成学习\n1、Boosting 和Bagging的比较\n2、XGB的推导\n3、XGB为什么要用二阶信息不用一阶\n4、XGB的VC维\n5、LGB、XGB的区别和联系，并行是如何并行的\n6、GBDT的原理，以及常用的调参的参数\n7、XGB与GBDT的比较\n8、RF怎么进行节点划分\n9、GBDT和RF的比较\n10、Stacking方法\n特征工程\n1、如何判断特征的有效性\n2、特征选择的几种方法\n3、为什么要做数据归一化，在梯度下降时有什么好处\n评价指标\n1、评价指标及含义\n2、AUC理解和计算方法\n3、样本分布不均衡时，怎么训练怎么评价\n损失函数、优化函数、核函数\n1、各种核函数的比较与使用场景\n2、牛顿法的原理及求解sqrt https://leetcode.com/problems/sqrtx/\n3、SGD、Momentum和Adam的区别和联系\n4、GD和SGD等的区别\n5、各个损失函数的形式与区别\n6、交叉熵损失公式及推导\n7、偏差和方差的区别\n正则化、降维、过拟合\n1、L1和L2的区别与应用场景\n2、各个模型如何防止过拟合\n3、使得|x_1 - x*| + … + |x_n - x*|最小的x*\n4、SVD在遇到数据特别多的时候会产生一定的问题？如何解决？\n5、PCA的原理\n6、PCA与SVD之间区别和联系\n学习链接\nhttp://www.dscademy.com/supervised-learning/linear-regression/\nhttps://www.jianshu.com/p/70e04c02985c\n二、深度学习\nCNN相关\n1、各个CNN模型之间的比较，例如inception、VGG、Resnet等\n2、CNN的模型结构与原理\n3、Pooling的作用\n4、Dropout的理解\n5、BN原理及为什么可以工作\n6、Resnet的原理\n7、胶囊网络的原理\n8、Alphago的原理\n9、Data Augmetaion方法\n10、1X1卷积核的作用\nRNN相关\n1、LSTM的结构、原理及参数数量\n2、梯度消失原因，解决方法，为什么LSTM可以避免梯度消失\n3、GRU与LSTM的不同\n4、RNN模型的演变过程\n5、RNN中的正则化方法：AR以及TAR\n模型比较、训练\n1、深度学习中的过拟合，如何解决\n2、梯度消失梯度爆炸的原因及解决方法\n3、模型训练停止方法\n4、RNN和CNN的对比\n学习链接\nhttps://www.cnblogs.com/huanyi0723/p/8470866.html\n三、推荐算法\n1、FM模型的具体公式，FFM的改进\n2、个性化推荐的常用模型\n3、https://www.jianshu.com/p/99e8f24ec7df\n五、概率论\n1、如何衡量两个分布的相似度\n2、CRF推导\n3、统计中的P值和Alpha值\n4、常问问题：摸扑克牌、硬币、五福的期望等\n六、框架\n1、Hadoop，Hive，Spark相关理论\n2、Tensorflow的图计算模型\n3、with关键字\n4、模型保存的相关描述\n5、session是什么\n\nhttps://baijiahao.baidu.com/s?id=1621054167310242353&amp;wfr=spider&amp;for=pc\n作者：黑羽KID2015_560\nhttps://www.nowcoder.com/discuss/236329?type=2来源：牛客网\n列表去重\n字典排序\n列表的排序算法，归并排序的原理\n字符串去空格\nPython23的区别\nPython的内存管理机制，优缺点\nreadline和readlines的区别\n了解的正则表达式\n","tags":["面试"]},{"title":"面试概率题大杂烩","url":"/article/%E9%9D%A2%E8%AF%95%E6%A6%82%E7%8E%87%E9%A2%98%E5%A4%A7%E6%9D%82%E7%83%A9/","content":"\n\n从一副52张扑克牌中随机抽两种，颜色相等的概率\n\n$\\frac{C_{2}^{1} C_{13}^{2}}{C_{52}^2} = \\frac{40}{221}$\n\n\n\n\n\n54张牌，分成6份，每份9张牌，大小王在一起的概率\n\n$\\frac{C_6^1 C_2^2 C_{52}^{7} C_{45}^{9}C_{36}^{9}\\cdots C_{9}^{9}}{C_{54}^{9}C_{45}^{9}\\cdots C_{9}^{9}} = \\frac{8}{53}$\n\n\n\n\n52张牌去掉大小王，分成26*2两堆，从其中一堆取4张牌为4个a的概率\n\n\n直觉告诉我分不分堆没有关系，这样想的话，答案是：\n$\\frac{C_4^4}{C_{52}^{4}}$\n考虑分堆的话：\n1 先求分两堆，4张A出现在同一堆的概率： $ \\frac{C_2^1 C_4^4 C_{48}^{22} C_{26}^{26}}{C_{52}^{26}C_{26}^{26}}$\n2 在这两堆中，选中4张A同时出现的那一堆：$ \\frac{1}{2}\\frac{C_2^1 C_4^4 C_{48}^{22} C_{26}^{26}}{C_{52}^{26}C_{26}^{26}}$\n3 从选中的这堆中，选4张牌出来是A的概率：$ \\frac{1}{2}\\frac{C_2^1 C_4^4 C_{48}^{22} C_{26}^{26}}{C_{52}^{26}C_{26}^{26}} \\frac{C_{4}^{4}}{C_{26}^{4}}$\n\n\n一枚硬币，扔了一亿次都是正面朝上，再扔一次反面朝上的概率是多少？\n\n\n当出现1亿次都是正面朝上的时，有理由怀疑这个硬币两面都是正面。\n参考答案: https://www.zhihu.com/question/29683794\n\n\n有8个箱子，现在有一封信，这封信放在这8个箱子中（任意一个）的概率为4/5,不放的概率为1/5（比如忘记了）,现在我打开1号箱子发现是空的，求下面7个箱子中含有这封信的概率为？\n\n\n事件A：放信封事件\n事件B：1号为空\n$$\n\\begin{align}\np(A|B) &amp;= \\frac{p(AB)}{p(B)} \\&amp;= \\frac{p(B|A)p(A)}{p(B|A)p(A) + p(B|\\hat A)p(\\hat A)}\n\\end{align}\n$$\n\n\n已知N枚真硬币，M枚假硬币（两面都是国徽），取一枚硬币抛R次重复都是国徽，问该硬币是真硬币的概率？\n\n\n\n\n\n一对夫妻有2个孩子，求一个孩子是女孩的情况下，另一个孩子也是女孩的概率\n\n\n有两个孩子，那么所有的组合情况为：\np(男，女) = 1/4\np(男，男）= 1/4\np(男， 男) = 1/4\np(女，女) = 1/4\n1/3\n\n\n有种癌症，早期的治愈率为0.8，中期的治愈率为0.5，晚期的治愈率为0.2.若早期没治好就会转为中期，中期没治好就会变成晚期。现在有一个人被诊断为癌症早期，然后被治愈了，问他被误诊为癌症的概率是多少？\n\n\np(cur|早) = 0.8\np(cur|中) = 0.2 * 0.5 = 0.1\np(cur|晚) = 0.2 * 0.5 * 0.2 = 0.02\n\n\n\n某城市发生了一起汽车撞人逃跑事件，该城市只有两种颜色的车，蓝20%绿80%，事发时现场有一个目击者，他指证是蓝车，但是根据专家在现场分析，当时那种条件能看正确的可能性是80%，那么，肇事的车是蓝车的概率是多少？ https://www.nowcoder.com/discuss/65344\n\n\n\n100人坐飞机，第一个乘客在座位中随便选一个坐下，第100人正确坐到自己坐位的概率是？\n\n\n\n1/2\n\n\n一个国家重男轻女，只要生了女孩就继续生，直到生出男孩为止，问这个国家的男女比例？\n\n\n1/2\n\n\n\n有50个红球，50个蓝球，如何放入两个盒子中使得拿到红球的概率最大\n\n一个盒子中放一个红球，剩下的都放在另一个盒子中\n\n\n\n\n\n某个一直函数返回0/1，0的概率为p，写一函数返回两数概率相等。\n\n生成两次，当生成的数为01时返回第一个数，10时返回第二个数，11和00时不滚\n\n\n\n\n\n给你一个函数，这个函数是能得出1-5之间的随机数的，概率相同。现在求1-7之间随机函数，你如何做\n\n1 &lt; x &lt; 5\n1 &lt; ax+b &lt; 7\na + b = 1\n5a + b = 7\na = 3/2\nb = - 1/2\ny = (3x-1)/2\n\n\n\n\n\nX是一个以p的概率产生1,1-p的概率产生0的随机变量，利用X等概率生成1~n的数 https://www.nowcoder.com/discuss/75360 https://www.nowcoder.com/discuss/53916 https://www.nowcoder.com/discuss/47341 https://www.nowcoder.com/discuss/12393\n\n$pr(X=1) = p$\n$pr(X = 0) = 1-p$\n$C_{2n}^{n} &lt;= n$， 求出n，然后依次编码\n\n\n\n\n给你一个硬币，你如何获得2/3的概率\n\n\n这个其实还是比较容易想到的，把这枚硬币扔两次，以下情况出现的概率相等：\n\n正正\n正反\n反正\n反反\n\n所以如果出现第4种情况则相当于采样失败，继续实验，如果在1~3种情况中出现1~2的情况则是一个2323的概率\n\n\n\n扔硬币期望掷出‘正反正反……’的序列出来，倘若抛掷硬币没有任何技巧，每次是正是反的概率相同，那么无限地抛掷下去，第一次出错更有可能出在什么地方？\nA．该掷正面的时候掷出了反面\nB．该掷反面的时候掷出了正面\nC．上述两种情况的出现概率相同\n\n\n\n这个题目的答案是 A 。下面我们证明，因为该掷反面的时候掷出了正面而挂掉的概率，也就是在第偶数次抛掷时挂掉的概率，精确地等于 1/3 。容易得出，第 2 次就挂了的概率就是前 2 次精确地掷出“正正”序列的概率，它等于 1 / 22 。类似地，到第 4 次才挂的概率就是前 4 次精确地掷出“正反正正”序列的概率，它等于 1 / 24 ；而到第 6 次才挂的概率则是前 6 次精确地掷出“正反正反正正”序列的概率，它等于 1 / 26……所以，在第偶数次挂掉的概率是：\n$$\n\\begin{align}\n&amp;\t1 / 2^2 + 1 / 2^4 + 1 / 2^6 + 1 / 2^8 + … + 1/2^n \\\n= &amp; 1 / 4 + 1 / 4^2 + 1 / 4^3 + 1 / 4^4 + … + 1/4^{(n-1)} \\\n= &amp; (1 + 1 / 4 + 1 / 4^2 + 1 / 4^3 + 1 / 4^4 + … + 1/4^{(n-1)}) – 1 \\\n= &amp; 1 / (1 – 1 / 4) – 1 \\\n= &amp; 1 / 3 \\\n\\end{align}\n$$\n\n\n给定一个函数，它完全随机地产生[1,3]范围内的整数（即每个数的产生机率都是1/3）。用给定的函数去求一个完全随机产生[1,89]范围内的整数函数。注意，要求每个数的出现的概率都相同。\n\n\n已知一个函数random()，可以返回1到n是随机值，设法利用它他构造一个random2()，使得random2()可以返回1到m的随机值。使用笛卡尔积，构造$(n\\times n)$个随机元素，所以这些元素产生的概率都是1/$(n\\times n)$。\n当 m&lt;=$(n\\times n)$时，只需要略去($(n\\times n)$ % m)个元素，其余的元素总个数可以整除m，就构造了符合要求的random2()了；\n当 m &gt; $(n\\times n)$  时，可以考虑$(n\\times n \\times n)$来构造元素，然后略去($(n\\times n\\times n)$ % m)个元素，其余的元素总个数就可以整除m，那就构造了random2()了。\n例如，假设n=2，笛卡尔积就是 (1, 1)、(1, 2)、(2, 1)、(2, 2)，就得到$(2\\times 2)$个元素，并且出现这$(2\\times 2)$个元素出现的概率是相等的，都是1/4 。\n假设此时m=3， $(2\\times2)$ 不能 整除3，所以随便略去((2*2) % 3) (也就是 1 个) 个元素即可构造一个random2()函数。\n依此类推…\n\n\n\n随机数的生成算法，比如0~0.6的生成概率是0.7,0.6~1的生成概率是0.3，问怎么实现。 https://www.nowcoder.com/discuss/13322 https://www.nowcoder.com/discuss/36424\n\n随机的生成0-1的数，设这个数为x。\n当0&lt;x&lt;0.7时， 输出\t\t$\\frac{6x}{7}$\n当0.7&lt;x&lt;1时，输出 $\\frac{4x-1}{3}$\n\n\n\n网游中有个抽奖活动，抽中各星座的概率为10/200，20/200，。。。120/200.如何实现？ https://www.nowcoder.com/discuss/1658\n\n\n\n给一个概率分布均匀的随机数发生器，给一串float型的数，希望通过这个随机数发生器实现对这串数进行随机采样，要求是如果其中的某个数值越大，那么它被采样到的概率也越大 https://www.nowcoder.com/discuss/80837\n\n\n\n随机数生成算法，一个float数组相同元素的和除以整个数组的和做为抽取该元素的概率，实现按这种概率随机抽取数组中的元素的算法。 https://www.nowcoder.com/discuss/13857\n\n\n一本无数个字的书从前往后读，某个时间点突然暂停并返回之前读过的某个字，要求每个字返回的概率是一样的。 https://www.nowcoder.com/discuss/80218\n\n\n\n一个有n*n个方格的棋盘，在里面放m个地雷，如何放保证在每个方格上放雷的概率相等。 https://www.nowcoder.com/discuss/47399\n\n\n一根棍子折三段能组成三角形的概率\n\n设折成的三段长分别为x,y和L-x-y,\n根据三角形中任意两边的和大于第三边的性质，可得\nx+y &gt; L-x-y①\nx+(L-x-y) &gt; y②\ny+(L-x-y)&gt; x③\nx&gt;0,y&gt;0④\n0&lt;x+y&lt;L⑤\n题目所示的概率就是在④⑤围成的三角形区域S中由①②③围成的三角形区域所占的概率\n由：s=Ll/2=L^2/2， S’=(L/2)(L/2)/2=L^2/8，得所求的概率为p=S’/S=1/4.\n\n\n\n\n\n一个圆上三个点形成钝角的概率是多少？假如两个点和圆心形成的圆心角已经是直角，那么第三个和这两个点形成钝角的概率是多少？ https://www.nowcoder.com/discuss/91505\n\n\n3/4\n3/4\n\n\n\n\nX，Y独立均服从（0,1）上的均匀分布，P{X^2+Y^2≤1}等于\n\n\n\n\n\n\n\n一个圆，在圆上随机取3个点，这3个点组成锐角三角形的概率。\n\n\n\n\n\n一个袋子里有100个黑球和100个白球，每次随机拿出两个球丢掉，如果丢掉的是不同颜色的球，则从其他地方补充一个黑球到袋子里，如果颜色相同，则补充一个白球到袋子里。问：最后一个球是黑球和白球的概率分别为多大？\n\n抽到黑白：-&gt; 取一个白球\n抽到白黑：-&gt; 取一个白球\n抽到黑黑：-&gt; 取两个黑球，放一个白球\n抽到白白：-&gt; 去一个白球\n意味着每次取黑球的时候都是偶数个的取，那么当取到最后是两个黑球的时候，会放进来一个白球，所以最后肯定还剩一个白球。\n\n\n\n扔骰子，最多扔两次，第一次扔完可以自行决定要不要扔第二次，取最后一次扔色子的结果为准，求：尽可能得到最大点数的数学期望 https://www.nowcoder.com/discuss/74234\n\n\n\n对一扔一次骰子，他的期望是$\\frac{1}{6} (1 + 2 ,\\cdots, + 6) = 3.5$ ，那么此时的扔骰子的策略为，当我扔到1-3时，继续抛，当我扔到4-6时，停止。在选择继续抛的时候，之前的结果作废，此时相当于抛一次骰子。他的期望为3.5。当只投一次的时候，只会在[4, 5, 6]之间，他的期望是5，所以最终的期望是，（5+3.5）/2 = 4.25\n\n\n两人轮流扔硬币，扔出正面获胜，求：先扔者获胜的概率 https://www.nowcoder.com/discuss/74234\n\n\n设第一个人赢的概率为$p(A)$, 第二个人赢的概率为$p(B)$,\n$p(A) = \\frac{1}{2} + \\frac{1}{2} ^ 3 + \\frac{1}{2} ^ 5 + \\cdots + \\frac{1}{2} ^ {2n+1} = \\frac{2(1-\\frac{1}{4} ^ {n})}{3} $\n$p(B) = \\frac{1}{2} ^2 + \\frac{1}{2} ^ 4 + \\frac{1}{2} ^ 6 + \\cdots + \\frac{1}{2} ^ {2n} = \\frac{1-(\\frac{1}{4} ^ {n})}{3}$\n$\\frac{2}{3}, \\frac{1}{3}$\n\n\na b c 分别循环投掷硬币，直到正面出现胜利，求a b c获胜的概率 https://www.nowcoder.com/discuss/52700\n\n\n$\\frac{4}{7}, \\frac{2}{7}, \\frac{1}{7}$\n\n\n硬币正反概率是1/2,一直抛硬币,直到连续两次正面停止，问期望次数。\n\n\n设期望为E，\n当开局抛到两次正面时，$0.5\\times0.5\\times2$\n当开局抛到了反面时，需要重新抛，此时的期望分量时：$0.5\\times (E+1)$\n当开局抛到了正面，但是紧接着抛到了反面，此时有需要重新抛，期望分量为：$0.5\\times0.5\\times(E+2)$\n所以有：\n$$\nE = 0.5 \\times 0.5 \\times 2 + 0.5 \\times(E + 1) + 0.5\\times 0.5 \\times(E+2)\n$$\n求解E=6\n\n\n\n某大公司有这么一个规定：只要有一个员工过生日，当天所有员工全部放假一天。但在其余时候，所有员工都没有假期，必须正常上班。这个公司需要雇用多少员工，才能让公司一年内所有员工的总工作时间期望值最大？\n\n一个人，对于任意一天，过生日的概率是 1 / 365, 不过生日的概率是 364 / 365\nn个人，对于任意一天，没任何人过生日的概率是(364 / 365)^n\nn个人，对于任意一天，有人过生日的概率是 1 - (364   / 365)^n\n那么365天里有人过生日的期望天数是 365（1 - (364 / 365)^n）天，\n则n个人，365天，每个人工作的期望天数是365 - 365（1 - (364 / 365)^n）= 365(364 /   365)^n\n从而所有人的期望工作天数的和为：365n(364 / 365)^n，求导数，导数不小于0，递增。\n所以是365\n\n\n\n不存储数据流的前提下,从输入流中获得这 n 个等概率的随机数据 。\n\n开辟一个长度为n的数组，对与数据流的第i个数据，以$\\frac{n}{i}$的概率将其留下。（i&gt;n）\n设数据流中已经流过了m个数据，一共有n个数据被留下来了，每个数据流下来的概率为n/m\n\n那么在i=n+1时，n中的数据被留下来的概率为：\n\n$$\n\\frac{n}{m} [(1-(\\frac{n}{m+1})) + (\\frac{n}{m+1}*\\frac{n-1}{n})]\n= \\frac{n}{m}\\frac{m}{m+1} = \\frac{n}{m+1}\n$$\n\n第i个被选中留下的概率为：$\\frac{n}{m+1}$\n\n\n\n\n某段公路上1小时有车通过的概率是0.96，半小时有车通过的概率是多少\n\n反过来想，设半个小时有车经过的概率是p，那么一个小时内没有车经过的概率为$(1-p)^2$,那么一个小时内有车经过的概率为$1-(1-p)^2 = 0.96$， p=0.8\n\n\n\n一个公交站在1分钟内有车经过概率是p，问3分钟内有车经过概率\n\n$1-(1-p)^3$\n\n\n\n6位数字的8位数码管显示的数字，倒过来看和以前相同的概率是多少。 https://www.nowcoder.com/discuss/89390 https://www.nowcoder.com/discuss/19487\n\n$\\frac{6^4}{6^8}$\n\n\n\n\n\n8支球队循环赛，前四名晋级。求晋级可能性\n\n\n![image-20190807172622469](/Users/xiongz/Library/Application Support/typora-user-images/image-20190807172622469.png)\n\n\n\n一个活动，女生们手里都拿着长短不一的玫瑰花，无序地排成一排，一个男生从队头走到队尾，试图拿到尽可能长的玫瑰花，规则是:一旦他拿了一朵，后面就不能再拿了，如果错过了某朵花，就不能再回头，问最好的策略是什么? https://www.nowcoder.com/discuss/75715\n\n\n参考答案: https://www.guokr.com/article/6768/\n\n\n三个范围在0-1的数，和也在0-1的概率\n\n画个图就出来了\n1/4\n\n\n\n100张牌，每次只能抽一张，抽过的牌会丢掉，怎么选出最大的牌\n\n\n\n\n36匹马，6条跑道，选出最快3匹，最少赛多少场？\n\n先进行6场比赛，选出最快的6匹马\n这6匹马，再比赛一次，得到排序排序：\nA1 A2 A3 A4 ... A6B1 B2 B3 B4 ... B6C1 C2 C3 C4 ... C6...\n第一名肯定是A1，第二名可能是A2，B1，第三名可能是A2， A3，B1， B2， C1\n所以吧A2， A3， B1，B2， C1再进行一次比赛即可。\n总共6+1+1场\n\n\n\n5个海盗抢到了100颗宝石，每一颗都一样的大小和价值连城。他们决定：抽签决定自己的号码（1，2，3，4，5）。首先，由1号提出分配方案（你抽到1号），然后大家5人进行表决，当且仅当超过半数的人同意时，按照他的提案进行分配，否则将被扔入大海喂鲨鱼。 如果1号死后，再由2号提出分配方案，依此类推。条件：每颗宝石都是一样的价值。海盗都想保命，尽量多得宝石，尽量多杀人。问题：你会提出怎样的分配方案才能够使自己的收益最大化？\n\n\nD来分配，一定不会得到E的同意，因为只要E不同意，同意的票数就不会超过50%，然后D喂鲨鱼，E独享100颗，所以D一定不希望自己来分。D分配意味着喂鲨鱼的结局。\nC来分配，D一定会同意，所以不用分给D和E。因为D如果不同意，E一定不同意，C被喂给鲨鱼，这样又出现第一种情况了。保命要紧，D宁可不要钻石了。故C分配时可以得到全部100颗。\nB来分配，C不会同意，因为把B喂鲨鱼后回到第二种情况C会独占，所以B必须得到D、E的同意，只要分给D一个，E一个，D和E就会同意，若D和E不同意，则由C分配时一个也得不到。所以B分配时可以得到98颗，D得到一颗，E得到一颗，C0颗。\nA来进行分配，B一定不会同意，因为不可能给B98颗以上，所以要得到C、D或者C、E的同意，可以给C一个，D两个，让C、E同意；也可以给C一个E两个,来让C、E同意\n\n故最终A的分配结果是\nA97 C1 D2\n或 A97 C1 E2\n\n\n\n一个人要过一座80米的桥，每走一米需要吃一颗豆子，他最多可以装60颗豆子，问最少需要吃多少颗豆子才能走完桥？证明一下为什么你给的答案是最少的？桥长81米呢？当桥长n米，最多装m颗的时候结果用公式怎么表示？\n\n先拿60颗，走到20米处，放下20颗，返回。\n再拿60颗，走到20米处，消耗20颗，取之前放下的20颗，总共60颗，过桥。\n一共消耗80+40 = 120颗\n\n\n\n一个绳子烧完需要1个小时，假设所有绳子的材质都不一样，也不均匀，怎么取出1小时加 15分钟。\n\n把一根两端点燃，同时把另一根的一端点燃。这样，第一根烧完的时候是过了半个小时。\n半个小时后，把第二根的另一端点燃，这样在第二根烧完的时候，就是15分钟了。\n\n\n\n把1~9这9个数填入九格宫里,使每一横、竖、斜相等。\n\n\n有100个黑球，100个白球。两个桶，桶的容量无限，每个球都可以任意放在任何一个桶中，没有限制，请设计一种分配方法，使得白黑球分配到两个桶之后, 某个人从某个桶中取出的球是白球的概率最大化。（这个人去第一个桶取球的概率是1/2,第二个桶也是1/2）\n\n第一个放一个白球，剩下的都放在另一个箱子\n\n\n\n有1亿个货物，不能单个单个检测，只能通过两两对比来找出其中的次品，请设计一个算法来找出次品。\n\n\n有3盏灯，房间外有3个开关，你只有1次机会进入房间，怎么判断哪个开关对应哪盏灯？\n\n\n给你一堆螺母和螺栓，每个螺母都有一个相对应的螺栓，但是他们之间的对应关系已经打乱。你可以比较螺母和螺栓的大小关系，但是你无法比较螺母和螺母的大小关系，你也无法比较螺栓和螺栓的大小关系。设计一个算法，找出螺母和螺栓的对应关系。\n\n\n\n\n\n大数据\n100亿数字，怎么统计前100大的？\n10亿个url，每个url大小小于56B，要求去重，内存4G。\n1KW句子算相似度（还是那套分块+hash/建索引，但是因为本人不是做这个的，文本处理根本说一片空白，所以就不误导大家了），之后就是一直围绕大数据的题目不断深化。\nQ1：给定一个1T的单词文件，文件中每一行为一个单词，单词无序且有重复，当前有5台计算机。请问如何统计词频？\n\n通过对文件进行划分，将分解切分成小文件，每个计算机单独进行处理。\n\nQ2：每台计算机需要计算200G左右的文件，内存无法存放200G内容，那么如何统计这些文件的词频？\n\n维护一个dic，用于保存词-cnt，分段对文件进行处理，然后并归这些dic\n\nQ3：如何将1T的文件均匀地分配给5台机器，且每台机器统计完词频生成的文件只需要拼接起来即可（即每台机器统计的单词不出现在其他机器中）\n\n划分文件的时候，用哈希函数，将文件进行划分，这样以来，同一个词肯定会被映射到同一个文件。\n\n一个大文件A和一个小文件B，里面存的是单词，要求出在文件B中但不在文件A中的单词。然后大文件A是无法直接存到内存中的。\n\nBooming Filter. 使用若干个哈希函数，对大文件中的每一个单词进行映射，映射得到的位数指1. 对小文件中的每一个单词，用同样的哈希函数进行映射。如果有一个函数映射得到的位为就说明它不在这个大文件中。\n\n扔硬币，连续出现两次正面即结束，问扔的次数期望\n\nE = 0.5*0.5 + 0.5(E+1) + 0.5 * 0.5 * (E + 2)\nE = 6\n\n有100W个集合，每个集合中的word是同义词，同义词具有传递性， 比如集合1中有word a, 集合2中也有word a, 则集合1，2中所有词都是同义词，对这100W个集合进行归并，同义词都在一个集合当中。\n\nUnion Find\n对每一个集合中的每一对word，组成一个pair。&lt;word1, word2&gt;\ndef find(p, id):    t = p    while p != id[p]:        p = id[p]    while p != t:        x = id[t]        id[t] = p        t = x    return pdef union(p, q):    pid = find(p, id)    qid = find(q, id)    if sz[pid] &lt; sz[qid]:        sz[qid] += sz[pid]        id[pid] = id[qid]    else:        sz[pid] += sz[qid]        id[qid] = id[pid]if __name__ == &#x27;__main__&#x27;:    test = [(2, 3), (1, 0), (0, 4), (5, 7), (6, 2)]    id = [i for i in range(8)]    sz = [1 for i in range(8)]    for (p, q) in test:        union(p, q)    print(id)\n\n有几个 G 的文本，每行记录了访问 ip 的 log ，如何快速统计 ip 出现次数最高的 10 个 ip，如果只用 linux 指令又该怎么解决？\n\n海量数据的topk问题\n计算机基础\nLinux下的一些指令，$$（进程id），$?（上一条命令退出时状态），怎么查看进程，按照内存大小，CPU占用排序等等。\nLinux的命令：pwd、ln、which\nLinux线程通信\nhash表是怎么实现的？有冲突的时候怎么处理？\nlinux 文件词频统计\n介绍一下hash，怎么解决冲突。\n你说一下hashmap的原理\n内存泄露出现原因。\n悲观锁乐观锁\n把两个表按id合并怎么搞？\n数据库transaction\n浅拷贝深拷贝\n第二题是两题 sql ，涉及 join,group by,max,min,sum,count 等操作的结合，以及同个题目多种写法。\n线程安全是什么意思？新线程什么情况下会影响原有线程？\n网络基础TCP三次握手\n计算机网络：描述他发一句hello world到我这边显示，中间经历了哪些过程，我从应用层开始一层层往下分析答的，主要说http和tcp，网络层和链路层有些忘，但主要的几个协议和子网划分什么的也答了，面试官比较满意\n词向量的推导，混合高斯，linux硬链接，三次握手，linux inode\n进程线程的区别\n概率题\n100人坐飞机，第一个乘客在座位中随便选一个坐下，第100人正确坐到自己坐位的概率是？\nX是一个以p的概率产生1,1-p的概率产生0的随机变量，利用X产生1/2概率是0,1/2概率是1的随机变量。\nX，Y均服存于 [0,1] 的均匀分布，求X+Y。\n一个国家重男轻女，只要生了女孩就继续生，直到生出男孩为止，问这个国家的男女比例？\n一个有7个格子的环，三种颜色染色，相邻不能颜色重复，问多少种方案\n一个袋子里有很多种颜色的球，其中抽红球的概率为1/4，现在有放回地抽10个球，其中7个球为红球的概率是多少？\n一枚硬币，扔了一亿次都是正面朝上，再扔一次反面朝上的概率是多少？\n一道概率题，54张牌，平均分成三堆，大小王在同一堆的概率？\n一道概率题，一个六位的密码，由0~9组成，问你正过来看和倒过来看密码是一样的概率。\n一道组合数学题。10盏灯，灭三盏，两头的必须亮着，不能灭掉相邻的两盏灯，问组合数？\n有三枚硬币,其中一枚的两面都是正面图像,另一枚的两面都是反面图像,第三枚是正常的，一反一正。现从中随机的抽取一枚硬币进行抛掷，得到正面朝上，问这枚硬币的另一面是反面图像的概率是多大？\n个人玩游戏，100个球，每次挑5个，如何保证必胜。\n52张牌，四个人抽，黑桃A和红桃A同时在一个人手里的概率。\n好像是问有70%的人喜欢玩游戏，30%的人不喜欢玩游戏，现在推送的资源必须是50%游戏，50%非游戏。问怎么分配比较合理。\n有n个elements和1个Compare(A, B)函数，用Compare函数作为排序算法中的比较算子给elements排序.Compare函数有p的可能比较错。排序完取Top m个元素，本来就在Top m并被正确分在Top m的元素个数是x。问x的数学期望。\n有两个随机数产生器，R1以0.7的概率产生1，以0.3的概率产生0，而R2以0.3的概率产生1，0.7的概率产生0.问如何组合这两种产生器，使新得到的随机数产生器以0.5的概率产生1，0.5的概率产生0。随机数产生器可复用\n\n用R1和R2同时生成两个随机数：\n$$\np(1, 1) = 0.7 \\times 0.3 \\\np(1, 0) = 0.7 \\times 0.7 \\\np(0, 1) = 0.3 \\times 0.3 \\\np(0, 0) = 0.3 \\times 0.7 \\\n$$\n可以看到同事产生1，1 和同时产生0，0的概率是相等的。所以可以随机的用R1和R2产生数组\n\n如果生成的事[1, 1] 则返回1\n如果是生成的[0，0]则返回0\n如果生成 [1, 0]或者[0，1]则放弃这次的结果，继续生成。\n\n\n有两枚硬币A和B，A正面的概率为0.6，B正面的概率为0.5.现在扔了一枚硬币显示为正面，问：该枚硬币是A的概率是多少？\n\np(p|A) = 0.6\np(p|B) = 0.5\n$p(A|p) = \\frac{p(A,P)}{p§} = \\frac{p(P|A)p(A)}{p(P|A)p(A) + p(P|B)p(B)} = \\frac{0.6\\times0.5}{0.6\\times0.5+0.5\\times0.5}$\n\n概率题：有种癌症，早期的治愈率为0.8，中期的治愈率为0.5，晚期的治愈率为0.2.若早期没治好就会转为中期，中期没治好就会变成晚期。现在有一个人被诊断为癌症早期，然后被治愈了，问他被误诊为癌症的概率是多少？\n给定一个分类器p，它有0.5的概率输出1，0.5的概率输出0。\nQ1：如何生成一个分类器使该分类器输出1的概率为0.25，输出0的概率为0.75？\nQ2：如何生成一个分类器使该分类器输出1的概率为0.3，输出0的概率为0.7？\n问了一个概率题 54张牌，分成6份，每份9张牌，大小王在一起的概率\nHR常问问题\n为什么不读博、对读博报以什么态度。\n为什么选择百度，谷歌百度都给你offer你选哪个。\n为什么选择跨专业学计算机？\n为什么选择阿里\n以后可能要学习很多新技术，你怎么看。\n你平时喜欢做什么？看过哪些书？最近在看什么书？\n你觉得最有挑战的项目是什么。\n你觉得最难忘的事情是什么？\n你认为你的优（缺）点是什么。\n你还有什么想问的？\n加班怎么看。\n印象最深刻的事？\n压力最大的情况是什么时候。\n在面试过程中觉得自己那些当面有进步\n场景分析题，有一个任务给你，要求一个月完成，但是以目前的能力一个月完成不了，现在你知道有一个同事擅长这部分工作，但是他有自己的活，帮助你就可能耽误他的进度，问你咋办。\n大学令你觉得最不爽的事情是什么\n如何学习的？\n如何看待加班。\n实习期间项目，在组内担任的角色，是否熟悉其他组员的工作。\n家庭教育观念？\n家里什么情况？独生子女？\n将来的职业规划？\n工作地点\n工作地点的问题\n平时有什么兴趣爱好。\n我觉得我会先去专心钻研技术，到达一定的\n最后问了一下我兴趣爱好\n有什么问题问我。\n有没其他offer\n有没有想过去创业公司\n现在在哪里实习？实习主要做些什么？\n简单介绍一下自己\n聊聊offer情况，有什么考虑之类的。\n聊聊实验室生活。\n能不能来北京\n自己有什么优点缺点？\n自己本科生和研究生相比有哪些进步\n要求用两个字评价大学生涯。\n讲一下你觉得你突出的地方，有亮点的地方。\n评价一下你自己的优点缺点？\n详细介绍项目。\n说下你的优缺点\n说说你的经历。\n说说你自己的性格。\n说说研究生阶段最有成就的事，遇到问题具体怎么解决的。\n请你说一下你对应聘该岗位的优势。\n遇到的最大挫折是什么。\n问你的职业规划，遇到挑战怎么处理，有没有之前和同事发生过较大分歧。\n开放题\n2016年每个项目有个上线和下线时间段，统计每天在线的项目数量\n一堆问题和答案的pair，算它们的相关性\n一面现场面，自我介绍加挑一个项目细讲，还有场景题，第一题是QQ添加好友按名称搜索时，怎么区别广告号，诈骗号；\n为什么之前没有深度网络出现（数据量不够+机器性能）\n为今日头条设计一个热门评论系统，支持实时更新。\n从项目中在哪一方面体会最深。\n假设一个文档，连续的K个词，认为是一个时间窗口，一个时间窗口的词有关系，如何得到所有的时间窗口。\n假设你拥有一切搜索数据，问怎么在不同场景下进行推荐，具体场景忘了（核心点：共线性、语义相似度、主题聚类等等）\n假设有100W个单词，如何存储（我答的是trie树，面试官问每个节点会有很多子节点，每个子节点是一个指针，占用8个字节，如何节省空间，我说不知道，面试官提示双数组trie树）\n假设要对一场nba球赛进行自动解说，会遇到哪些困难，又该怎么解决呢？\n做过哪些项目？项目中遇到哪些难点，你是怎样解决的？\n关于集群调度的一些经验 trick 掌握多少；\n分词时，为了提高效率，怎么存储词典？（键树）如何压缩存储？\n在微信的场景下，如何判断用户的职业？开放问题\n场景题如何鉴别淘宝上卖假货的商家，价格维度可以用什么策略等\n如何做一个新闻推荐\n如何在语料中寻找频繁出现的字串，分析复杂度。\n如何用尽可能少的样本训练模型同时又保证模型的性能；\n如何预测双十一支付宝的负载峰值。\n对推荐算法的未来看法。\n平面上有n个点，让你设计一个数据结构，能够返回这个这n个点中距离某特定点最近的一个点。一开始讲了下kd树，然而太复杂面试官不满意，就讲了一个类似GeoHash的方案。\n建立一个数据结构，基于此写一段程序用于存储sparse vector，同时编写一个函数实现两个sparse vector的相加运算\n很多单词，如何计算单词之间的相似度（或者对单词进行分类）\n怎么预测降雨量。\n我只有一大批实体词， 如何对他们进行聚类（无监督聚类）， 如何找出这些词中， 哪些词之间有关系， 是强关系还是弱关系， 具体是什么关系，（如刘德华和朱丽倩 属于娱乐分类， 是强关系， 关系为夫妻）\n拼车软件是如何定价的以及如何优化。\n推荐算法（基于用户的协同过滤，基于内容的协同过滤）\n推荐系统的冷启动问题如何解决\n文本挖掘中，分词算法？如何选取特征？如何进行相似度计算，文本聚类结果如何评估？\n无给定条件，预测蔬菜价格。\n有100W个集合，每个集合中有一些词，对于每个集合，找出他是哪些集合的真子集。\n有一堆已经分好的词，如何去发现新的词？\n比赛相关问题提特征特征选择等\n海量的 item 算文本相似度的优化方法；\n特征工程经验。\n用两分钟介绍自己的项目，创新点在哪里。\n用户给三个item（query），如何给出查询网页。\n第三题是如何鉴别实施诈骗的QQ用户；\n第二题是微信朋友圈内容的安全鉴别；\n第四题是如何做反作弊，例如公众号的刷阅读量。\n系统设计题，给一个query，如何快速从10亿个query中找出和它最相似的 （面试官说可以对每个query找1000个最相似的，存起来，每天离线更新）\n线性代数：特征线性依赖，出现冗余，会导致什么问题？\n给一堆数据找找到最佳拟合的直线，数据有较多噪声\n给你一个系统（面试官好像是无人车部门的），后台的逻辑已经实现了，但是前端加载很慢，怎么检测。\n给你两个文件a和b，大小大概100M，两个文件每行一个整数，要求找到两个文件中相同的整数，存到文件c里，问我怎样尽快的完成这项工作？\n给出一个算法实现如何确定快递邮件上的地址，要求从国家到省市到县到乡镇的一个识别，要求效率高（有陷阱，比如有的人把县写到市的前面，有人喜欢写地域名称的省略词比如安徽省写成安徽或者皖）。\n给定淘宝上同类目同价格范围的两个商品A和B，如何利用淘宝已有的用户、商品数据、搜索数据、评论数据、用户行为数据等所有能拿到的数据进行建模，判断A和B统计平均性价比高低。统计平均性价比的衡量标准是大量曝光，购买者多则高。\n给很多单词，统计某个子串出现次数，我给的方法还是用Trie，只不过一个单词要分成多个插入到Trie数中就行了。\n给很多单词，要求统计出现某个前缀出现次数。\n统计全球会弹钢琴的人数，我用机器学习的思路答的，面试官还比较满意\n自己项目中有哪些可以迁移到其他领域的东西。\n讲了讲自己在深度学习的认识，问的问题是几个具体场景的设计，包括怎么从海量数据中提取热点问题。\n设计 LRU 系统\n设计一个合理的电梯调度策略，调度两个电梯 ，考虑满足基本的接送需求，满足能耗最小，满足用户等待时间最短\n设计一个系统可以实时统计任意ip在过去一个小时的访问量；\n设计一个结构存取稀疏矩阵（面试官最后告诉我了一个极度压缩的存法，相同行或列存偏差，我当时没听懂，还不懂装懂，最后还是没记住）\n设计实现一个git diff\n说一下最能代表你技术水平的项目吧？\n项目：具体问了特征怎么做的。\n（难到我了，我想的方法不好，面试告诉我了他的想法，类似于一个进程调度问题，每一时刻只可能有一个用户按按钮，把这条指令接收，判断当前电梯能否满足，能满足就执行，不能满足则放入一个队列里，实际情况还要细化）\n机器学习\nBoost算法\nCART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）\nGBDT与随机森林比较。\nGBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）\nKKT条件用哪些，完整描述\nKNN（分类与回归）\nL1 与 L2 的区别以及如何解决 L1 求导困难。\nL1和L2函数。\nL1和L2正则相关问题。\nL1和L2正则项，它们间的比较\nL1正则为什么可以把系数压缩成0，坐标下降法的具体实现细节\nLR为什么用sigmoid函数。这个函数有什么优点和缺点？为什么不用其他函数？\nLR和SVM有什么区别，libsvm和liblinear有什么区别。\nLogistics与随机森林比较\nLogistics（推导）\nLogistic回归的推导，怎么得到objective function。\nSVM与随机森林比较\nSVM为什么要引入拉格朗日的优化方法。\nSVM原问题和对偶问题关系？\nSVM在哪个地方引入的核函数, 如果用高斯核可以升到多少维。\nSVM怎么防止过拟合\nSVM的目标函数。常用的核函数。\nSVM的过程，讲了推导过程，可能表达不清晰，都是泪\nbagging、adaboost、boosting\nem与kmeans的关系；\nk-means的k怎么取等等\nk-means算法初始点怎么选择？你的项目里面推荐算法是怎么实现的？\nkmeans的原理，优缺点以及改进。\nk折交叉验证中k取值多少有什么关系\nl2惩罚项是怎么减小Overfitting的？l1，l2等范数的通式是什么？他们之间的区别是什么？在什么场景下用什么范数？l1在0处不可导，怎么处理？\nrandomforest,GBDT\nrf, gbdt, xgboost的区别。\nsoftmax公式\n为什么要做数据归一化？\n主要问最优化方面的知识，梯度下降法的原理以及各个变种（批量梯度下降，随机梯度下降法，mini 梯度下降法），以及这几个方法会不会有局部最优问题，牛顿法原理和适用场景，有什么缺点，如何改进（拟牛顿法）\n什么情况下一定会发生过拟合？\n什么是贝叶斯估计\n介绍LR、RF、GBDT ，分析它们的优缺点，是否写过它们的分布式代码\n介绍SVD、SVD++\n会哪些机器学习算法\n信息熵公式\n假设面试官什么都不懂，详细解释 CNN 的原理；\n决策树原理\n决策树处理连续值的方法。\n决策树如何防止过拟合\n决策树过拟合哪些方法，前后剪枝\n分类模型可以做回归分析吗？反过来可以吗？\n分类模型和回归模型的区别\n判别模型，生成模型\n各个模型的Loss function，牛顿学习法、SGD如何训练。\n在平面内有坐标已知的若干个点P0…Pn，再给出一个点P，找到离P点最近的点。\n在模型的训练迭代中，怎么评估效果。\n如何减少参数（权值共享、VGG的感受野、GoogLeNet的inception）\n如何防止过拟合（增加数据，减少模型复杂度-&gt;正则化）\n对于同分布的弱分类器，求分类器均值化之后的分布的均值跟方差。\n对于机器学习你都学了哪些？讲一个印象深的。\n常见分类模型（ svm，决策树，贝叶斯等）的优缺点，适用场景以及如何选型\n归一化方式\n\n两种常用的归一化方法：\n（1）min-max标准化\n（2）Z-score标准化方法\nmin-max标准化（Min-Max Normalization）（线性函数归一化）\n定义：也称为离差标准化，是对原始数据的线性变换，使得结果映射到0-1之间。\n本质：把数变为【0,1】之间的小数。\n转换函数：（X-Min）/(Max-Min)\n如果想要将数据映射到-1,1，则将公式换成：（X-Mean）/(Max-Min)\n其中：max为样本数据的最大值，min为样本数据的最小值，Mean表示数据的均值。\n缺陷：当有新数据加入时，可导致max和min的变化，需要重新定义。\n0均值标准化（Z-score standardization）\n定义：这种方法给与原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。经过处理的数据符合标准正态分布，即均值为0，标准差为1.\n本质：把有量纲表达式变成无量纲表达式。\n转换函数：（X-Mean）/(Standard deviation) 其中，Mean为所有样本数据的均值。Standard deviation为所有样本数据的标准差。\n应用场景\n（1）在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维的时候，第二种方法(Z-score standardization)表现更好。\n因为：第一种方法(线性变换后)，其协方差产生了倍数值的缩放，因此这种方式无法消除量纲对方差、协方差的影响，对PCA分析影响巨大；同时，由于量纲的存在，使用不同的量纲、距离的计算结果会不同。\n（2）在不涉及距离度量、协方差计算、数据不符合正太分布的时候，可以使用第一种方法或其他归一化方法。比如图像处理中，将RGB图像转换为灰度图像后将其值限定在0 255的范围。\n因为：第二种归一化方式中，新的数据由于对方差进行了归一化，这时候每个维度的量纲其实已经等价了，每个维度都服从均值为0、方差1的正态分布，在计算距离的时候，每个维度都是去量纲化的，避免了不同量纲的选取对距离计算产生的巨大影响。\n\n手写k-means的伪代码。\n手写k-means的伪代码和代码。（Code）\n手撕svm硬软间隔对偶的推导\n手撕逻辑回归（损失函数及更新方式推导）\n接着写一下信息增益的公式。\n推一下bp算法等等\n改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度。\n数据挖掘各种算法，以及各种场景下的解决方案\n是否了解mutual infomation、chi-square、LR前后向、树模型等特征选择方式。\n是否了解线性加权、bagging、boosting、cascade等模型融合方式\n有哪些常见的分类器，简单介绍下原理\n机器学习与深度学习的区别\n机器学习基础（线性回归与逻辑回归区别等）\n机器学习：几种树模型的原理和对比，朴素贝叶斯分类器原理以及公式，出现估计概率值为 0 怎么处理（拉普拉斯平滑），缺点； k-means 聚类的原理以及缺点及对应的改进；\n梯度下降牛顿拟牛顿原理\n梯度下降的优缺点。\n深度学习和普通机器学习有什么不同？\n深度学习有很大部分是CNN，给他用通俗的语言解释下卷积的概念，解释下CNN中的优势及原因\n激活函数的选择（sigmoid-&gt;ReLu-&gt;LReLU-&gt;PReLU）\n然后20分钟内手写k-means\n牛顿法、随机梯度下降算法和直接梯度下降算法的区别？\n牛顿法推导\n特征选择的方法\n由数据引申到数据不平衡怎么处理（10W正例，1W负例，牛客上有原题）\n聊聊SVM，这段说了好久，从基本的线性可分到不可分，相关升维，各种核函数，每个是如何实现升。以及出现了XX问题，分析是样本的原因还是其他原因。针对不同情况，采取什么解决方案较好。\n自己实现过什么机器学习算法\n解释 word2vec 的原理以及哈夫曼树的改进。\n解释一下过拟合和欠拟合，有哪些方法防止过拟合。\n让我一步一步地构造决策树，怎么计算信息熵、信息增益、然后C4.5 ID3 CART的区别，还说了一下优缺点\n详细讨论了样本采样和bagging的问题\n说一下Adaboost，权值更新公式。当弱分类器是LR时，每个样本的的权重是w1，w2…,写出最终的决策公式。\n说了一下bagging跟boosting。\n说明L1L2正则的效果与为什么形成这种情况（L1正则稀疏，L2正则平滑，之后说明就是画图说明正则化）\n过拟合的解决方法\n\n数据方面：数据增强，具体体现在在原图上使用patch、反转、小的角度变换\n模型方面：使用小的网络结构、添加dropout、添加BN\n损失方面：添加正则项，l1、l2正则\n\n逻辑回归估计参数时的目标函数，如果加上一个先验的服从高斯分布的假设，会是什么样。\n逻辑回归估计参数时的目标函数\n逻辑回归的值表示概率吗？\n问了很多数据挖掘的基础知识，包括SVM,逻辑回归、EM、K-means等，然后给我很多场景问我遇到这些情况我要怎么来处理数据，怎么进行建模等等，问得很细\n随机梯度下降，标准梯度\n随机森林和GBDT的区别？LR的参数怎么求解？有没有最优解？\n随机森林（Bagging+CART）\n编程题\n1~n这n个数现在去掉两个，如何找到去掉的两个数。 假设去掉的两个数是a和b，那么通过求和，平方和可以知道a+b和a^2+b^2，然后解方程就行了。\n一个字符数组中，每个字符都出现了3次，只有一个出现了2次，如果快速找出这个出现2次的？\n\ndef ffff(nums):    l = []    for i in range(32):        mask = 1 &lt;&lt; i        cnt = 0        for n in nums:            if mask &amp; n:                  cnt += 1        l.append(cnt)    l = l[::-1]    ans = 0    for i in l:        ans = ans &lt;&lt; 1        t = 1 if i%3 else 0        ans += t    return ans\n\n一个数组存着负数与正数，将正数放在前面，负数放在后面\n\ndef fff(nums):    if not nums:        return    head = 0    tail = len(nums) - 1    p = 0    while p != tail+1:        if nums[p] &lt; 0:            if p == tail:                p += 1                continue            nums[p], nums[tail] = nums[tail], nums[p]            tail -= 1        elif nums[p] &gt; 0:            if p == head:                p += 1                continue            nums[p], nums[head] = nums[head], nums[p]            head += 1        else:            p += 1    return nums\n# 一个运算序列只有+、*、数字，计算运算序列的结果\n\n\ndef cal(s): num = 0 items = s.split(&#x27;+&#x27;) for i in items:     if &#x27;*&#x27; in i:         t = i.split(&#x27;*&#x27;)         mul = 1         for j in t:             mul *= float(j) # 有可能有小数         num += mul     else:         num += float(i) return num``### ##  一维数组，swap 其中的几对数字（每个数字只属于一次 swap 操作），实现查找### \n\n一维有序数组，经过循环位移后，最小的数出现在数列中间，如果原数组严格递增或递减，如何找这个最小数\n一维有序数组，经过循环位移后，最小的数出现在数列中间，如果原数组严格递增，如何找这个最小数。\n一维有序数组，经过循环位移后，最小的数出现在数列中间，如果原数组非严格递增或递减，如何找这个最小数；\n一维有序数组，经过循环位移后，最小的数出现在数列中间，数组可能是递增、递减、递减后递增、递增后递减四种情况，递增递减都是非严格的，如果有转折点，返回转折点的值，否则返回-1；\n一道题：给定一个整数数组，里面有两个数相同，其他数都是不同的，如何尽快找到这两个数（答，用hash表，O（N），有更好的方法么？）\n一题是多位数用链表存储（ e.g. 123 用 1-&gt;2-&gt;3 存储），实现相加功能函数   ###   ## 不创建临时产量换两个数\n\na = a ^ b\nb = a ^ b\na = a ^ ###    ## 两个同样大小有序数组求中位数\n\n\ndef medium(nums1, nums2): n = len(nums1) - 1 left = 0 right = n while left &lt; right:     i = left + ((right - left + 1) &gt;&gt; 1)     j = (2 * n + 1)//2 - i     if i &lt; n and nums2[j - 1] &gt; nums1[i]:         left = i + 1     elif i &gt; 0 and nums1[i - 1] &gt; nums2[j]:         right = i - 1 if i - 1 == 0:     leftmax = nums2[j - 1] elif j - 1 == 0:     leftmax = nums1[i - 1] else:     leftmax = max(nums1[i - 1], nums2[j - 1]) if i == n:     rightmin = nums2[j] elif j == n:     rightmin = nums1[i] else:     rightmin = min(nums1[i], nums2[j]) return (leftmax + rightmin) / 2\n\n``\n两个大整数相乘\n\ndef bigmul(nums1, nums2): l1, l2 = list(map(int, list(str(nums1)))), list(map(int, list(str(nums2)))) ans = [0] * (len(l1)+len(l2)-1) for i, n1 in enumerate(l1):     for j, n2 in enumerate(l2):         t = n1 * n2         ans[i+j] += t carry = 0 for i in range(len(ans)-1, -1, -1):     t = (ans[i]+carry)%10     carry = (ans[i]+carry)//10     ans[i] = t while carry:     ans.insert(0, carry%10)     carry = carry//10 return &#x27;&#x27;.join(list(map(str, ans)))### ```\n\n两棵树相加——对应位置两棵树都有值则相加，对应位置只有一棵树有值则取该值\n\ndef treeadd(root1, root2):if not root1: return root2if not root2: return root1root = TreeNode(root1.val + root2.val)root.left = TreeNode(root1.left, root2.left)root.right = TreeNode(root1.right, root2.right)return root### ```\n\n中序遍历二叉树，利用O(1)空间统计遍历的每个节点的层次\n\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def inorderTraversal(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        stack = []        cur = root        ans = []        while stack or cur:            if cur:                stack.append(cur)                cur = cur.left            else:                t = stack.pop()                ans.append(t.val)                cur = t.right        return ans                 \ndef preorder(root):stack = []cur = rootans = []while stack or cur:if cur:ans.append(cur.val)stack.append(cur.right)cur = cur.leftelse:cur = stack.pop()\n# Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution(object):    def postorderTraversal(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        ans = []        stack = []        cur = root        while stack or cur:            if cur:                ans.append(cur.val)                stack.append(cur.left) # 这里是往右走                cur = cur.right            else:                cur = stack.pop()        return ans[::-1]\n\n为分析用户行为\n系统常需存储用户的一些 query ，但因 query 非常多，故系统不能全存，设系统每天只存 m 个 query ，现设计一个算法，对用户请求的 query 进行随机选择 m 个，请给一个方案，使得每个 query 被抽中的概率相等，并分析之，注意：不到最后一刻，并不知用户的总请求量\n\n在第i个数据来的时候，以m/i的概率将它保留，保留的时候，在m个数据中随机选取一### ，然后加入。\n\n二叉树序列化\n\n# 先序遍历的方式保存def serilize(root): cur = root stack = [] ans = [] while stack or cur:     if cur:         ans.append(cur.val)         stack.append(cur.right)         cur = cur.left     else:         ans.append(&quot;#&quot;)         cur = stack.pop() return ansdef deserilize(s): stack = [] ans = None for i in s:     if i == &#x27;#&#x27;:         while stack[-1] == &#x27;#&#x27;:             stack.pop()             stack.pop()         stack.append(&#x27;#&#x27;)     else:         t = TreeNode(int(i))         if not stack:             ans = t             stack.append(t)         elif stack[-1] == &#x27;#&#x27;:             stack[-2].right = t             stack.append(t)         else:             stack[-1].left = t             stack.append(t) return ans\n\n``\n\n二叉树遍历，描述下层序遍历\n\nimport copydef leveltravel(root):  stack = [root]  while stack:    l = []    for i in range(len(stack)):      t = stack.pop()      print(t.val, end=&#x27; &#x27;)      if t.right:        l.append(t.right)      if t.left:        l.append(t.left)    print(&#x27;&#x27;)    stack = copy.copy(l)    \n\n二维数组，每行递增，每列递增，任意交换其中的两### 现并恢复。\n二维数组，每行递增，每列递增，实现查找\n\ndef find(matrix, target): if not matrix or not matrix[0]:     return None row, col = len(matrix), len(matrix[0]) i, j = row-1, 0 while i&gt;=0 and j &lt; col:     if matrix[i][j] == target:         return i, j     elif matrix[i][j] &lt; target:         j += 1     else:         i -= 1 return Non###  ```\n\n二维数组，每行递增，每列递增，求第k大的数\n\ndef kthsmallestinrotatedmatrix(matrix, k):    if not matrix:        return None    row, col = len(matrix), len(matrix[0])    if k &gt; row * col:        return None    smallest_idx_in_rows = [0] * len(matrix)    for _ in range(k):        min_ = float(&#x27;inf&#x27;)        tag = None        for i in range(len(matrix)):            if smallest_idx_in_rows[i] &lt; len(matrix[0]):                if matrix[i][smallest_idx_in_rows[i]] &lt; min_:                    min_ = matrix[i][smallest_idx_in_rows[i]]                    tag = i        smallest_idx_in_rows[tag] += 1        ans = min_    return ans\n\n介绍大顶堆和小顶堆\n从一组数中找出和为sum的三个数（leetcode原题，先sort再找，并且剪枝），写代码，四个### 说思路。\n允许两个元素交换一次的最大连续子序列和\n\ndef maxsequence(nums):    if not nums:        return None    sum_ = 0    max_ = -float(&#x27;inf&#x27;)    start, end = 0, 0    for i, n in enumerate(nums):        sum_ += n        if sum_ &lt; n:            sum_ = n            start = i        else:            if sum_ &gt; max_:                max_= sum_                end = i    sub = nums[start: end+1]    left = nums[:start-1] + nums[end+1:]    a = min(sub)    if left:        b = max(left)    if a &gt; 0 and b&gt;0:        if b &gt; 0:            sub.append(b)    if a &lt; 0 and  b &gt; a:        sub.remove(a)        sub.append(b)    print(sub)\n\n全排列\n冒泡排序\n\ndef bubbleSort(nums):    for i in range(len(nums)):        for j in range(1, len(nums)-i):            if nums[j] &lt; nums[j-1]:                nums[j], nums[j-1] = nums[j-1], nums[j]    return nums\n\n写一个二叉树的非递归的后续遍历\n\ndef postOrder(root):    stack = []    ans = []    cur = root    while stack or cur:        if cur:            ans.append(cur.val)            stack.append(cur.right)            cur = cur.left        else:            cur = stack.pop()    ans = ans[::-1]    return ans\n\n最长公共子序列\n\n子序列是不相连的\ndef lcs(s1, s2):    if not s1 or not s2:        return &quot;&quot;    n1, n2 = len(s1), len(s2)    dp = [[0]*(n2+1) for _ in range(n1+1)]    for i in range(1, n1+1):        for j in range(1, n2+1):            if s1[i-1] == s2[j-1]:                dp[i][j] = dp[i-1][j-1]+1            else:                if dp[i-1][j] &gt; dp[i][j-1]:                    dp[i][j] = dp[i-1][j]                else:                    dp[i][j] = dp[i][j-1]    ans = []    i, j = len(dp)-1, len(dp[0])-1    while dp[i][j]:        if dp[i][j] == dp[i-1][j]:            i -= 1        elif dp[i][j] == dp[i][j-1]:            j -= 1        else:            ans.append(s1[i-1])            i -= 1            j -= 1    for i in dp:        print(i)    return ans[::-1]\n\n判断一个字符串是否为另外一个字符串旋转之后的字符串\n\ndef isreversed(s1, s2):    if len(s1) != len(s2):        return False    return s1 in s2+s2[::-1]\n\n前k大的数\n\ndef kthLargest(nums, k):    q = []    if len(nums) &lt; k:        return None    for i in nums:        if len(q) &lt; k:            q.append(i)        else:            if i &gt; min(q):                q.remove(min(q))                q.append(i)    return min(q)\n\n单链表的翻转\n\ndef reverselinkedlist(head):    if not head or not head.next:        return head    p = reverselinkedlist(head.next)    head.next.next, head.next = head, None    return p\ndef reverseLinkedList(head):    if not head or not head.next:        return head    pre = head    p = pre.next    pre.next = None    while p:        q = p.next        p.next = pre        pre = p        p = q    return pre\n\n去掉连续的重复数字，输出新数组，例如：1，2，2，2，1，3，5——&gt; 3，5\n\ndef removeDuplicate(nums):    nums.sort()    i, j = 0, 0    ans = []    while j &lt; len(nums) and i &lt; len(nums):        while j &lt; len(nums) and nums[i] == nums[j]:            j += 1        if i == j-1:            ans.append(nums[i])        i = j        j = i    return ans\n\n去除字符串S1中的字符使得最终的字符串S2不包含’ab’和’c’\n\ndef remove(s1):    s1 = list(s1)    item = &#123;&#x27;ab&#x27;, &#x27;c&#x27;&#125;    stack = []    for i in s1:        stack.append(i)        while stack and stack[-1] == &#x27;c&#x27;:            stack.pop()        while len(stack)&gt;=2 and stack[-1] == &#x27;b&#x27; and stack[-2] == &#x27;a&#x27;:            stack.pop()    return &#x27;&#x27;.join(list(map(str, stack)))\n\n合法括号匹配\n\ndef match(s):    stack = []    dic = &#123;&#x27;)&#x27;: &#x27;(&#x27;, &#x27;]&#x27;: &#x27;[&#x27;, &#x27;&#125;&#x27;: &#x27;&#123;&#x27; &#125;    for i in s:        if i in &#123;&#x27;(&#x27;, &#x27;[&#x27;, &#x27;&#123;&#x27;&#125;:            stack.append(i)        elif i in dic:            if not stack:                return False            if stack.pop() != dic[i]:                return False    if stack:        return False    return True\n\n在一个字符串中，找出最长的无重复字符的子串\n\ndef lnr(s):    cnt = &#123;&#125;    start, end = 0, 0    tag = -float(&#x27;inf&#x27;)    ans = &#x27;&#x27;    while end &lt; len(s):        cnt[s[end]] = cnt.get(s[end], 0) + 1        end += 1        if all(i in &#123;0, 1&#125; for i in cnt.values()):            if end - start &gt; tag:                tag = end - start                ans = s[start: end]        else:            while not all(i in &#123;0, 1&#125; for i in cnt.values()):                cnt[s[start]] -= 1                start += 1    return ans\n\n在二叉树结点结构中加一个指针域，使其指向层次遍历的下一个结点\n\nclass Solution(object):    def connect(self, root):        cur = root        while cur:            nextlevel = None            nextcur = None            while cur:                if nextlevel == None:                    if cur.left:                        nextlevel = cur.left                    elif cur.right:                        nextlevel = cur.right                    p = nextlevel                    nextcur = nextlevel                if p and cur.left and p is not cur.left:                    p.next = cur.left                    p = p.next                if p and cur.right and p is not cur.right:                    p.next = cur.right                    p = p.next                cur = cur.next            cur = nextcur        return root\n\n堆排序\n\ndef heapsort(nums):    if not nums:        return nums    def add(nums, start, end):        root = start        while True:            child = root * 2 + 1 # left child            if child &gt; end:                break            if child + 1 &lt;= end and nums[child + 1] &gt; nums[child]: # right child is biger                child = child + 1            if nums[child] &gt; nums[root]:                nums[root], nums[child] = nums[child], nums[root]                root = child            else: # if father larger than both child break                break    for i in range((len(nums) // 2) - 1, -1, -1): # adjust from the last father node        add(nums, i, len(nums) - 1)    for i in range(len(nums) - 1, -1, -1): # put the largetst number in the last of num         nums[0], nums[i] = nums[i], nums[0]        add(nums, 0, i - 1) # adjust the nums execpt the last numbet    print(nums)\n\n字符串移位，给出字符串abc##dfg##gh，实现将所有#移至字符串串头。输出####abcdfggh\n\ndef move(s):    ans = list(s)    end = len(s)-1    for i in range(len(s)-1, -1, -1):        if s[i] != &#x27;#&#x27;:            ans[end] = s[i]            end -= 1    for i in range(end, -1, -1):        ans[i] = &#x27;#&#x27;    return &#x27;&#x27;.join(ans)\n\n定义满足$n=x^a+y^b$（$x，y，a，b$是非负整数）的n是神奇数。如$4 = 2^0 + 3^1,17 = 2^3 + 3^2$。输入l和r，请求出闭区间$[l,r]$里，最长的一段不含有神奇数的连续区间长度。$x,y,l,r&lt;=10^{18},x&gt;=2,y&gt;=2$，如$3\\ 5\\ 10\\ 22$，在$[10,22]$区间内，$x=3,y=5$的条件下，区间内[14]是神奇数，所以最长的区间是$[15,22]$长度为$8$，如$2，3，1，10$，在$[1,10]$区间内，$x=2，y=3$的条件下，$2，3，4，5，7，9$都是神奇数，所以最长的区间只有长度$1$\n实现栈，使得 添加、删除、max 操作的复杂度为 O(1)\n\nclass ms():    def __init__():        self.stack = []        self.max_ = []    def add(num):        self.stack.append(num)\t\tif not self.max_:            self.max_.append(num)        elif self.max_[-1] &gt; num:            self.max_.append(self.max_[-1])        else:            self.max_.append(num)    def pop():        self.max_.pop()        return self.stack.pop()   \tdef max():        if not self.max_:            return None        return self.max_[-1]\n\n给定一个字符串，按空格翻转每一个单词，但是单词内的字符顺序保持不变\nI am a student. -&gt; student. a am I\n\ndef r(s):    def reverse(s, i, j):        while i &lt; j:            s[i], s[j] = s[j], s[i]         \ti += 1            j -= 1            s = list(s)    s = reverse(s, 0, len(s)-1)    left = 0    for right in range(len(s)):        if s[right] == &#x27; &#x27; or right == len(s):            reverse(s, start, end-1)            start = end + 1            end = end + 1        else:            end += 1    return &#x27;&#x27;.join(s)            \n\n对于一个字符串，请设计一个算法，将字符串的长度为len的前缀平移到字符串的最后\n\ndef move(s, k):    s = list(s)    if k &lt; 0 or k &gt; len(s):        return None    head = s[:k][::-1]    tail = s[k:][::-1]    s = head + tail    return &#x27;&#x27;.join(s[::-1])\n\n寻找字符串中第一个只出现一次的字符\n\nfrom collections import Counterdef firstchr(s):    c = Counter(s)    for i in s:        if c[i] == 1:            return i\n\n将字符串连续重复出现的字符删到只剩一个\n\ndef removeduplicate(s):    ans = []    start, end = 0, 0    while end &lt; len(s):        while s[end] == s[start]:            end += 1        ans.append(s[start])        start = end        end = end+1    return &#x27;&#x27;.join(ans)\n\n常用排序算法的时间和空间复杂度\n\n冒泡排序\n插入排序\n选择排序\n并归排序\n快速排序\n堆排序\n\n归并排序\n\ndef mergsort(nums):    def merge(left, right):        ans = []        i, j = 0, 0        while i &lt; len(left) and j &lt; len(right):            if left[i] &lt; right[j]:                ans.append(left[i])                i += 1            else:                ans.append(right[j])                j += 1        while i &lt; len(left):            ans.append(left[i])            i += 1        while j &lt; len(right):            ans.append(right[j])            j += 1        return ans    if not nums or len(nums)==1:        return nums    left = mergsort(nums[:len(nums) // 2])    right = mergsort(nums[len(nums) // 2:])    return merge(left, right)\n\n快速排序\n\ndef quicksort(nums):    def swap(nums, i, j):        nums[i], nums[j] = nums[j], nums[i]    def partition(nums, i, j):        start, end = i, j        swap(nums, start, end)        pivot = end        end = end - 1        i = start        while i &lt;= end:            if nums[i] &lt; nums[pivot] and start != i:                nums[i], nums[start] = nums[start], nums[i]                i -= 1                start += 1            elif nums[i] &gt;= nums[pivot] and i != end:                nums[i], nums[end] = nums[end], nums[i]                i -= 1                end -= 1            i += 1        swap(nums, i, pivot)        return i    def qs(nums, i, j):        if i &lt; j:            pivot = partition(nums, i, j)            qs(nums, i, pivot-1)            qs(nums, pivot+1, j)            return nums    return qs(nums, 0, len(nums)-1)   手写快排(easy)   \n\n打印数组的组合数\n\ndef combination(nums):    import copy    ans = []    visited = [False]*len(nums)    def bfs(ans, t, level, visited):        if level &gt; len(nums):            return        if t not in ans:            ans.append(copy.copy(t))        for i in range(level, len(nums)):            if not visited[i]:                visited[i] = True                t.append(nums[i])                bfs(ans, t, level+1, visited)                t.pop()                visited[i] = False    bfs(ans, [], 0, visited)    return ans\n\n把一个bst转化成一个双向链表\n\ndef trans(root):    tail = None    tail = f(root, tail)    while tail and tail.left:\t\ttail = tail.left\treturn taildef f(root, tail):    if not root:        return None    if root.left:   \t\ttail = f(root.left, tail)        root.left = tail    if tail:    \ttail.right = root    tail = root    if root.right:\t\tlast = f(root.right, tail)     return last\n\n把一个字符串的大写字母放到字符串的后面，各个字符的相对位置不变，不能申请额外的空间\n\n例如AbcDeFGhi -&gt;bceiADFG\ndef cmp(a, b):    if a.islower() and b.isupper():        return 1    if a.islower() and b.islower():        return 0    if a.isupper() and b.isupper():        return 0    else:        return -1import functoolsdef moves(s):    s = list(s)    s.sort(key=functools.cmp_to_key(cmp))    return s\n\n描述Dijkstra最短路径算法\n\ndef dijkstra(l, from_, to_):    dic = &#123;&#125;    for (u, v, c) in l:        dic[u] = dic.get(u, &#123;&#125;)        dic[u][v] = c\timport heapq    l = []    path = []    l.append([0, from_, path])    visited = set()    while l:        [cost, t, path] = heapq.heappop(l)        visited.add(t)        path += [t]        if t == to_:            return path        else:            for v, c in dic.get(t, &#123;&#125;).items():                if v not in visited:                    heapq.heappush(l, [cost+c, v, path])                    visited.add(v)\treturn float(&#x27;inf&#x27;)            \n\n插入排序\n数列中找第 k 大的数字\n数据解压缩，3(a4(ab)) -&gt; aababababaababababaabababab\n\ndef unzip(s):    stack = []    nums = []    i = 0    while i &lt; len(s):                \n\n最少时间复杂度求数组中第k大的数\n最短路径代码\n最长公共子串（动态规划有关）\n最长公共子序列\n有一堆无向好友列表 1-2， 3-4, 2-3 之类的，问能不能把这些用户划分两组，组内都不互为好友。\n有序数组寻找和为某数的一对数字；\n正数数组，找三个数使积最小，问有多少种选择。\n母鸡、公鸡和小鸡问题：公鸡五块一只，母鸡三块一只，小鸡一块三只，用100元买100只鸡的所有方法。\n求double类型的二进制1的个数。\n求二叉树最近公共祖先(leetcode原题)\n求连续子数组最大乘积，还让考虑边界问题（最后问了：连乘有可能导致溢出，存不下了）\n用一个队列，将每个二叉树的root先放入队列。\n用数组实现队列，各操作的复杂度分析。\n用速度不同的指针可以判断链表中是否有环，问两速度满足怎样的关系可以保证发现环。\n直接插入排序写代码\n矩阵求最长连续递增的路径长度。\n第一题是链表倒数第 k 节点；第二题是二叉树打印路径，第三题是矩阵中将 0 元素所在行列全置 0 的最优空间解法\n存在一个数组，大小98，里面的元素均为在[1,100]，且无重复， 不申请额外空间的情况下，在时间复杂度为O(N)情况下，找出缺失的两个元素值。\n给一个n*n的矩阵，矩阵中满足每行每列都是递增的，要查找矩阵是否存在某个数.(leetcode原题)\n给一个数组，只有一个元素出现了一次，其他都出现了两次，找出出现一次的数。\n给一个数组，数组种存在一种数，它的左边都比它小，右边都比它大，找出所有这些数的位置。\n给一个股票，n天的价格，只能两次买入卖出，而且只能只能先卖再买，问最多赚多少钱？\n给一个股票，n天的价格，只能进行一次买入和卖出，问最多赚多少钱？\n给一个股票，n天的价格，可以买入卖出k次，而且只能只能先卖再买，问最多赚多少钱？\n给一个股票，n天的价格，可以无限次买入卖出，问最多赚多少钱？\n给了一个链表，第1个结点标号为1，把链表中标号在M到N区间的部分反转\n\ndef f(head, m, n):  if m &gt; n:    return -1  cnt = 1  dump = Node(-1)  dump.next = head  p = head  pre = dump  Pre, M, N = None, None, None  while p.next:    if cnt == m:      M = p      Pre = pre    if cnt == n:      N = p    pre = p    p = p.next    cnt += 1  if not M or not N:    return -1  tail = N  while Pre.next != tail:    Pre.next = Pre.next.next    M.next = N.next    N.next = M    N = N.next    M = Pre.next return dump.next\n\n给你一个无重复的数组输出全排列\n\ndef f(nums):    if not nums:        return    if len(nums) == 1:        return [nums]    ans = []    for i in range(len(nums)):        for j in f(nums[:i] + nums[i + 1:]):            if not j:                continue            ans.append([nums[i]] + j)    return ans\n\n给你一颗二叉树按层输出每一层输出后都换行\n\ndef travel(root):\tif not root:    return \tstack = [root]  while stack:    l = len(stack)    ans = []    for i in range(l):      t = stack.pop()      print(t.val, end=&#x27; &#x27;)      ans.append(t)      if t.right:        ans.append(t.right)      if t.left:        ans.append(t.left)    stack = copy.copy(ans)    print(&quot;&quot;)\n\n给出一颗二叉树，两个叶节点，找到这两个叶节点互连通的一条最短路径\n\ndef f(root, p, q， level):  if not root:    return -1  if root == p or root == q:    return level  left = f(root.left, p, q, level+1)  right = f(root.right, p, q, level+1)  if left == -1:    return right  if right == -1:    return left  return left+right-2*level\n\n给定一个数组，只有一个元素出现了一次，其他都出现了3次，找出出现一次的数。\n\ndef f(nums):  l = []\tfor i in range(32):    mask = 1 &lt;&lt; i    cnt = 0    for n in nums:      if mask &amp; n:        cnt += 1    l.append(cnt)  l = l[::-1]  ans = 0  for i in l:    ans = ans &lt;&lt; 1    t = 1 if i%3 else 0    ans += t  return ans\n\n给定一个数组，有两个元素出现了一次，其他都出现了两次，找出两个出现一次的数\n\ndef f(nums):  xor = 0  for i in nums:    xor ^= i  mask = 1  while mask &amp; xor:    mask &lt;&lt;= 1  l, r = [], []  for i in nums:    if i ^ mask:      l.append(i)    else:      r.append(i)  a, b = 0, 0  for i in l:    a ^= i  for i in r:    b ^= i  return a, b\n\n给定一个数组，判断是否存在一个片段，使得反转这个片段后能够使该向量升序排列。如：[1, 2, 4, 3]，就可以通过反转[4, 3]使得向量变为[1, 2, 3, 4]\n\ndef f(nums):  n = len(nums)  i, start, end = 1, 0, 0  while i &lt; n and nums[i] &gt; nums[i-1]:    start += 1    i += 1    if i == n:      return False    end = i    i += 1    while i &lt; n and nums[i] &lt; nums[j-1]:      end += 1      i += 1    if i == n:      if nums[start-1] &lt; nums[end]:        return True      else:        return False    else:      while i &lt; n and nums[i] &gt; nums[i-1]:        i += 1      if i != n:        return False      if nums[start-1] &lt; nums[end] and nums[start] &lt; nums[end+1]:        return True\t\t\treturn False      \n\n给定二叉树的先序跟后序遍历，能不能将二叉树重建\n\n不能，因为先序：父节点-左节点-右节点，后序：左节点-右节点-父节点，两者的拓扑序列是一样的，所以无法建立）\n\n给定循环递增数组 $a=[7,8,9,1,2,3]$和一个值$k=2$,返回该值得再数组中的下标\n\ndef find(A, k):  if not A:    return -1  left, right = 0, len(A)-1  while left &lt;= right:    mid = left + ((right-left)&gt;&gt;1)    if A[mid] == k:      return mid    elif A[mid] &lt; A[right]:      if A[mid] &lt; target &lt;= A[right]:        left = mid + 1      else:        right = mid - 1    else:      if A[left] &lt;= target &lt; A[mid]:        right = mid - 1      else:        left = mid + 1  return -1\n\n给定数组A和一个数T，A中的数可复用，求和为T的A中的数最少的个数\n\ndef f(A, T):  dp = [float(&#x27;inf&#x27;)]*(T+1)  dp[0] = 0  for i in A:    for j in range(T+1):      if j-i &gt;= 0:        dp[j] = min(dp[j], dp[j-i]+1)  return dp[-1] if dp[-1] &lt; float(&#x27;inf&#x27;) else 0\n\n给定数组，寻找 next big\n\n［1，2，5，10，20，50，100］，可以从里面取若干个数，要求得出和为100的不同取法有多少？\n数列中的逆序对\n\n# -*- coding:utf-8 -*-class Solution:    def InversePairs(self, nums):        # write code here        self.cnt = 0        def mergeSortCount(nums, left, right, temp):            if left &gt;= right:                return 0            mid = left + ((right - left) &gt;&gt; 1)            mergeSortCount(nums, left, mid, temp)            mergeSortCount(nums, mid + 1, right, temp)            merge(nums, left, mid, mid + 1, right, temp)        def merge(nums, l_left, l_right, r_left, r_right, temp):            i = l_left            j = r_left            k = l_left            while i &lt;= l_right and j &lt;= r_right:                if nums[i] &lt; nums[j]:                    temp[k] = nums[i]                    k += 1                    i += 1                else:                    temp[k] = nums[j]                    k += 1                    j += 1                    self.cnt += l_right - i + 1            while i &lt;= l_right:                temp[k] = nums[i]                k += 1                i += 1            while j &lt;= r_right:                temp[k] = nums[j]                k += 1                j += 1            for i in range(l_left, r_right+1):                nums[i] = temp[i]        if not nums or len(nums) == 1:            return 0        temp = [0] * len(nums)        mergeSortCount(nums, 0, len(nums) - 1, temp)        return self.cnt\n\n正整数平方根整数部分\n\nbinary search\n\n翻转二叉树（Code）\n若干个二叉树，如何按照层序遍历\n设 rand （ s ， t ）返回 [s,t] 之间的随机小数，利用该函数在一个半径为 R 的圆内找随机 n 个点，并给出时间复杂度分析。\n输入一个大长方形，长宽ab，和一堆小长方形。选择两个小长方形，它能放进大长方形，而这个小长方形面积和最大\n输入一个宿舍楼亮灯描述图，计算把所有灯关掉的最短时间，管理员起点在左下角，只能在最左或最右的楼梯往上一层，不可往下一层。每次往上一层花费1分钟，每次往左或往右一间宿舍花费1分钟，关灯不花时间。输入的高&lt;=15，宽&lt;=100。\n如图:\n\n0010\n0100\n\n从左下角开始，最短花费时间是先往右（关灯），再往左，再上一层，再往右两次（关灯）完成：5\n​    再如：\n\n001000\n000010\n000010\n\n最短时间是先往右四次（关灯），往右一次，上一层，往左一次（关灯），往右一次，上一层，往左三次（关灯），完成，12\npython的动态数组是如何实现的\n\nHow are lists implemented?\nPython’s lists are really variable-length arrays, not Lisp-style linked lists. The implementation uses a contiguous array of references to other objects, and keeps a pointer to this array and the array’s length in a list head structure.\nThis makes indexing a list a[i] an operation whose cost is independent of the size of the list or the value of the index.\nWhen items are appended or inserted, the array of references is resized. Some cleverness is applied to improve the performance of appending items repeatedly; when the array must be grown, some extra space is allocated so the next few times don’t require an actual resize.\n\n输入两个正数数组，在两个数组分别选一个数，要求第一个数组选的数的下标小于第二个数组选的数的下标。使得两个数的乘积最大。\n\ndef getmax(a, b):    t = 0    ans = -float(&#x27;inf&#x27;)    for i, j in enumerate(b):        ans = max(ans, j*t)        t = max(t, a[i])    print(ans)\n\n输出字符串中的所有重复子串，例如：abcab，输出: a, b, ab\n\n连续子数组最大和\n\ndef maxSum(nums):  if not nums:    return 0  s = 0  ans = -float(&#x27;inf&#x27;)\tfor i in nums:    if s+i &lt; i:      s = i    else:      s += i    ans = max(ans, s)    return ans    \n\n选择排序\n\ndef selectSort(nums):   if not nums:      return nums    idx = cur    for cur in range(len(nums)):      idx = cur\t    for i in range(cur, len(nums)):        \tif nums[i] &lt; nums[idx]:            idx = i      nums[cur], nums[idx] = nums[idx], nums[cur]        \n\n链表快速排序\n\ndef swap(p, q):    p.val, q.val = q.val, p.valdef partition(head, tail):    pivot = head    p = head    while p != tail:        if p.val &lt;= tail.val:            swap(p, pivot)            pivot = pivot.next        p = p.next    swap(pivot, tail)    return pivotdef qs(head, tail):    if head == tail or head.next == tail:        return    pivot = partition(head, tail)    qs(head, pivot)    qs(pivot.next, tail)def sort(head):    if not head or not head.next:        return    tail = head    while tail.next:        tail = tail.next    qs(head, tail)\n\n长度为N的序列有多少种不同的二叉树形态的中序遍历\n\n1的平方加到100的平方结果\n\nn(n+1)(2n+1)/6\n\nSpark 和mapreduce 的不同\n\n而MapReduce计算模型的架构导致上述两类应用先天缓慢，用户迫切需要一种更快的计算模型，来补充MapReduce的先天不足。Spark的出现就弥补了这些不足，我们来了解一些Spark的优势：\n1.每一个作业独立调度，可以把所有的作业做一个图进行调度，各个作业之间相互依赖，在调度过程中一起调度，速度快。\n2.所有过程都基于内存，所以通常也将Spark称作是基于内存的迭代式运算框架。\n3.spark提供了更丰富的算子，让操作更方便\n\nTCP为啥是三次握手\n\nTCP链接之所以可靠，是因为其链接是面向字节的。\n\n\n在通信的过程中，协议会给每个字节一个序分配一个序号。三步握手的过程，主要是为了互相确认双方的起始序列号。\n**如果只进行两次握手，**客户端发送链接请求及起始序列号seq = x, 收到 服务器端的起始序列号seq = y及对客户端序列号seq= x 的确认。此时，双方就 客户端的起始序列号达成了共识。\n此时，并没有对服务器的起始序列号达成共识，所以就需要进行第三次握手。对B的起始序列号达成共识，不能保证通信的可靠。\n如果进行四次握手，在四次握手的过程中，可以把第二、三步合并，这样可以提高连接的速度与效率。\n\n余弦距离和欧式距离\n\n余弦相似度：$\\cos(A, B) = \\frac{AB}{||A||_2||B||_2}$\n余弦距离： $1-\\cos(A, B)$\n欧式距离：$\\begin{equation}\nd=\\sqrt{\\sum_{i=1}^{N}\\left(A_{i}-B_{i}\\right)^{2}}\n\\end{equation}$\n$$\n\\begin{equation}\n|A-B|_{2}=\\sqrt{2(1-\\cos (A, B))}\n\\end{equation}\n$$\n总体来说，欧氏距离体现数值上的绝对差异，而余弦距离体现方向上的相对差异。\n\n\n统计两部剧的用户观看行为，用户A的观看向量为(0,1)，用户B为(1,0)；此时二者的余弦距很大，而欧氏距离很小；我们分析两个用户对于不同视频的偏好，更关注相对差异，显然应当使用余弦距离。\n\n\n而当我们分析用户活跃度，以登陆次数(单位：次)和平均观看时长(单：分钟)作为特征时，余弦距离会认为(1,10)、(10,100)两个用户距离很近；但显然这两个用户活跃度是有着极大差异的，此时我们更关注数值绝对差异，应当使用欧氏距离。\n\n\n\nLBP算子\n\n原始的LBP算子定义为在$3\\times3$的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于等于中心像素值，则该像素点的位置被标记为1，否则为0。这样，$3\\times3$邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息。需要注意的是，LBP值是按照顺时针方向组成的二进制数。\n基本的 LBP算子的最大缺陷在于它只覆盖了一个固定半径范围内的小区域，这显然不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala等对 LBP 算子进行了改进，将 3×3邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的 LBP 算子允许在半径为 R 的圆形邻域内有任意多个像素点。从而得到了诸如半径为R的圆形区域内含有P个采样点的LBP算子，称为Extended LBP，也叫Circular LBP。\n\n优点:\n\n一定程度上消除了光照变化的问题\n具有旋转不变性\n纹理特征维度低，计算速度快\n\n缺点:\n\n当光照变化不均匀时,各像素间的大小关系被破坏,对应的LBP算子也就发生了变化。\n通过引入旋转不变的定义,使LBP算子更具鲁棒性。但这也使得LBP算子丢失了方向信息。\n\n原始LBP代码：\nimport cv2import numpy as npdef origin_LBP(img): dst = np.zeros(img.shape,dtype=img.dtype) h,w=img.shape for i in range(1,h-1):     for j in range(1,w-1):         center = img[i][j]         code = 0                   code |= (img[i-1][j-1] &gt;= center) &lt;&lt; (np.uint8)(7)           code |= (img[i-1][j  ] &gt;= center) &lt;&lt; (np.uint8)(6)           code |= (img[i-1][j+1] &gt;= center) &lt;&lt; (np.uint8)(5)           code |= (img[i  ][j+1] &gt;= center) &lt;&lt; (np.uint8)(4)           code |= (img[i+1][j+1] &gt;= center) &lt;&lt; (np.uint8)(3)           code |= (img[i+1][j  ] &gt;= center) &lt;&lt; (np.uint8)(2)           code |= (img[i+1][j-1] &gt;= center) &lt;&lt; (np.uint8)(1)           code |= (img[i  ][j-1] &gt;= center) &lt;&lt; (np.uint8)(0)           dst[i-1][j-1]= code return dst\n\nmobilnetv2和v1\n\n参数量和计算量\n\n\n\n如何解决目标检测中的物体尺度大小不一的问题\n\n多尺度的特征融合\nFPN SSD\n\npython 复制文件\n\nshutil.copyfile(old_name, new_name)shutil.copyfile(old_name, new_name)\n\npooling的反向传播\n\n在看卷积神经网络的时候，突然想起来池化是会改变特征图的尺寸的，那反向传播是怎么实现的呢。于是搜了一些博客，感觉上面这个博客写得最清晰直观，就从这个博客里面搬了点东西过来作为笔记。\nPooling 池化操作的反向梯度传播\nCNN 网络中另外一个不可导的环节就是 Pooling 池化操作，因为 Pooling 操作使得 feature map 的尺寸变化，假如做 2×2 的池化，假设那么第 l+1 层的 feature map 有 16 个梯度，那么第 l 层就会有 64 个梯度，这使得梯度无法对位的进行传播下去。其实解决这个问题的思想也很简单，就是把 1 个像素的梯度传递给 4 个像素，但是需要保证传递的 loss（或者梯度）总和不变。根据这条原则，mean pooling 和 max pooling 的反向传播也是不同的。\n1、mean pooling\nmean pooling 的前向传播就是把一个 patch 中的值求取平均来做 pooling，那么反向传播的过程也就是把某个元素的梯度等分为 n 份分配给前一层，这样就保证池化前后的梯度（残差）之和保持不变，还是比较理解的，图示如下 ：\n\nmean pooling 比较容易让人理解错的地方就是会简单的认为直接把梯度复制 N 遍之后直接反向传播回去，但是这样会造成 loss 之和变为原来的 N 倍，网络是会产生梯度爆炸的。\n2、max pooling\nmax pooling 也要满足梯度之和不变的原则，max pooling 的前向传播是把 patch 中最大的值传递给后一层，而其他像素的值直接被舍弃掉。那么反向传播也就是把梯度直接传给前一层某一个像素，而其他像素不接受梯度，也就是为 0。所以 max pooling 操作和 mean pooling 操作不同点在于需要记录下池化操作时到底哪个像素的值是最大，也就是 max id，这个变量就是记录最大值所在位置的，因为在反向传播中要用到，那么假设前向传播和反向传播的过程就如下图所示 ：\n\n\n网格最短距离\n\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明：每次只能向下或者向右移动一步。\n示例:\n输入:\n[\n[1,3,1],\n[1,5,1],\n[4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\ndef minPath(matrix):  if not matrix or not matrix[0]:    return 0  dp = [[0]*len(matrix[0]) for i in range(len(matrix))]  for i in range(len(dp)):    for j in range(len(dp[0])):      if i == j == 0:        dp[i][j] = matrix[0][0]      elif i == 0:        dp[i][j] = matrix[i][j-1] + matrix[i][j]      elif j == 0:        dp[i][j] = matrix[i-1][j] + matrix[i][j]      else:        dp[i][j] = min(matrix[i-1][j], matrix[i][j-1]) + matrix[i][j]  return dp[len(matrix)-1][len(matrix[0])-1]\n\nnumpy实现CNN\n给一组数字添加正负号使他们的和为0\n\nhttps://leetcode.com/problems/target-sum/\nclass Solution:    def findTargetSumWays(self, nums: List[int], S: int) -&gt; int:        self.ans = 0        self.helper(nums, 0, 0, S)        return self.ans        def helper(self, nums, total, start, S):        if start == len(nums) and total == S:            self.ans += 1        elif start &lt; len(nums):            self.helper(nums, total+nums[start], start+1, S)            self.helper(nums, total-nums[start], start+1, S)™2\nclass Solution(object):    def findTargetSumWays(self, nums, S):        &quot;&quot;&quot;        :type nums: List[int]        :type S: int        :rtype: int        &quot;&quot;&quot;        if not nums or sum(nums) &lt; S or (sum(nums)+S) % 2 == 1:            return 0        target = (sum(nums)+S)//2        dp = [0]*(target+1)        dp[0] = 1        for n in nums:            for i in range(target, n-1, -1):                dp[i] = dp[i] + dp[i-n]        return dp[-1]\n\nGAN的损失函数\nBN的数学形式\n主流的网络\npython实现判断回文（找最优做法）\n\na == a[::-1]\n\npython扩展维度\n导数和偏导的区别\n\n导数和偏导没有本质区别,都是当自变量的变化量趋于0时，函数值的变化量与自变量变化量比值的极限。\n\n\n一元函数，一个y对应一个x，导数只有一个\n\n\n二元函数，一个z对应一个x和一个y，那就有两个导数了，一个是z对x的导数，一个是z对y的导数,称之为偏导。\n\n\n一、导数第一定义\n设函数 $y = f(x)$ 在点 $x_0$ 的某个邻域内有定义当自变量$x$在$ x_0$ 处有增量$\\Delta x$ ($ x0 + △x$ 也在该邻域内 ) 时相应地函数取得增量 $△y = f(x0 + △x) - f(x0)$ 如果 $△y 与 △x 之比当 △x→0 时极限存在则称函数 y = f(x) 在点 x0 处可导并称这个极限值为函数 y = f(x) 在点 x0 处的导数记为 f’(x0) ,即导数第一定义\n二、导数第二定义\n设函数 y = f(x) 在点 x0 的某个邻域内有定义当自变量x 在 x0 处有变化 △x ( x - x0 也在该邻域内 ) 时相应地函数变化 △y = f(x) - f(x0) 如果 △y 与 △x 之比当 △x→0 时极限存在则称函数 y = f(x) 在点 x0 处可导并称这个极限值为函数 y = f(x) 在点 x0 处的导数记为 f’(x0) ,即导数第二定义\n\npytorch定义标量，向量，矩阵以及张量\n激活函数的作用\n防止过拟合\n如何处理大小不同的图片输入（全卷积网络）\n常用的损失函数\n常见的GAN\n如何检测小物体等\npython深拷贝和浅拷贝的区别\npytorch实现CNN\npytorch中类的构造\nPytorch 显存控制\n\n\n\n降低计算的精度，比如float32 变为float16。这个是一个大杀器，基本上有减少内存尤其是显存消耗的模型，都可以这么做，我个人的经验是在CNN图像处理领域，这么做不会带来显著的模型质量的下降。\n\n\n分清楚eval 和 requires_grad = False。\n对于不需要bp的forward，如validation 请使用 torch.no_grad , 注意model.eval() 不等于 torch.no_grad()\n\n\n使用torch.cuda.empty_cache()\n在确定的地方释放显存\n\n\n\nlinux中找到正在运行的某个进程，查看显存，杀死进程等\n\n查看进程：ps\n查看现存：nvidia-smi\n杀死进程：kill\n\n旷视数学题：x，y服从0-1之间的均匀分布，求z=max(x,y)的数学期望\n\n\n\n字节跳动一面只有代码题：将数组分成m段求各段和的最大值最小是多少（动态规划或者二分）\n\n\n假设数组分为一段，此时的最大值为t = sum(nums)，得到新的t，此时，按个个分组和小于t进行划分，看一共能够分多少个组，如果分的组数小于m，则说明肯定可以。\n\n一张图片多个类别怎么设计损失函数，多标签分类问题\n\n\\5. SVM、决策树优缺点，非线性回归用什么方法，L1、L2 正则化区别\n\\6. 链表归并快排 LeetCode 148——排序链表\n\\7. 反转链表 LeetCode 206——反转链表\n骰子掷出 1-7 的均匀分布\n\n第一次掷骰子的点数为 $X1 X_1 X1$，第二次掷骰子的点数为 X2X_2X2，如果X1=X2=6X_1=X_2=6X1=X2=6，则重掷，令\n$$\nX=((X1−1)∗6+X2)X =((X_1-1)*6 + X_2) % 7X=((X1−1)∗6+X2)\n$$\n，则 XXX 即为取值范围为 1-7 的均匀分布\n\nResNet 的特点\n\n引入跳跃连接，有效地解决了网络过深时候梯度消失的问题，使得设计更深层次的网络变得可行。\n\n用 BN 没有，BN 有啥优点，这里问各种细节\n\n详见论文阅读笔记 Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift\n\n怎么求一个三角形外接圆，\n\n三条边垂直平分线的交点即为圆心，圆心到顶点的距离为半径\n\n什么是 one-shot、zero-shot，区别\n\nzero-shot 就是说测试集中的类别都是训练集中没有见到的；\none-shot 就是说测试集中的类别在训练集中很少或者只能见到一次\n\n梯度下降法和牛顿法区别\n\n梯度下降法：利用一阶导数\n牛顿法：利用二阶导数，收敛速度快；但对目标函数有严格要求，必须有连续的一、二阶偏导数，计算量大\n\nAdam 和 SGD 区别，RMSProp 优化算法\n\n\nRNN 怎么反向传播`\n\n\nSVM 的损失函数，特点，对偶问题求解，用朗格朗日乘子法将有约束优化转化为无约束优化，   直观解释一下拉格朗日乘子法\n\n\n给定一个 [0, 1] 的均匀分布，求圆周率\n\n用这个分布产生一个坐标 (x,y)(x, y)(x,y)，则这些点均匀分布在一个边长为 1 的正方形内，如下图所示。由几何概率可知，落在四分之一圆内的概率为 P=π4P = \\frac{\\pi}{4}P=4π，因此我们只需统计出所有点里面落在圆内的点数即可估计出圆周率。\n\n\n\\12. 编程求数组中的 Top K 大的数 LeetCode 215——数组中的第 K 个最大元素\n1、目标检测项目\n\n阀值是怎么选取的？取多少？答：０.75\n阀值的实际意义是什么？答：IOU 值，然后仔细解释\n如果预测出的框过多了怎么办？答：调整 IOU 阀值，然后解释\nFPN 在网络中是怎么加的\nResNet-50 的选用，因为背景比较单一，没有必要选取更深的网络\n\n２、常规深度学习问题\n\nBN 和 L2 正则化\n哪些原因会导致梯度消失。答：网络深度、激活函数\n\n３、编程题：\n\n判断两个链表是否相交。\n求一个数列中两个元素的最大和，找到这个两个元素。（Top K 问题）\n\n二面\n\n为什么项目中用 Faster R-CNN+FPN，Faster 和 YOLO 对比；为什么叫单步法，两步法？\nR-CNN系列：R-CNN，Fast R-CNN，Fast R-CNN。大概说了一下每代改进。又问了RPN网络。\nC++，问了 map 等是用什么实现的。答：红黑树。（面试官：好了，我也不问你红黑树了），那你在想想还有其他实现的方法吗？平衡二叉树，差不多说了一下。可能是跳表？数据结构和算法之——跳表\nSTL 中 vector 是怎么实现的？我答了用数组实现，然后常数时间访问，内存分配。内存不够在原有基础上扩大一倍分配。又问内存减小的时候是怎么做的，我懵逼了。\n问堆和栈。我不太会堆，忘记了。然后说了说栈的特点，怎么用的。又问了一下，在计算机系统中，栈有哪些用处，具体解释了一下。我说了线程和进程。堆和堆排序、堆的应用、数据结构之——栈\nLinux的一些常用命令：我说了几个。他又问怎么按时间顺序打印出文件列表，按文件大小打印文件列表\n编程：两个字符串序列的最长公共子序列。动态规划经典题目\n开放问题：让我设计神经网络模型（由于硬件限制，Faster 这种网络不让用）\n数据：许多图片，这些图片是由很多网络分割的，就像棋盘一样。每一个格子中可能存在一条小斜线（因为是直线，所以实际由两个端点就可以确定）。要求设计一个网络来检测出这张图片中的这些小短线。\n要求：自己定义图片的尺寸，网络的模型，loss，评价指标。问的比较细，每一步的实现细节，整得我一愣一愣的。\ncaffe 实现一种新的自定义网络\n\n","tags":["面试","概率"]}]