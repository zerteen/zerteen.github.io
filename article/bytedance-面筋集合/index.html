<!DOCTYPE html>
<html lang="null">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="z">
    
    <title>
        
            bytedance 面筋集合 |
        
        ffgw
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"zerteen.github.io","root":"/","language":null,"path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                ffgw
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                LINKS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">LINKS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">bytedance 面筋集合</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">z</span>
                        
                            <span class="author-label">Lv7</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2019-08-29 13:56:08
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>18.6k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>71 Mins</span>
        </span>
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>提前批的，面试拖了好久，今天刚面完交叉面，虽然还没有意向书，也先发下面经，回馈下牛友</p>
<p>面的是上海的ailab</p>
<p>一面</p>
<p>1、上来直接问论文，他基本上没有问啥细节，主要是我在讲</p>
<p>2、一道算法题</p>
<p>稀疏向量的点乘 要求：尽量高效地实现，需要同时考虑时空复杂度。</p>
<p>代码是当时写的，不一定bug free</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="comment">#include &lt;iostream&gt;``using` `namespace` `std;``struct` `Node&#123;``    ``int` `index;``    ``int` `value;``&#125;;` `int` `func(Node[] v1, Node[] v2)&#123;``    ``int` `p1 = 0, p2 = 0;``    ``int` `ret = 0;``    ``int` `len1 = ``sizeof``(v1) / ``sizeof``(Node);``    ``int` `len2 = ``sizeof``(v2) / ``sizeof``(Node)；``    ``while``(p1&lt;len1 &amp;&amp; p2&lt;len2)&#123;``        ``int` `index1 = v1[p1].index, index2 = v2[p2].index;``        ``if``(index1 == index2)&#123;``            ``ret += v1[p1].value * v2[p2].value;``            ``p1++;``            ``p2++;``        ``&#125;``else` `if` `(index1 &lt; index2)&#123;``            ``p1++;``        ``&#125;``else``&#123;``            ``p2++;``        ``&#125;``    ``&#125;``    ``return` `ret;``&#125;` `int` `main() &#123;``    ``cout &lt;&lt; ``&quot;Hello World!&quot;` `&lt;&lt; endl;``&#125;`</span></span><br></pre></td></tr></table></figure>
<p>二面</p>
<p>1、先问项目的一些细节</p>
<p>2、深度学些基础</p>
<p><strong>smoothL1</strong><br>
$$<br>
\operatorname{smooth}<em>{L</em>{1}}(x)=\left{\begin{array}{ll}{0.5 x^{2}} &amp; {\text { if }|x|&lt;1} \ {|x|-0.5} &amp; {\text { otherwise }}\end{array}\right.<br>
$$</p>
<ul>
<li>相比于L1损失函数，可以收敛得更快。</li>
<li>相比于L2损失函数，对离群点、异常值不敏感，梯度变化相对更小，训练时不容易跑飞。</li>
</ul>
<blockquote>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-085140.png" alt="image-20190829165140414"></p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-085207.png" alt="image-20190829165206975"></p>
</blockquote>
<p><strong>fpn的结构</strong></p>
<p>特征金字塔是处理<strong>多尺度物体检测</strong>问题的一个基础组成部分。然而，最近基于深度学习的物体检测算法考虑到计算量和内存限制都尽量避免采用特征金字塔的方式。在这篇文章中，<strong>利用深度卷积网络本身固有的多尺度、层次结构来构造特征金字塔</strong>，它的好处是只会带来极小的额外消耗。具体的，本文构造了一种自顶向下、带有侧向连接的层次结构来构建各个尺度的高层语义特征。这种方法称之为Feature Pyramid Network (FPN)。FPN可以作为一种通用的特征提取器，并且在多个任务上带来了显著的性能提升。将FPN应用于Faster RCNN，在COCO上达到了最佳的单模型性能。另外，FPN的推理速度在GPU上可以达到5FPS，因此是一种检测性能高，同时推理速度能达到实际使用的方法。</p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-090209.png" alt="image-20190829170208782"></p>
<p><strong>roi pooling和roi align的区别</strong></p>
<blockquote>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-121729.png" alt="image-20190829201728367"></p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-121750.png" alt="image-20190829201749609"></p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-121835.png" alt="image-20190829201835211"><br>
<img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-121858.png" alt="image-20190829201857655"></p>
</blockquote>
<p>3、数据结构基础</p>
<p>链表判断是否有环</p>
<p>归并排序描述</p>
<p>二叉排序树时间复杂度</p>
<blockquote>
<p>如果二叉排序树是平衡的，则n个节点的二叉排序树的高度为Log2n+1,其查找效率为O(Log2n)，近似于折半查找。如果二叉排序树完全不平衡，则其深度可达到n，查找效率为O(n)，退化为顺序查找。一般的，二叉排序树的查找性能在O(Log2n)到O(n)之间。因此，为了获得较好的查找性能，就要构造一棵平衡的二叉排序树。</p>
</blockquote>
<p>4、算法题</p>
<p>leetcode958  判断是否是完全二叉树</p>
<p>三面</p>
<p>1、问比赛，主要是我在介绍</p>
<p>2、介绍下cascade rcnn</p>
<p>3、算法题</p>
<p>leetcode3 最长不重复子串</p>
<p>交叉面</p>
<p>1、论文讲下，没有提问题</p>
<p>2、RPN介绍一下</p>
<p>![image-20190829204113463](/Users/xiongz/Library/Application Support/typora-user-images/image-20190829204113463.png)</p>
<p>![image-20190829204039728](/Users/xiongz/Library/Application Support/typora-user-images/image-20190829204039728.png)</p>
<p>3、inception介绍一下</p>
<p>4、depthwise 卷积</p>
<p>5、shufflenet</p>
<hr>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-055949.png" alt="image-20190829135948996"></p>
<hr>
<ul>
<li>对分类，分割检测，视频理解哪方面比较熟悉？</li>
</ul>
<p>答：对分类，分割比较熟悉</p>
<ul>
<li>
<p>那我们问一下检测方面的问题吧（我：？？？），你了解faster rcnn吗，大致介绍一下</p>
</li>
<li>
<p>再问一个分割检测方面的，了解nms吗，大致介绍一下</p>
</li>
<li>
<blockquote>
<p>同一个人可能有好几个框(每一个框都带有一个分类器得分)</p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-30-010938.png" alt="image-20190830090937922"></p>
<p>而我们的目标是一个人只保留一个最优的框：</p>
<p>于是我们就要用到非极大值抑制，来抑制那些冗余的框： 抑制的过程是一个迭代-遍历-消除的过程。</p>
<p>（1）将所有框的得分排序，选中最高分及其对应的框：</p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-30-011006.png" alt="image-20190830091004665"></p>
<p>（2）遍历其余的框，如果和当前最高分框的重叠面积(IOU)大于一定阈值，我们就将框删除。</p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-30-011023.png" alt="image-20190830091023734"></p>
<p>（3）从未处理的框中继续选一个得分最高的，重复上述过程。</p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-30-011908.png" alt="image-20190830091042736"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">py_cpu_nms</span>(<span class="params">dets, thresh</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Pure Python NMS baseline.&quot;&quot;&quot;</span></span><br><span class="line">    x1 = dets[:, <span class="number">0</span>]</span><br><span class="line">    y1 = dets[:, <span class="number">1</span>]</span><br><span class="line">    x2 = dets[:, <span class="number">2</span>]</span><br><span class="line">    y2 = dets[:, <span class="number">3</span>]</span><br><span class="line">    scores = dets[:, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    areas = (x2 - x1 + <span class="number">1</span>) * (y2 - y1 + <span class="number">1</span>)</span><br><span class="line">    order = scores.argsort()[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    keep = []</span><br><span class="line">    <span class="keyword">while</span> order.size &gt; <span class="number">0</span>:</span><br><span class="line">        i = order[<span class="number">0</span>]</span><br><span class="line">        keep.append(i)</span><br><span class="line">        xx1 = np.maximum(x1[i], x1[order[<span class="number">1</span>:]])</span><br><span class="line">        yy1 = np.maximum(y1[i], y1[order[<span class="number">1</span>:]])</span><br><span class="line">        xx2 = np.minimum(x2[i], x2[order[<span class="number">1</span>:]])</span><br><span class="line">        yy2 = np.minimum(y2[i], y2[order[<span class="number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        w = np.maximum(<span class="number">0.0</span>, xx2 - xx1 + <span class="number">1</span>)</span><br><span class="line">        h = np.maximum(<span class="number">0.0</span>, yy2 - yy1 + <span class="number">1</span>)</span><br><span class="line">        inter = w * h</span><br><span class="line">        ovr = inter / (areas[i] + areas[order[<span class="number">1</span>:]] - inter)</span><br><span class="line"></span><br><span class="line">        inds = np.where(ovr &lt;= thresh)[<span class="number">0</span>]</span><br><span class="line">        order = order[inds + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keep</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>模型训练过拟合怎么办</p>
</li>
</ul>
<blockquote>
<ol>
<li>数据角度： 数据增强、增大数据量</li>
<li>模型角度：换简单的网络，更换backbone，添加dropout，添加BN</li>
<li>损失角度：添加正则项、加大正则项的权重</li>
</ol>
</blockquote>
<ul>
<li>BN为什么防止过拟合呢？</li>
</ul>
<blockquote>
<p>大概意思是：在训练中，BN的使用使得一个mini-batch中的所有样本都被关联在了一起，因此网络不会从某一个训练样本中生成确定的结果。</p>
<p>意思就是同样一个样本的输出不再仅仅取决于样本本身，也取决于跟这个样本属于同一个mini-batch的其它样本。同一个样本跟不同的样本组成一个mini-batch，它们的输出是不同的（仅限于训练阶段，在inference阶段是没有这种情况的）。我把这个理解成一种数据增强：同样一个样本在超平面上被拉扯，每次拉扯的方向的大小均有不同。不同于数据增强的是，这种拉扯是贯穿数据流过神经网络的整个过程的，意味着神经网络每一层的输入都被数据增强处理了。</p>
</blockquote>
<p>但是我回答的是BN为啥work的原因</p>
<blockquote>
<p>包括BN原论文解释的改善ICS现象，但是今年年初MIT的一篇论文《How Does Batch Normalizetion Help Optimization》推翻了这个结论，该论文认为</p>
<ol>
<li>BN带来的性能提升与ICS的减少无关。 并且在一定程度上认为BN并不能减少 ICS。</li>
<li>发现了BN使得优化问题的曲面更加平滑，这使得梯度更容易预测以及允许更大范围的学习率和更快的网络vonvergence。证明了BN提升了模型的LOSS的Lipschitzness和梯度的Lipschitzness（β-smoothness）。**换个说法：**引入了 BN 后，损失函数相对于激活函数值的梯度幅值更小，也即损失函数更加利普希兹。损失函数相对于激活函数值的二阶项幅值更小，也即损失函数更加贝塔平滑。同理，损失函数相对于权重的梯度幅值也更小。 权重的最优解与初始解的距离也更小，也即神经网络更快就可以训练到最佳表现。（参考：<a class="link" target="_blank" rel="noopener" href="https://www.zhihu.com/collection/226366658?page=4%EF%BC%89">https://www.zhihu.com/collection/226366658?page=4）<i class="fas fa-external-link-alt"></i></a></li>
<li>提出了除了BN外，还有其他方式同样可以达到类似平滑效应，有些甚至效果更好。</li>
</ol>
</blockquote>
<p>算法题：判断一棵树是不是完全二叉树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#File Name : 是否为完全二叉树.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,val=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isCBT</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    isLeaf = <span class="literal">False</span></span><br><span class="line">    queue = [head]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        head = queue.pop(<span class="number">0</span>)</span><br><span class="line">        left = head.left</span><br><span class="line">        right = head.right</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> left <span class="keyword">and</span> right) <span class="keyword">or</span> (isLeaf <span class="keyword">and</span> (left <span class="keyword">or</span> right)):</span><br><span class="line">            <span class="comment"># （not left） and  right 右边存在 左边不存在</span></span><br><span class="line">            <span class="comment">#  或者是进入到全是叶节点状态后 有左或者右</span></span><br><span class="line">            <span class="comment"># 这两种情况都会返回F</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            queue.append(left)</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            queue.append(right)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">            isLeaf = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>问：AI lab业务偏多还是research偏多 面试官说：都会做，比较好的一点就是公司大中台战略，本身公司的业务场景就很多，所以有很多落地的工作可以做</p>
<p>问：AI lab的扩招情况，发展态势？AI lab的规模？</p>
<ul>
<li>你投的哪个城市，我是目前在上海工作，如果你有兴趣的话可以到上海来</li>
</ul>
<h1 id="二面-视频面60min2019717">二面 视频面（60min）2019/7/17</h1>
<p>自我介绍</p>
<p>实习的工作是如何改进的</p>
<p>为什么不用L1而用L2loss监督</p>
<p>sobel算子介绍一下</p>
<p>sobel核的参数为什么里面-1 -2，改变了参数后会发生什么事情？</p>
<p>面试官本身是想让我回答不同的参数就能实现不同的功能效果，例如高斯模糊，腐蚀，锐化，膨胀等等</p>
<p>讲一下Focal loss，它解决了一个什么东西？如何解决的?</p>
<blockquote>
<p>解决正负样本不均衡的问题：</p>
<p>Focal Loss：</p>
<p>在onestage的网络中，正负样本达到1:1000，这就会出现两个问题：1.样本不平衡   2.负样本主导loss。虽然负样本的loss小（因为大量的负样本是easy example，大量负样本是准确率很高的第0类），但个数众多，加起来的loss甚至大于了正样本的loss<br>
$$<br>
\mathrm{FL}\left(p_{\mathrm{t}}\right)=-\alpha_{\mathrm{t}}\left(1-p_{\mathrm{t}}\right)^{\gamma} \log \left(p_{\mathrm{t}}\right)<br>
$$</p>
<p>focal loss先解决了样本不平衡的问题，即在CE上加权重，当class为1的时候，乘以权重$\alpha$，当class为0的时候，乘以权重$1-\alpha$，这是最基本的解决样本不平衡的方法，也就是在loss计算时乘以权重。注意下面的图：$\alpha$下面有个坐标t，也就是说$\alpha$针对不同类别，值并不一样</p>
<p>实际上就是在CE前加了一个$(1-p_t)^\gamma$，也就是说，如果你的准确率越高，$\gamma$ 次方的值越小，整个loss的值也就越小。也就是说，$\gamma $ 次方就是用来衰减的，准确率越高的样本衰减越多，越低的衰减的越少，这样整个loss就是由准确率较低的样本主导了。对于onestage的网络，loss由负样本主导，但这些负样本大多是准确率很高的，经过focal loss后就变成了正负样本共同主导，或者说是概率低的主导。这一点和ohem很像，ohem是让loss大的进行训练。</p>
<p>OHEM：</p>
<blockquote>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-30-020938.png" alt="image-20190830100938528"></p>
<p>从图中可以看出，本文的亮点在于在每次迭代中，较少训练样本下，如何hard negative mining，来提升效果。即针对Fast-RCNN框架，在每次minibatch（1张或者2张）训练时加入在线筛选hard region的策略，达到新的SoA。需要注意的是，这个OHEM适合于batch size（images）较少，但每张image的examples很多的情况。（thousands of candidate examples，这里的example可以理解为instance、region或者proposal）  这是一次ML经典算法bootstrapping在DL中的完美“嵌入”。</p>
<p>具体来说：</p>
<p>1 将Fast RCNN分成两个components：ConvNet和RoINet. ConvNet为共享的底层卷积层，RoINet为RoI Pooling后的层，包括全连接层；</p>
<p>2 对于每张输入图像，经前向传播，用ConvNet获得feature maps（这里为RoI Pooling层的输入）；</p>
<p>3 将事先计算好的proposals，经RoI Pooling层投影到feature maps上，获取固定的特征输出作为全连接层的输入；需要注意的是，论文说，为了减少显存以及后向传播的时间，这里的RoINet是有两个的，它们共享权重，RoINet1是只读（只进行forward），RoINet2进行forward和backward：<br>
	a 将原图的所有props扔到RoINet1，计算它们的loss（这里有两个loss：cls和det）；<br>
	b 根据loss从高到低排序，以及利用NMS，来选出前K个props（K由论文里的N和B参数决定）<br>
		为什么要用NMS? 显然对于那些高度overlap的props经RoI的投影后，<br>
		其在feature maps上的位置和大小是差不多一样的，容易导致loss double counting问题<br>
	c 将选出的K个props（可以理解成hard examples）扔到RoINet2，<br>
	这时的RoINet2和Fast RCNN的RoINet一样，计算K个props的loss，并回传梯度/残差给ConvNet，来更新整个网络<br>
	论文提及到可以用一种简单的方式来完成hard mining：<br>
	在原有的Fast-RCNN里的loss layer里面对所有的props计算其loss，根据loss对其进行排序，（这里可以选用NMS），选出K个hard examples（即props），反向传播时，只对这K个props的梯度/残差回传，而其他的props的梯度/残差设为0即可。由于这样做，容易导致显存显著增加，迭代时间增加，这对显卡容量少的童鞋来说，简直是噩梦。<br>
	为什么说是online？<br>
	论文的任务是region-based object detection，其examples是对props来说的，即使每次迭代的图像数为1，它的props还是会很多，即使hard mining后<br>
	为什么要hard mining：<br>
	1 减少fg和bg的ratio，而且不需要人为设计这个ratio；<br>
	2 加速收敛，减少显存需要这些硬件的条件依赖；<br>
	3 hard mining已经证实了是一种booststrapping的方式， 尤其当数据集较大而且较难的时候；<br>
	4 eliminates several heuristics and hyperparameters in common use by automatically selecting hard examples, thus simplifying training。<br>
	放宽了定义negative example的bg_lo threshold，即从[0.1, 0.5)变化到[0, 0.5)。<br>
	取消了正负样本在mini-batch里的ratio（原Fast-RCNN的ratio为1:3）?</p>
</blockquote>
<ul>
<li>和难例挖掘OHEM有什么区别</li>
</ul>
<p>3:1是负样本比上正样本</p>
</blockquote>
<blockquote>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-060341.png" alt="img"></p>
</blockquote>
<ul>
<li>讲一下你熟悉的优化器，说一下区别或发展史</li>
</ul>
<p>答：只简单讲了adam和SGD，没复习到</p>
<p>具体参考https://www.cnblogs.com/ljygoodgoodstudydaydayup/p/7294671.html</p>
<ul>
<li>算法题：一个整数数组A，求Ai-Aj的最大值Max，i&lt;j，</li>
</ul>
<p>c++的解法及思路： <a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/fkyyly/article/details/83930343">https://blog.csdn.net/fkyyly/article/details/83930343<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def f(arr):</span><br><span class="line">    if len(arr)==0 or len(arr)==1:</span><br><span class="line">        return 0</span><br><span class="line">    if len(arr)==2:</span><br><span class="line">        return arr[0]-arr[1]</span><br><span class="line">    p1 = 0</span><br><span class="line">    p2 = 1</span><br><span class="line">    max = arr[p1]-arr[p2]</span><br><span class="line">    n = len(arr)</span><br><span class="line">    while p2&lt;n:</span><br><span class="line">        while p2&lt;n and arr[p2]&lt;arr[p1]:</span><br><span class="line">            if arr[p1]-arr[p2]&gt;max:</span><br><span class="line">                max = arr[p1]-arr[p2]</span><br><span class="line">            p2 += 1</span><br><span class="line"></span><br><span class="line">        p1 = p2</span><br><span class="line">        p2 += 1</span><br><span class="line">    return max</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度空间复杂度是多少</li>
</ul>
<p>答：<strong>O(n)，O(1)</strong></p>
<ul>
<li><strong>一个图片中心逆时针旋转30度后，求最小外接矩形长和宽，说一下有哪些解决方法</strong></li>
</ul>
<p><strong>答：第一种初中数学，几何知识；第二种，求解仿射变换矩阵（2x3），然后和原图相乘，就得到变换后的图片，也就知道了最小外接矩形的长和宽</strong></p>
<p><strong>具体参考</strong><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/flyyufenfei/article/details/80208361">https://blog.csdn.net/flyyufenfei/article/details/80208361<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>有什么想问的</li>
</ul>
<p>问：这个提前批的面试流程，有几面</p>
<p>答：至少三面，没面过的不影响正式秋招</p>
<p>问：老师您在公司做的什么方面呢</p>
<p>答：广告方面的图像，cv-ad</p>
<h1 id="三面-主管面-视频面-30min2019723">三面 主管面 视频面 （30min）2019/7/23</h1>
<ul>
<li>
<p>自我介绍</p>
</li>
<li>
<p>介绍一下简历上比赛经历</p>
</li>
<li>
<p>介绍一下简历上最有含金量的工作</p>
</li>
<li>
<p>1x1卷积的作用</p>
<blockquote>
<p>用来降维或者升维 （GoogLeNet、mobileNet）</p>
<p>增加非线性</p>
</blockquote>
</li>
<li>
<p>经典分类网络backbone</p>
</li>
<li>
<p>讲一下inception系列</p>
</li>
<li>
<p>经典分割网络</p>
</li>
<li>
<p>没有提问环节（感觉凉了呀）</p>
</li>
</ul>
<hr>
<p>编程题：</p>
<p>1.非递减数组中查询某个目标值出现个数。解法：二分查找左右边界。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">            right = mid</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> right == <span class="number">0</span> <span class="keyword">and</span> nums[<span class="number">0</span>] != target:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    a = left</span><br><span class="line">    </span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = (left+right+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left-a+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>2.leetcode 124 二叉树最大路径和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxpath</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">h</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = h(root.left)</span><br><span class="line">        right = h(root.right)</span><br><span class="line">        self.ans = <span class="built_in">max</span>(self.ans, root.val+left+right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, root.val + <span class="built_in">max</span>(left, right))</span><br><span class="line">	self.ans = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    h(root)</span><br><span class="line">    <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>
<p>概率题：一个圆上三个点，组成锐角三角形概率。现场没算出来。</p>
<blockquote>
<p>1/4</p>
</blockquote>
<ol>
<li>
<p>逻辑回归是什么？sigmoid的作用是什么？解释最大似然。先验概率与后验概率。</p>
<p>对于回归问题，可以使用一个线性回归模型来做$y = wx+b$，对于分类问题，就可以用一个函数将事数值的 $y$ 转换成成离散值1/0。sigmoid函数就可以实现将其转换为一个概率数值。<br>
$$<br>
sigmoid(z) = \frac{1}{1+e^{-z}}<br>
$$</p>
<p>$$<br>
p(Y=1|x) = \frac{1}{1+e^{-wx+b}} \<br>
p(Y=0|x) = 1 - p(Y=1|x)<br>
$$</p>
<p>最大似然估计</p>
<p>模型的参数是未知的，但是是客观存在的一个定值。MLE是通过采样来估计概率分布参数的方法。</p>
<p>假设有训练集合D，$D_c$ 是这个训练集合中的c个样本组成的集合。那么参数$\theta_c$对于数据集合$D_c$ 的似然是</p>
<p>$P(D_c|\theta_c) = \Pi_{x\in D_c} P(x|\theta_c)$</p>
<p>简单的来讲，极大似然估计就是在所有的$\theta$中找到使得所有可能出现的值出现的可能性最大。</p>
<p>先验</p>
<p>$p(c|x)$</p>
<p>$p©$ 先验</p>
<p>$p(x|c)$ 后验概率</p>
</li>
<li>
<p>决策树分裂节点的标准与对应的算法。gbdt的gb是什么意思，如何体现。bagging与boosting的区别。gbdt里如何知道每个特征的重要性。</p>
<blockquote>
<p>ID3 --&gt; 信息增益</p>
<p>C4.5 --&gt; 信息增益比</p>
<p>GB  梯度提升</p>
<p>GBDT（Gradient Boosting Decison Tree）中的树都是回归树，GBDT用来做回归预测，调整后也可以用于分类（设定阈值，大于阈值为正例，反之为负例），可以发现多种有区分性的特征以及特征组合。GBDT是把所有树的结论累加起来做最终结论的，GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差(负梯度)，这个残差就是一个加预测值后能得真实值的累加量。比如A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学。 Boosting的最大好处在于，每一步的残差计算其实变相地增大了分错instance的权重，而已经分对的instance则都趋向于0。这样后面的树就能越来越专注那些前面被分错的instance。</p>
<p>缺点:Boost是一个串行过程，不好并行化，而且计算复杂度高，同时不太适合高维稀疏特征</p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-30-082016.png" alt="image-20190830162016665"></p>
</blockquote>
<blockquote>
<p>取样方式（样本权重）</p>
<p>Bagging是均匀选取，样本的权重相等</p>
<p>Boosting根据错误率取样，错误率越大则权重越大</p>
<p>Bagging随机选择训练集，训练集之间相互独立</p>
<p>Boosting的各轮训练集的选择与前面各轮的学习结果有关</p>
<p>Bagging各个预测函数没有权重，可以并行生成，</p>
<p>Boosting有权重，顺序生成</p>
<p>Bagging是减少variance</p>
<p>Boosting是减少bias</p>
<p>Bagging 是 Bootstrap Aggregating的简称，意思就是再取样 (Bootstrap) 然后在每个样本上训练出来的模型取平均，所以是降低模型的 variance.<br>
Boosting 则是迭代算法，每一次迭代都根据上一次迭代的预测结果对样本进行加权，所以随着迭代不不断进行，误差会越来越小，所以模型的 bias 会不不断降低。这种算法无法并行。</p>
</blockquote>
</li>
</ol>
<ol start="3">
<li>
<p>为什么svm的loss不能直接用梯度下降要用对偶？说说你知道的优化算法。</p>
<blockquote>
<p>核技巧应用到支持向量机，其基本想法就是通过一个非线性变换将输入空间</p>
<p>(欧氏空间 R n 或离散集合)对应于一个特征空间(希尔伯特空间  )，使得在输 入空间 R n 中的超曲面模型对应于特征空间  中的超平面模型(支持向量机).这 样，分类问题的学习任务通过在特征空间中求解线性支持向量机就可以完成</p>
<p>核函数K(x,z)给定的条件下，可以利用解线性分类问题的方法 求解非线性分类问题的支持向量机.学习是隐式地在特征空间进行的，不需要显 式地定义特征空间和映射函数.这样的技巧称为核技巧，它是巧妙地利用线性分 类学习方法与核函数解决非线性问题的技术.在实际应用中，往往依赖领域知识 直接选择核函数，核函数选择的有效性需要通过实验验证</p>
</blockquote>
</li>
<li>
<p>优化方法</p>
<blockquote>
<p>1、梯度下降法</p>
<p>梯度下降法是最早最简单的，也是最为常用的最优化算法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度未必是最快的。梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为“最速下降法”。最速下降法越接近目标值，步长越小，前进越慢。</p>
<p>在机器学习中，基于基本的梯度下降法发展了两种梯度下降方法，分别为随即梯度下降法和批量梯度下降法。</p>
<p>批量梯度下降：最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。</p>
<p>随机梯度下降法：最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向，但是大的整体的方向是向着全局最优解，最终的结果往往是在全局最优解附近，使用于大规模训练样本情况。</p>
<p>2、牛顿和拟牛顿法</p>
<p>从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法更快。如果更通俗得到说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前的位置选一个坡度最大的方向走一步，牛牛顿法在选择方向时，不仅会考虑坡度是否足够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说是牛顿法比梯度下降法看的更远一点，能更快地走到最底部。</p>
<p>优点：二阶收敛，收敛速度更快；</p>
<p>缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的hessian矩阵的逆矩阵，计算比较复杂。</p>
<p>拟牛顿法</p>
<p>拟牛顿法的基本思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺点，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。拟牛顿法和最速下降法一样只要每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优与最速下降法，尤其对于困难的问题，另外，因为拟牛顿法不需要二阶倒数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。</p>
<p>3、共轭梯度法</p>
<p>共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解决大型非线性最优化最有效的算法之一。在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有步收敛性，稳定性高，而且不需要任何外来参数。</p>
<p>4、启发式优化方法</p>
<p>启发式方法是指人在解决优化问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时，利用过去的经验，选择已经行之有效的方法，而不是系统地、以确定的步骤去寻求答案。启发式优化方法种类繁多，包括经典的模拟退火方法，遗传算法、蚁群算法以及粒子群算法等等。</p>
<p>还有一种特殊的优化算法被称之多目标优化算法，它主要针对同时优化多个目标（两个及两个以上）的优化问题，这方面比较经典的算法有NSGAII算法、MOEA/D算法以及人工免疫算法等。</p>
<p>5、EM算法</p>
<p>EM算法是一类算法的总称。EM算法分为E-step和M-step两步。EM算法的应用范围很广，基本机器学习需要迭代优化参数的模型在优化时都可以使用EM算法。</p>
<p>EM算法的思想和过程</p>
<p>E-step：E的全称是Exception，即期望的意思。E-step也是获取期望的过程。根据现有的模型，计算各个观测数据输入到模型中的结果。这个过程称为期望值计算过程，即E过程。</p>
<p>M-step：M的全称是Maximization，即最大化的意思。M-step也是期望最大化的过程。得到一轮期望值以后，重新计算模型参数，以最大化期望值。这个过程为最大化过程，即M过程。</p>
<p>最大化的意思是我们在使用这个模型时希望我们定义的函数能使得到的结果最大化，而结果越大越接近我们希望得到的结果。我们优化的目标也就是这些能得到最大值的函数。</p>
<p>常见的EM算法有：隐含马尔科夫模型的训练方法Baum-Welch算法；最大熵模型的训练方法GIS算法等。</p>
<p>EM算法结果</p>
<p>EM算法不一定能保证获得全局最优解，但如果我们优化的目标函数是一个凸函数，那么一定能保证得到全局最优解。否则可能获得局部最优解。因为如果优化的目标函数有多个峰值点，则如果优化到某个不是最高的峰值点处，则会无法再继续下去，这样获得的是局部最优解。</p>
<p>总结</p>
<p>EM算法只需要输入一些训练数据，同时定义一个最大化函数，接下来经过若干次迭代，就可以蓄念出我们需要的模型了</p>
</blockquote>
</li>
<li>
<p>PCA和LDA的区别</p>
<blockquote>
<p><a class="link" target="_blank" rel="noopener" href="https://www.jianshu.com/p/982c8f6760de">https://www.jianshu.com/p/982c8f6760de<i class="fas fa-external-link-alt"></i></a></p>
<p>PCA**</p>
<p>总结一下，我们就可以梳理出整一个PCA降维的流程，归纳如下，<br>
（1）样本去中心化<br>
（2）计算样本的协方差矩阵$XX^{T}$<br>
（3）对协方差矩阵做特征值分解<br>
（4）取最大的$d’$ 个特征值所对应的特征向量<br>
（5）计算投影矩阵</p>
<p><strong>LDA</strong></p>
<p>从降维的层面考虑，其也是在寻找一个投影矩阵，使得投影之后数据样本，同类的接近，而不同类的远离。</p>
<p>LDA的中心思想就是最大化类间距离以及最小化类内距离</p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-30-080519.png" alt="image-20190830160519429"></p>
<p>总结一下，我们就可以梳理出整一个LDA用于降维的流程，归纳如下，<br>
（1）计算每个类别的均值$\mu_i$，全局样本均值$\mu$<br>
（2）计算类内散度矩阵$S_w$，全局散度矩阵$S_t$，类间散度矩阵$S_b$<br>
（3）对矩阵$S_w^{-1}S_b$做特征值分解<br>
（4）取最大的$d^{’}$个特征值所对应的特征向量<br>
（5）计算投影矩阵</p>
<p><strong>比较</strong></p>
<ol>
<li>PCA为非监督降维，LDA为有监督降维</li>
<li>PCA希望投影后的数据方差尽可能的大（最大可分性），因为其假设方差越多，则所包含的信息越多；而LDA则希望投影后相同类别的组内方差小，而组间方差大。LDA能合理运用标签信息，使得投影后的维度具有判别性，不同类别的数据尽可能的分开。</li>
<li>举个简单的例子，在语音识别领域，如果单纯用PCA降维，则可能功能仅仅是过滤掉了噪声，还是无法很好的区别人声，但如果有标签识别，用LDA进行降维，则降维后的数据会使得每个人的声音都具有可分性，同样的原理也适用于脸部特征识别。所以，可以归纳总结为有标签就尽可能的利用标签的数据（LDA），而对于纯粹的非监督任务，则还是得用PCA进行数据降维。</li>
</ol>
</blockquote>
</li>
</ol>
<p>二面：</p>
<p>编程题：正则表达式匹配。剑指offer和leetcode都有。</p>
<p><code>.</code>可以匹配任意个前面的字符</p>
<p><code>+</code>可以匹配任意一个字符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">s, p</span>):</span></span><br><span class="line">    dp = [[<span class="literal">False</span>] * (<span class="built_in">len</span>(s)+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p)+<span class="number">1</span>):</span><br><span class="line">    	<span class="keyword">if</span> p[i-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> <span class="keyword">and</span> dp[i-<span class="number">2</span>][<span class="number">0</span>]:</span><br><span class="line">            dp[i] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[i-<span class="number">1</span>] == s[j-<span class="number">1</span>] <span class="keyword">or</span> p[i-<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> p[i-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> p[i-<span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">or</span> p[i-<span class="number">2</span>] == s[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">2</span>][j] <span class="keyword">or</span> dp[i-<span class="number">1</span>][j-<span class="number">1</span>] <span class="keyword">or</span> dp[i][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">2</span>][j]</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>概率题：真硬币m个，假币n个。假币只有正面。真币投掷正面概率为p。其中某硬币投掷k次都是正面，求它为真币概率。</p>
<p>知识点：</p>
<p>1.pooling是什么，有哪些作用。</p>
<p>2.梯度爆炸与消失产生原理与解决方法。</p>
<p>3.解决过拟合的方法有哪些。</p>
<p>4.输入特征归一化有哪些方式，有什么好处。svm需不需要？决策树需不需要？</p>
<blockquote>
<p>1,避免训练得到的模型权重过小,引起数值计算不稳定;</p>
<p>2,使参数优化时能以较快的速度收敛.</p>
<p>归一化时可以采用对应维度均值与方差.</p>
</blockquote>
<p>5.1x1卷积的作用。</p>
<blockquote>
<p>1x1 卷积在图像处理的角度，乍一看好像没什么意义，但在 CNN 网络中，能实现降维，减少 weights 参数数量，能够实现升维，来拓宽 feature maps，在不改变 feature maps 的 size 的前提下，实现各通道之间的线性组合，实际上是通道像素之间的线性组合，后接非线性的激活函数，增加更多样的非线性特征。这就是为什么 GoogLeNet 用 1x1 卷积来降维，减少了计算量，但模型效果却没有降低，此外网络深度更深。可以说 1x1 卷积很 nice.</p>
</blockquote>
<p>6.什么是特征向量与特征值。怎么理解它们代表的意义。</p>
<blockquote>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-31-163535.png" alt="image-20190901003535332"></p>
<p>特征值表示的是这个特征到底有多重要，而特征向量表示这个特征是什么，可以将每一个特征向量理解为一个线性的子空间</p>
</blockquote>
<p>7.知道什么是k-means？k-means是否一定收敛。</p>
<blockquote>
<p>k-means一定收敛</p>
</blockquote>
<p>8.tcp三次握手。</p>
<p>进程线程区别</p>
<blockquote>
<p>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p>
<p>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>
<p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p>
<p>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。<br>
进程是资源分配最小单位，线程是程序执行的最小单位；</p>
<p>进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，线程没有独立的地址空间，它使用相同的地址空间共享数据；</p>
<p>CPU切换一个线程比切换进程花费小；</p>
<p>创建一个线程比进程开销小；</p>
<p>线程占用的资源要⽐进程少很多。</p>
<p>线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行；（但多线程程序处理好同步与互斥是个难点）</p>
<p>多进程程序更安全，生命力更强，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）；</p>
<p>进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换；</p>
</blockquote>
<hr>
<p>先简短的自我介绍</p>
<p>​     1.数据不平衡问题的解决方法</p>
<p>​     2.如何修改根据样本的不均衡确定Loss的权重</p>
<p>​     3.介绍过采样和下采样的方法以及会遇到哪些潜在的问题</p>
<p>​     4.画出ROC曲线和PR曲线，并介绍二者的区别和应用场景</p>
<p>​     5.天平平衡问题(先放置一个质量为m的砝码，在从[1,2,4,8,16…,2^(n-1)]的砝码里挑选，使天平平衡)</p>
<blockquote>
<p>2 --&gt; 10</p>
<p>3 --&gt; 11</p>
</blockquote>
<p>​     6.IoU代码</p>
<p>二面:</p>
<p>​     面试官依旧很nice，人很好</p>
<p>​     自我介绍</p>
<p>​     1.介绍自己做过的项目，数据有没有进行预处理，用到哪些模型，什么框架，做了什么改进和提升（讲了2个）</p>
<p>​     2.Momentum、Adagrad、Adam、SGD、RMSPROP的原理和公式，以及各自的好处</p>
<p>​     3.卷积层、池化层相关原理和反向传播的过程</p>
<p>​     4.BatchNorm层的相关原理及好处</p>
<p>​     5.编程实现梯度下降逼近根号x，设计损失函数，模拟梯度下降的过程。</p>
<p>$y = \sqrt{x}$</p>
<p>​     <a class="link" target="_blank" rel="noopener" href="http://6.TF">6.TF<i class="fas fa-external-link-alt"></i></a>、pytorch框架相关</p>
<p>​     7.Mysql相关 答得不好。。 也没细问</p>
<p>三面：</p>
<p>​     自我介绍</p>
<p>​     1.重点介绍一个项目，是问的最细的（比如涉及到opencv 透视转换的原理，指出透视转换矩阵的作用），细到怀疑人生</p>
<p>​     2.写出Yolov3的损失函数</p>
<p>​     3.二元交叉熵如何解决多分类问题</p>
<p>​     4.写出Softmax、Sigmoid公式和交叉熵损失函数公式</p>
<p>​     5.ResNet为何设计残差结构以及如何解决梯度消失问题，需写公式证明</p>
<blockquote>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-31-162610.png" alt="image-20190901002609443"></p>
</blockquote>
<p>​     6.编程：编辑距离  leetcode原题</p>
<p>​     7.有没有想问面试官的问题</p>
<hr>
<p>面试内容:<br>
1.kaggle比赛:<br>
标签相关性分析，数据增强，特征融合不同方式及其优缺点，attention（channel和pixel<br>
两种方式的具体实现），2D CNN全套，损失函数该如何设计，fine grained有哪些解决方法<br>
2.常规目标检测<br>
发展过来的前世今生，yolo全套,ssd,faster rcnn具体细节，代码实现，工程中需要考虑的实际问题<br>
3.非常规目标检测<br>
RRPN，R2CNN（感觉面试官不是很了解这个方向，所以一直是我在说），还有我自己的框架<br>
4.anchor free框架<br>
基本思想，不同网络的具体对比，hourglass结构的好处，损失函数，我自己的框架具体结构，和sota比性能如何（map更高速度更快），新的损失函数为什么这么设计<br>
5.3D卷积<br>
和2D卷积的区别，主要存在问题，如何加速运算，视频理解的sota方法，还有什么方向可以改进<br>
6.某大型项目<br>
实施细节（面试官对这个很感兴趣），公然po到网上担心引起问题，故不详细展开<br>
7.算法题<br>
每一次面试都是我讲完论文项目实习，就快一个小时了，所以算法题也没怎么做比较难的，很快写完了。</p>
<p>总结:<br>
1.注重对sota方法的了解程度，需要大量看最新顶级的论文<br>
2.注重对具体问题的分析与解决，有的方法实际上项目的时候并不适用（考虑清楚为什么）<br>
3.注重原理的理解而不是方法看起来有多fancy，原理至上，所以一定要理解透彻。</p>
<hr>
<p>一面</p>
<p>项目</p>
<p>一个数字序列重排找比它大的下一个</p>
<p>两个智力题：抛硬币上下面概率不等，怎么制定规则使他公平</p>
<p>1000瓶药水 一瓶有毒 小白鼠喝了有毒的会有反应 十个小白鼠 怎么找到有毒的那瓶</p>
<blockquote>
<p>题目：1000 瓶无色无味的药水，其中有一瓶毒药，10只小白鼠拿过来做实验。喝了无毒的药水第二天没事儿，喝了有毒的药水后第二天会死亡。如何在一天之内(第二天)找出这瓶有毒的药水？</p>
<p>第一次看这个问题完全没思路，应该有很巧妙的解法吧，后来还是百度一下，才明白怎么回事。</p>
<p>思路就是用二进制，2^10=1024，也就是10只小白鼠最多能验出1024瓶药水，哪个有毒。小白鼠编号，1-10。瓶子也编号，1-1000，然后把瓶子的编号转变为二进制数。如果第几位是1，就把这瓶水给第几个小白鼠喝。最后大概每个小白鼠喝500瓶药水的混合液。如果还不懂，下面列几个数字解释一下。</p>
<p>瓶子编号 二进制数 第几个小白鼠喝</p>
<p>1 0000000001 1</p>
<p>2 0000000010 2</p>
<p>3 0000000011 1，2</p>
<p>4 0000000100 3</p>
<p>5 0000000101 1，3</p>
<p>大概就是这意思，再反过来，假如1号和3号小白鼠死了，死的小白鼠用1表示，再写成2进制数：0000000101，转化为十进制数是5，从上面列出来的也可以看出1，3都喝了5号瓶的水，所以就是第五瓶水有毒。</p>
<p>解决方案<br>
1）我们将1000瓶液体编号1~1000，然后将编号转化为10位二进制，如1号就是0000000001；<br>
2）将十只小白鼠编号1~10；<br>
3）将液体的二进制编号上为1的位数给对应的小白鼠喝，如液体编号为 1111100000，那就是1~5号小白鼠不喝这瓶液体，6~10号小白鼠喝这瓶液体；<br>
4）一星期后观察小白鼠的死亡情况，如果1~5号小白鼠死亡，6~10号小白鼠存活，那么有毒的那瓶液体对应的二进制编码为 0000011111；<br>
5）将第四步得到的二进制编码转化为十进制，这里是31号，因此我们可以推断出编号为31的液体是被污染的。</p>
</blockquote>
<p>问我有什么想问他的</p>
<p>我说你为什么不问我知识点</p>
<p>他说看以前记录问过了……就考察别的</p>
<p>原来头条会存档面试记录…</p>
<p>二面</p>
<p>项目 根据项目问了一些epoll 消息类型有哪几种</p>
<p>事件触发回掉函数是在tcp协议哪一步里（没懂</p>
<p>代码：五子棋 没棋子0 白棋1 黑旗-1 判断黑旗赢了没</p>
<p>三面</p>
<p>代码题</p>
<p>无序数组找中位数（用了部分快排 但是没调对</p>
<hr>
<p>一面：</p>
<p>\1. 讲实习做的检测的项目，讲ocr比赛的项目, 针对项目提了些问题</p>
<p>\3. BN层作用， dropout作用</p>
<p>\3. nms伪代码</p>
<p>\4. iou代码</p>
<p>\5. 最大不重复字串</p>
<p>\6. 单链表排序</p>
<p>二面：</p>
<p>\1. 讲实习做的检测的项目，Faster RCNN, RetinaNet, Yolo-v3在检测超小物体遇到的问题</p>
<p>\2. Yolov1-Yolov3改进区别，问的很细</p>
<p>\2. 元学习图像分类的过程，问为什么用validation的梯度更新模型就可以见效泛化误差，</p>
<p>这个没有细想过，答的不太好</p>
<p>\3. SGD的动量的作用，问为什么可以减小震荡，为什么震荡小就更容易收敛，</p>
<p>这个也答的不太好</p>
<p>\4. Adam说一下，估计梯度的一阶和二阶，然后用二阶估计来缩放每个位置的学习率，</p>
<p>问为什么可以对学习率缩放，从数值的角度答了一下</p>
<p>\5.  编程题: 从左到右增，从上到下增的矩阵查找，忘了考虑多个值的情况</p>
<p>三面：</p>
<p>\1. 讲元学习基于优化的方法是怎么做的，大概说了下自己做的工作</p>
<p>\2. 实习做的检测的项目，Retinanet和yolov3 anchor box的区别，yolo3里train有没有iout_thresh</p>
<p>\3. 01矩阵中1的最大连通面积</p>
<p>\4. 有多个高维向量，再新给一个如何快速查找相似的， 答了类原型，先哈希再比较</p>
<p>\5. 如何等概率产生半径为1的圆内坐标(x,y)， 就是拒绝采样</p>
<p>今天问hr, 说方向不太match，基本是挂了。</p>
<p>出的编程题都不难，基本10分钟内就写完了。感觉可能还是理解不够深入，原理性的东西答的不太好。</p>
<p>渣硕一个，之前看了些别人的面经，今天也写一个回馈一下社区。。。</p>
<p>感觉太难了，半个月前面了旷视研究员两面也没消息了，我决定秋招完2年内就转行，不干程序员了，立帖为证。</p>
<hr>
<p>作者：天才儿童<br>
<a class="link" target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/215883?type=post&amp;order=time&amp;pos=&amp;page=2&amp;subType=2%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%89%9B%E5%AE%A2%E7%BD%91">https://www.nowcoder.com/discuss/215883?type=post&amp;order=time&amp;pos=&amp;page=2&amp;subType=2来源：牛客网<i class="fas fa-external-link-alt"></i></a></p>
<p>1、算法题：n个人之间存在m个关系对，关系具有传递性，假如A关注B，B关注C，那么A就间接关注了C。如果一个人被除他之外的所有人都直接或间接关注，那么这个人就是抖音红人，求抖音红人的总数。</p>
<p>2、介绍一个你的项目。</p>
<p>3、特征选择有哪些方法（介绍项目时涉及到了特征相关性分析，因此问了这个）。</p>
<p>4、FM是否也能起到自动特征选择的作用，为什么。</p>
<p>5、GBDT的原理，和随机森林等算法做比较。</p>
<p>二面：</p>
<p>1、svm损失函数推导。</p>
<p>2、朴素贝叶斯写公式。</p>
<p>3、算法题：两个单链表找到第一个公共结点。</p>
<p>4、算法题：由0和1组成的二维矩阵，找出1的最大连通域，计算其面积。</p>
<p>三面：</p>
<p>1、算法题：长度为n的字符串中包含m个不同的字符，找出包含这m个不同字符的最小子串。</p>
<p>2、如果实现c++中的vector，只需push_back和查找两个功能，底层如何实现。</p>
<p>3、如果用数组实现，数组初始容量为n，每次push到容量上限之后都扩容到原来的两倍，现在push进去m个数，m远大于n，求相比于m的时间复杂度。</p>
<p>4、A和B比赛，A、B获胜的概率分别是0.6、0.4，如果你是A，3局2胜和5局3胜你会选择哪个。</p>
<p>5、如果A和B比赛无数局，A获胜的概率是多少。</p>
<p>6、有两张表，第一张表有n个专有名词，比如今日头条、抖音等，第二张表有m条query，比如今日头条是怎样的应用、有多少人喜欢刷抖音等，如何统计表1中所有名词在表2中出现的频次。</p>
<p>7、一个用户在搜索框输入query之后，如何知道他是否是在找视频。</p>
<p>8、如何计算一个微博账户的权威分数。</p>
<p>9、介绍一下xgboost有哪些特点。</p>
<p>10、xgboost和GBDT的分裂方式你认为哪个好。</p>
<p>四面：</p>
<p>1、c++中指针和引用的区别。</p>
<p>2、如何从用户态进入内核态。</p>
<p>3、非线性分类算法有哪些。</p>
<p>4、如何判断一个算法是线性的还是非线性的。</p>
<p>5、算法题：下一个全排列。</p>
<p>6、算法题：长度为n的数组中有一个数字出现了n/2次，快速找到这个数。</p>
<p>7、介绍一个你参加的比赛。</p>
<p>每一面之后都是在第二天就接到的下一面的预约电话。</p>
<p>前两面的算法题需要写出代码，但是不用过测试用例，三四面只用说思路。</p>
<p>28号下午第四面，今天晚上快7点的时候接到了offer call，通完电话后加了hr小姐姐微信之后给我发了意向书。（一开始是qq邮箱，结果qq邮箱居然把我的意向书拒收了，然后发了网易邮箱。。。）</p>
<p>当时在牛客上面找的前辈内推，记得推的是广告系统，今天告诉我给我分配到了搜索团队，四面的面试官就是我的leader。（在这里非常感谢牛客内推的前辈🙏）</p>
<p>明天回家，今天收到意向书，真的难掩心中的激动和喜悦😭虽然是计算机科班，但并不是机器学习科班，基础可以说是非常薄弱，字节offer对于我来说真的太难得。</p>
<p>明天网易笔试的时候我正好在回家的飞机上，本来感觉挺遗憾，现在感觉无所谓了😂</p>
<hr>
<p>作者：南风哥哥<br>
<a class="link" target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/207092?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%89%9B%E5%AE%A2%E7%BD%91">https://www.nowcoder.com/discuss/207092?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2来源：牛客网<i class="fas fa-external-link-alt"></i></a></p>
<p>一面：</p>
<p>怎么推测抖音用户是男性还是女性？怎么确认判断结果的靠谱程度？</p>
<p>分类问题的指标？准确度、召回率、PR曲线</p>
<p>相关系数怎么计算？讲一讲协方差和它的意义？</p>
<p>详细介绍一下实习经历？有没有场景落地？</p>
<p>特征选择的方法？Lasso回归、相关系数等</p>
<p>为什么要用正则化？解释了奥卡姆剃刀</p>
<p>L1正则化与L2正则化的区别？解释了参数先验和拉格朗日乘子法</p>
<p>手撕代码：</p>
<p>求股票的最大利润，例如[1, 3, 1, 8, 10, 3]，只能买卖一次，计算最大收益</p>
<p>能买卖无数次，计算最大收益</p>
<p>只能买卖两次，计算最大收益</p>
<p>二面：</p>
<p>一定要走算法岗吗？还是大数据也OK？</p>
<p>简单说一下最有成就感的项目案例？介绍了比赛经历</p>
<p>简单说一下对假设检验的理解？没答上来。。。</p>
<p>抽样一般有哪些方法？答偏了，讲了欠采样、过采样</p>
<p>解释MCMC采样？讲了马尔可夫链、蒙特卡洛方法，改进版的M-H采样、吉布斯采样</p>
<p>与计算机相关的课程有哪些？数据结构、计算机网络、操作系统。。。嗯。。。都没学过</p>
<p>说几个常用排序算法的时间复杂度、空间复杂度、稳定性？</p>
<p>Linux系统的常用命令？</p>
<p>SQL如何取出成绩表中各科的前三名？</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> </span><br><span class="line">(  <span class="keyword">select</span> subject,name,score,<span class="built_in">ROW_NUMBER</span>() <span class="keyword">over</span>(<span class="keyword">PARTITION</span> <span class="keyword">by</span> subject <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>)  	<span class="keyword">as</span> num <span class="keyword">from</span> #score </span><br><span class="line">) T </span><br><span class="line"><span class="keyword">where</span> T.num <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> subject </span><br></pre></td></tr></table></figure>
</blockquote>
<p>对什么语言比较熟？C++、Python</p>
<p>手撕代码：</p>
<p>排序数组中绝对值不同的个数</p>
<p>字符串转整数</p>
<p>三面：</p>
<p>前面两面聊的怎么样？</p>
<p>为什么想做算法？</p>
<p>讲一下实习经历？大概用了什么方法？</p>
<p>抛一个不均匀硬币五次，两次正三次反，下一次正的概率p1是多少？</p>
<p>抛一个不均匀硬币五十次，二十次正三十次反，下一次正的概率p2是多少？</p>
<p>为什么概率是0.4?解释极大似然估计，求导计算出p1=p2=0.4</p>
<p>如果真实的概率是p，为什么你会觉得p2更接近p？</p>
<p>机器学习训练中，数据分为几份？</p>
<p>验证集和测试集的区别？</p>
<blockquote>
<p><strong>训练集用于训练模型参数，测试集用于估计模型对样本的泛化误差，验证集用于“训练”模型的超参数。</strong></p>
</blockquote>
<p>手撕代码：</p>
<p>1，2，…，N中，字符1出现的次数</p>
<p>判断a+b&gt;c?要考虑溢出</p>
<p>感受：一面问的是基础题，基本都答上来了。二面开始被虐，计算机基础太薄弱，统计学知识也很欠缺，面试官的评价是“虽然都有了解，但不系统”。三面感觉面试官是个大佬，简单的问题会一直深挖，着重对知识的理解程度。</p>
<p>总结：欠缺的地方还有很多，一点一点补吧</p>
<hr>
<p>作者：Neymarkim<br>
<a class="link" target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/192689?type=post&amp;order=time&amp;pos=&amp;page=2&amp;subType=2%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%89%9B%E5%AE%A2%E7%BD%91">https://www.nowcoder.com/discuss/192689?type=post&amp;order=time&amp;pos=&amp;page=2&amp;subType=2来源：牛客网<i class="fas fa-external-link-alt"></i></a></p>
<p>2.lightgbm GBDT xgb，问的超级细，可能持续了7 8分钟，XGB残差怎么用一次和二次梯度求，分裂点怎么求，思想原理是什么。XGB实际使用中重要的超参数，你们比赛中用的目标函数是什么，为什么lightgbm速度更快，其并行计算如何实现（这点没回答上）</p>
<p>3.bagging  boosting 的区别，谁是更关注方差 ，谁是更关注偏差</p>
<p>4.如何防止过拟合,项目中用过哪些手段</p>
<p>5.W2V 的原理 ，两种生成方式，W2V的思想到底是什么，为什么要这样做，W2V的缺点，W2V中所用的softmax 比起普通softmax有何区别，为什么能减少计算量（我并不是搞自然语言的，这一波问的我有点捉襟见肘，只是勉强回答了，面试官很好，我没回答清楚地就给我讲，引导我）</p>
<p>6.embeding的方法 FM FFM deep FM</p>
<p>7.attention (毕竟是 attention is all you need 基本都会问)</p>
<p>8.给他讲做的CTR比赛，主要问怎么做特征，onehot 特征多了会有什么问题，为什么有时会导致效果下降（我回答的是onehot 特征占用维度太高，可能会湮没其他一些重要的特征）</p>
<p>可能还有一些问题记不起来了，反正真的就是抓住一个点，不停地深入</p>
<p>9.模型的容量问题</p>
<p>10.编程，比较简单的二分法</p>
<p>一面 1H35min 可真是太恐怖了，但整体体验很好，面试官会给你讨论，给你讲</p>
<p>来源：牛客网</p>
<p>1.开门见山，一道概率题，真的懵了，先问我bagging  boosting 的区别，我愉快的回答了，然后题就来了，bagging 中随机有放回采样，假如一共有N个样本 采样了N次，得到N个采样数据，去重后有X个数据  求E（X），我只列出了暴力计算的方法，是有简单的我没想出来,各位大神知道的可以讲讲</p>
<ol start="2">
<li>
<p>resnet VGG介绍 主要特色</p>
</li>
<li>
<p>1*1的卷积核 有什么用</p>
</li>
<li>
<p>max pooling 梯度传导</p>
</li>
<li>
<p>5.如何防止梯度消失，为什么会有梯度消失</p>
</li>
<li>
<p>6.又是做题，数据结构的，找出一颗完全二叉树最后一个节点，时间复杂度要求 logN的平方</p>
</li>
</ol>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">root</span>):</span></span><br><span class="line">    left = getdepth(root.left)</span><br><span class="line">    right = getdepth(root.right)</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">		cur = cur.left</span><br><span class="line">        left = getdepth(root.left)</span><br><span class="line">        right = getdepth(root.right)</span><br><span class="line">    <span class="keyword">if</span> left == right:</span><br><span class="line">        cur = right:</span><br><span class="line">        <span class="keyword">while</span> cur.right:</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">	<span class="keyword">return</span> cur</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="hr面-521">HR面  5.21</h1>
<p>二面10分钟后就是HR面，问问基本情况，但问的还是很多，从实习的时间，工作的兴趣和期望，自我感觉的优缺点，曾经面临的困难，抗压能力等等吧</p>
<p>HR小姐姐一来就说她们不会刷人，只要我确定能去就能发OFFER，当时比较激动，连小姐姐声音好不好听都记不得了，我想肯定是很好听的。</p>
<hr>
<p>作者：Ococococ<br>
<a class="link" target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/212382?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%89%9B%E5%AE%A2%E7%BD%91">https://www.nowcoder.com/discuss/212382?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2来源：牛客网<i class="fas fa-external-link-alt"></i></a></p>
<p>2.这个项目要是你应该怎么做？</p>
<p>Oneclass模型？你知道哪些？普通svm能做oneclass吗？为什么？应该怎么才能做？</p>
<p>用过抖音么？怎么分析新老用户活跃度差异？</p>
<p>你会c++？讲几个关键字？</p>
<p>C++的异常？</p>
<p>水库抽样，我虽然听说过但还是不会，卒。</p>
<p>1-5的随机数发生器怎么生成1-7的？当时脑子抽了，明明想了一个正确的答案不敢说。</p>
<p>肯定是凉了，给我机会我不中用啊。</p>
<p>希望下午的拼多多能有个面试机会吧。</p>
<hr>
<p>作者：不瘦20.5斤不改名<br>
<a class="link" target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/215858?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%89%9B%E5%AE%A2%E7%BD%91">https://www.nowcoder.com/discuss/215858?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2来源：牛客网<i class="fas fa-external-link-alt"></i></a></p>
<p>1进程和线程</p>
<p>2编译原理，什么鬼，不懂</p>
<p>3队列和栈</p>
<p>4pytorch和tensorflow的区别</p>
<p>5项目里的问题，比价常规</p>
<p>6缓解过拟合的方法</p>
<p>7代码题，手撕实现图像的resize和rotate90度</p>
<p>二面：</p>
<p>1.项目</p>
<p>2.代码：找出数组里的任意峰值，需要优化到O(logn)，</p>
<p>最长不重复字符串</p>
<p>三面：</p>
<p>1实习经历</p>
<p>2小目标检测有哪些trick</p>
<p>3smoothl1的好处</p>
<p>4代码题</p>
<p>有一个1000w的视频库，每个视频3-5分钟。 新来一个视频，我们需要去这1000w的视频库里查询，是否存在相同视频。 1 选择使用什么样的特征 。 2 设计一个好的index，使得查询尽可能快 （这1000w视频可以离线处理）</p>
<p>写一个函数，输入是N个文件，每个文件中是很多float的数值，文件内部无序。输出是一个有序的大文件，内存约束2个G，磁盘可以随便用，具体怎么实现比较高效</p>
<p>一面面的比较烂，没想到自己能进二面，后面两面比较顺，等了一个周今天总算收到意向书，希望大家早日拿到心仪的offer</p>
<hr>
<p>作者：水煮鱼201906300703978<br>
<a class="link" target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/209478?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%89%9B%E5%AE%A2%E7%BD%91">https://www.nowcoder.com/discuss/209478?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2来源：牛客网<i class="fas fa-external-link-alt"></i></a></p>
<p>整体面试一面二面二面，每轮都会写写代码，但是都维持在leetcode上easy和medium的难度，基本上刷个200来道，都不会有太大问题。我面试之前也去刷了牛客网上的题。</p>
<p>细节上，设计到机器学校的一些知识，我的复习策略就是疯狂看面经，看技术博客。</p>
<p>印象深的问题有：</p>
<p>1.给你M个正样本，N个负样本，以及他们的预测值P，求AUC。（写完之后接问：AUC究竟在衡量模型什么能力？如果现在所有预测值都*1.2，AUC是否会变化？）</p>
<p>这一题印象深刻是因为平时在计算auc的时候，很多同学都知道是roc曲线的面积，但是对auc具体的含义了解不多。</p>
<p>2.Attention</p>
<p>考虑到最近Attention的火爆和字节跳动的主要技术优势，attention这一个技术热点是一定要复习的（然而我没仔细看，非常后悔，面完之后从头到尾看了一遍）。</p>
<p>3.BatchNorm<br>
这一个问题其实我有用过，我也知道原理，但是当面试问具体公示的时候，还是愣了一下，但是BN无疑是一个很火的应用，必须要会。</p>
<p>其他的例如softmax与cross entropy的推导，过拟合与正则化，BiLSTM，Gradient Explosion，Top N，特征选择都是常规问题就不仔细说了。</p>
<p>整体面试体验真的非常好，面试官很nice，一面二面的面试官，问得很仔细，我对问题理解错了给我纠正之后让我再思考，因为是视频面，反而不紧张。三面的姐姐问的最详细，但是很和善。大家面试的时候放松心态，做足准备就好，谋事在人，成事在天，不必太过紧张。如果面试中遇到思路卡壳可以一点一点解释，不用着急。</p>
<p>最终hr面之后拿到了offer，字节跳动data部，然后跟技术人员又聊了聊技术。跟家里谈了谈之后，决定接受offer。</p>
<p>有一个问题想问问大家，字节跳动data部是一个怎么样的部门呢？算是核心部门吗？</p>
<p>希望大家都能获得自己理想的offer！秋招加油！</p>
<hr>
<p>作者：越陵殇<br>
<a class="link" target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/211174?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%89%9B%E5%AE%A2%E7%BD%91">https://www.nowcoder.com/discuss/211174?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=2来源：牛客网<i class="fas fa-external-link-alt"></i></a></p>
<p>还问了人像分割比赛中的设计思路和改进策略，训练方式之类的，面试官比较懂这一块，聊得挺融洽的。</p>
<h2 id="深度学习相关">深度学习相关</h2>
<p>loss(x,y)=max(x,y)，求该函数分别对x和y的偏导怎么计算？（参照max pooliing的求梯度解释）；</p>
<p>BN的实现？</p>
<p>BN的作用？</p>
<p>BN训练期间和测试期间的区别？</p>
<p>BN中的batch怎么选择？<a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61725100">https://zhuanlan.zhihu.com/p/61725100<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-060950.jpg" alt="img"></p>
<p>普通卷的参数量如何计算？</p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-060946.png" alt="img"></p>
<p>如果换成depthwise conv呢？</p>
<p>大小为3*3，padding=0，stride=1的卷积核在经过2次计算后感受野为多少？参考：<a class="link" target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31004121">https://zhuanlan.zhihu.com/p/31004121<i class="fas fa-external-link-alt"></i></a></p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-29-060948.png" alt="img"></p>
<p>减小过拟合的方法有哪些？</p>
<p>YOLO v3的loss函数（讲错了，当时一紧张就讲成了Faster RCNN的loss函数，脑子发热了，难受~）</p>
<p>KL散度有了解吗？</p>
<p>smooth L1函数的作用为什么效果更好？</p>
<h2 id="一些发散性的题目">一些发散性的题目</h2>
<p>不规则图形的面积如何计算？</p>
<h2 id="算法">算法：</h2>
<p>给定一个二维数组，其中包含元素为0~9，要求矩阵中所有元素为0的行和列，并将所有0元素所在的行和列也全部更新为0。</p>
<hr>
<p>1、自我介绍，聊相关内容，主要是一篇小论文以及相关领域内的其他论文</p>
<p>2、聊项目，yolo检测相关</p>
<p>3、问检测中能提升速度但不损失性能的操作有哪些，用过的没用过都行</p>
<p>4、编程题：稀疏向量的点乘。先要我自定义存储的结构体，然后写函数头，再编程，本来要我用template但我不会就算了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x, y, val</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.val = val</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrixDotMult</span>(<span class="params">m1, m2, m, n</span>):</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">	i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(m1) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(m2):</span><br><span class="line">        <span class="keyword">if</span> m1[i].x == m2.[j].x <span class="keyword">and</span> m1[i].y == m2[j].y:</span><br><span class="line">            ans += m1[i].val * m2[j].val</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> m1[i].x &lt;= m2[j].x <span class="keyword">and</span> m1[i].y &lt; m2[j].y:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>二面：</p>
<p>1、自我介绍，还是聊论文，但问的点和一面的不一样。</p>
<p>2、一道数学题，A、B两人投硬币，谁先投到正面谁就赢，求先投的人赢的概率  2/3</p>
<p>3、LR、SVM的公式推导</p>
<p>4、特征点的匹配机制有哪些</p>
<p>5、深度学习中评价指标的解释，mAP、PR曲线、AUC</p>
<blockquote>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-31-094948.png" alt="image-20190831174947458"></p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-31-095010.png" alt="image-20190831175010353"></p>
</blockquote>
<p>6、编程题：链表反转，迭代+递归两种都要写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    t = reverse(head.<span class="built_in">next</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span>, head.<span class="built_in">next</span> = head, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head</span>):</span></span><br><span class="line">    p = head</span><br><span class="line">    prev = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> p:</span><br><span class="line">		t = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = prev</span><br><span class="line">        prev = p</span><br><span class="line">        p = t</span><br><span class="line">  <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>
<p>三面：（居然还有三面！二面的时候感觉凉透了）</p>
<p>全程问项目，不问很深的技术，只是让你讲项目细节、效果如何，感觉是来验证简历真假的，问完就结束了</p>
<p>没有编程题</p>
<p>7.25更新，收到了感谢信，已凉</p>
<hr>
<p>一面：</p>
<p>二叉树镜像</p>
<p>LRU Cache</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="literal">None</span>, val=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.key = key</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.head = Node()</span><br><span class="line">        self.tail = Node()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.dic = &#123;&#125;</span><br><span class="line">        self.cnt = capacity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move2tail</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        </span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        node.<span class="built_in">next</span> = self.tail</span><br><span class="line">        node.prev = self.tail.prev</span><br><span class="line">        node.<span class="built_in">next</span>.prev = node</span><br><span class="line">        node.prev.<span class="built_in">next</span> = node</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.dic:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        val = self.dic[key].val</span><br><span class="line">        self.move2tail(self.dic[key])</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            self.dic[key].val = value</span><br><span class="line">            self.move2tail(self.dic[key])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.dic) == self.cnt:</span><br><span class="line">                self.dic.pop(self.head.<span class="built_in">next</span>.val)</span><br><span class="line">                self.head.<span class="built_in">next</span> = self.head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                self.head.<span class="built_in">next</span>.prev = self.head</span><br><span class="line">                </span><br><span class="line">            t = Node(key, value)</span><br><span class="line">            self.dic[key] = t</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            t.<span class="built_in">next</span> = self.tail</span><br><span class="line">            t.prev = self.tail.prev</span><br><span class="line">            t.<span class="built_in">next</span>.prev = t</span><br><span class="line">            t.prev.<span class="built_in">next</span> = t</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>全排列稍微变形了一下</p>
<p>二面：</p>
<p>LFU Cache</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        self.freq_key = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span>, new=<span class="literal">False</span></span>) -&gt; <span class="built_in">int</span>:</span>      </span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 找出当前key的频率并加1</span></span><br><span class="line">        <span class="keyword">for</span> freq <span class="keyword">in</span> self.freq_key:</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> self.freq_key[freq]:</span><br><span class="line">                self.freq_key[freq].remove(key)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.freq_key[freq]:</span><br><span class="line">                    self.freq_key.pop(freq)</span><br><span class="line">                self.freq_key.setdefault(freq+<span class="number">1</span>, []).append(key)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> self.cache.get(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.capacity &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) == self.capacity:</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 弹出频率最小的第一个元素，并移除</span></span><br><span class="line">                pop_key = self.freq_key[<span class="built_in">min</span>(self.freq_key)].pop(<span class="number">0</span>)</span><br><span class="line">                self.cache.pop(pop_key)</span><br><span class="line">                </span><br><span class="line">            self.cache[key] = value</span><br><span class="line">            self.freq_key.setdefault(<span class="number">1</span>, []).append(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.cache[key] = value</span><br><span class="line">            self.get(key)</span><br></pre></td></tr></table></figure>
<p>三面：</p>
<p>一个圆形的时钟，一个点从12点出发，每秒可以顺时针走一步也可以逆时针走一步，问N秒后回到12点有多少种走法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ways</span>(<span class="params">n</span>):</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*<span class="number">60</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>):</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][(j-<span class="number">1</span>+n)%<span class="number">60</span>] + dp[i-<span class="number">1</span>][(j+<span class="number">1</span>)%<span class="number">60</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>N个人，有2N只手，彼此握手，问形成的环的期望数（一个人可以左手握右手形成一个环，两个人交叉握手和正对着握手，都可以形成一个环）。</p>
<blockquote>
<p>记绳子数为$N$时，环的个数为随机变量$X_N$，期望为$\mu_N=E{X_N}$。显然，$X_N$可能的取值为$1, 2, \dots, N$。直接的想法是计算$X_N$的概率分布$P{X_N=m}$然后再求期望，但显然过于复杂。考虑如下的思路：先随机选取两个绳头系在一起，有且只有两种结果：a. 这两个绳头属于一根绳子，于是形成了一个环，而剩下的$N-1$根绳子归结为规模为$N-1$的问题；b. 这两个绳头属于不同的绳子，于是这两根绳子形成了一根绳子，和剩下$N-2$共同构成了规模为$N-1$的问题。记a、b发生的概率分别为$P{a}, P{b}$，则有<br>
$$<br>
\mu_{N}=\left(\mu_{N-1}+1\right) P{a}+\mu_{N-1} P{b}<br>
$$<br>
下面计算a、b发生的概率。选这两个绳头时，第一个可以任选。而从剩下$2N-1$个绳头中选择第二个时，只有一种选择会产生情况a，即选中和第一个绳头属于同一根绳子的绳头；剩下$2N-2$种选择将产生情况b。于是:<br>
$$<br>
\begin{aligned} P{a} &amp;=\frac{1}{2 N-1} \ \ P{b} &amp;=\frac{2 N-2}{2 N-1} \end{aligned}<br>
$$</p>
<p>$$<br>
\mu_{N}=\frac{1}{2 N-1}\left(\mu_{N-1}+1\right)+\frac{2 N-2}{2 N-1} \mu_{N-1}<br>
$$</p>
<p>$$<br>
\mu_{N}=\mu_{N-1}+\frac{1}{2 N-1}<br>
$$</p>
<p>$$<br>
\mu_{N}=\sum_{n=1}^{N} \frac{1}{2 n-1}<br>
$$</p>
</blockquote>
<hr>
<p>TCP 四次挥手，滑动窗口</p>
<blockquote>
<p>滑动窗口协议（Sliding Window Protocol），属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。</p>
<p>TCP通过滑动窗口的概念来进行流量控制。设想在发送端发送数据的速度很快而接收端接收速度却很慢的情况下，为了保证数据不丢失，显然需要进行流量控制， 协调好通信双方的工作节奏。所谓滑动窗口，可以理解成接收端所能提供的缓冲区大小。TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓 冲区。由于窗口由16位bit所定义，所以接收端TCP 能最大提供65535个字节的缓冲。由此，可以利用窗口大小和第一个数据的序列号计算出最大可接收的数据序列号。</p>
</blockquote>
<p>Python GIL</p>
<blockquote>
<p>Guido van Rossum（吉多·范罗苏姆）创建python时就只考虑到单核cpu，解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁， 于是有了GIL这把超级大锁。因为cpython解析只允许拥有GIL全局解析器锁才能运行程序，这样就保证了保证同一个时刻只允许一个线程可以使用cpu。由于大量的程序开发者接收了这套机制,现在代码量越来越多,已经不容易通过c代码去解决这个问题。<br>
————————————————<br>
即全局解释器所（<a class="link" target="_blank" rel="noopener" href="https://www.baidu.com/link?url=wcyORPNvihJlWYZsd97z3F3g6xZfs09N64Jc56POq3P7r3h5vIxVFcjGiZjosC6g3jhmBh13DS36rKld5eBfWq&amp;wd=&amp;eqid=aa7605a200005349000000025aa0f4fb">global interpreter lock<i class="fas fa-external-link-alt"></i></a>），每个线程在执行时候都需要先获取GIL，保证同一时刻只有一个线程可以执行代码，即同一时刻只有一个线程使用CPU，也就是说多线程并不是真正意义上的同时执行</p>
<p>问题1: 什么时候会释放Gil锁,<br>
答 :<br>
1 遇到像 i/o操作这种 会有时间空闲情况 造成cpu闲置的情况会释放Gil<br>
2 会有一个专门ticks进行计数 一旦ticks数值达到100 这个时候释放Gil锁 线程之间开始竞争Gil锁(说明:<br>
ticks这个数值可以进行设置来延长或者缩减获得Gil锁的线程使用cpu的时间)</p>
<p>Gil锁  : 保证同一时刻只有一个线程能使用到cpu<br>
互斥锁 : 多线程时,保证修改共享数据时有序的修改,不会产生数据修改混</p>
</blockquote>
<p>2轮：</p>
<p>C++和python里的future是分别是干啥的</p>
<blockquote>
<p>要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。</p>
<p>Python提供了<code>__future__</code>模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。举例说明如下：</p>
</blockquote>
<p>3轮：</p>
<p>看你做过爬虫，知道有哪些反爬虫的机制 = = （这个问题问的贼多，跟面试官探讨了很久，提了好几个方案都看他不是很满意）</p>
<ul>
<li><strong>通过UA 识别爬虫</strong> 有些爬虫的UA是特殊的，与正常浏览器的不一样，可通过识别特征UA，直接封掉爬虫请求</li>
<li><strong>设置IP访问频率，如果超过一定频率，弹出验证码</strong> 如果输入正确的验证码，则放行，如果没有输入，则拉入禁止一段时间，如果超过禁爬时间，再次出发验证码，则拉入黑名单。当然根据具体的业务，为不同场景设置不同阈值，比如登陆用户和非登陆用户，请求是否含有refer。</li>
<li><strong>通过并发识别爬虫</strong> 有些爬虫的并发是很高的，统计并发最高的IP，加入黑名单（或者直接封掉爬虫IP所在C段）</li>
<li><strong>请求的时间窗口过滤统计</strong> 爬虫爬取网页的频率都是比较固定的，不像人去访问网页，中间的间隔时间比较无规则，所以我们可以给每个IP地址建立一个时间窗口，记录IP地址最近12次访问时间，每记录一次就滑动一次窗口，比较最近访问时间和当前时间，如果间隔时间很长判断不是爬虫，清除时间窗口，如果间隔不长，就回溯计算指定时间段的访问频率，如果访问频率超过阀值，就转向验证码页面让用户填写验证码</li>
<li><strong>限制单个ip/api token的访问量</strong> 比如15分钟限制访问页面180次，具体标准可参考一些大型网站的公开api，如twitter api，对于抓取用户公开信息的爬虫要格外敏感</li>
<li><strong>识别出合法爬虫</strong> 对http头agent进行验证，是否标记为、百度的spider，严格一点的话应该判别来源IP是否为、baidu的爬虫IP，这些IP在网上都可以找到。校验出来IP不在白名单就可以阻止访问内容。</li>
<li><strong>蜜罐资源</strong> 爬虫解析离不开正则匹配，适当在页面添加一些正常浏览器浏览访问不到的资源，一旦有ip访问，过滤下头部是不是搜素引擎的蜘蛛，不是就可以直接封了。比如说隐式链接。</li>
</ul>
<ul>
<li><strong>策略1</strong>：<strong>设置下载延迟</strong>，比如数字设置为5秒，越大越安全</li>
<li><strong>策略2</strong>：<strong>禁止Cookie</strong>，某些网站会通过Cookie识别用户身份，禁用后使得服务器无法识别爬虫轨迹</li>
<li><strong>策略3</strong>：<strong>使用user agent池</strong>。也就是每次发送的时候随机从池中选择不一样的浏览器头信息，防止暴露爬虫身份</li>
<li><strong>策略4</strong>：<strong>使用IP池</strong>，这个需要大量的IP资源，可以通过抓取网上免费公开的IP建成自有的IP代理池。</li>
<li><strong>策略5</strong>：<strong>分布式爬取</strong>，这个是针对大型爬虫系统的，实现一个分布式的爬虫，主要为以下几个步骤：  1、基本的http抓取工具，如scrapy；  2、避免重复抓取网页，如Bloom Filter；  3、维护一个所有集群机器能够有效分享的分布式队列；  4、将分布式队列和Scrapy的结合；  5、后续处理，网页析取(如python-goose)，存储(如Mongodb)。</li>
<li><strong>策略6：模拟登录—浏览器登录的爬取</strong> 设置一个cookie处理对象，它负责将cookie添加到http请求中，并能从http响应中得到cookie，向网站登录页面发送一个请求Request, 包括登录url，POST请求的数据，Http header利用urllib2.urlopen发送请求，接收WEB服务器的Response。</li>
</ul>
<hr>
<p>第一题，不能用系统自带的除法，要求用算法自己implement一个除法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">div</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> a &gt;= b:</span><br><span class="line">            x = b</span><br><span class="line">            y = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> a &gt;= (x&lt;&lt;<span class="number">1</span>):</span><br><span class="line">                x &lt;&lt;= <span class="number">1</span></span><br><span class="line">                y &lt;&lt;= <span class="number">1</span></span><br><span class="line">            ans += y</span><br><span class="line">            a -= x</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(div(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二题，用O（n）的方法找到一个无序数组的中位数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findmid</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">nums, i, j</span>):</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickFind</span>(<span class="params">nums, target, left, right</span>):</span></span><br><span class="line">        pivot = left</span><br><span class="line">        swap(nums, pivot, right)</span><br><span class="line">        l = left</span><br><span class="line">        r = right - <span class="number">1</span></span><br><span class="line">        i = l</span><br><span class="line">        <span class="keyword">while</span> i &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[right - <span class="number">1</span>]:</span><br><span class="line">                swap(nums, i, l)</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                swap(nums, i, r)</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        swap(nums, i, right)</span><br><span class="line">        <span class="keyword">if</span> i == target:</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        <span class="keyword">elif</span> i &lt; target:</span><br><span class="line">            <span class="keyword">return</span> quickFind(nums, target - i, i + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> quickFind(nums, target, left, i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> quickFind(nums, n // <span class="number">2</span>, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (quickFind(nums, n // <span class="number">2</span>, <span class="number">0</span>, n - <span class="number">1</span>) + quickFind(nums, n // <span class="number">2</span> - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l = [[], [<span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">        <span class="built_in">print</span>(findmid(i))</span><br></pre></td></tr></table></figure>
<hr>
<p>梯度爆炸梯度消失</p>
<p>L1范数L2范数原，公式</p>
<p>L1</p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-31-024430.png" alt="image-20190831104429967"><br>
$$<br>
J=J_{0}+\alpha \sum_{w}|w|<br>
$$<br>
L2</p>
<p><img src="https://blog-1259562174.cos.ap-chengdu.myqcloud.com/2019-08-31-024530.png" alt="image-20190831104529551"><br>
$$<br>
J=J_{0}+\alpha \sum_{w}w^2<br>
$$</p>
<ul>
<li>为什么能够处理过拟合
<ul>
<li>奥卡姆剃刀原理，模型越简单越好</li>
<li>相当于是对模型的解空间进行约束</li>
</ul>
</li>
</ul>
<p>L1会趋向于产生少量的特征，而其它特征都是0。L2会选择更多的特征，这些特征都会趋近于0。L1在特征选择时非常有用，而L2只是一种防止过拟合的方法。在所有特征中只有少数特征起重要作用的情况下，选择L1范数比较合适，因为它能自动选择特征。而如果所有特征中，大部分特征都能起作用，而且起的作用很平均，那么使用L2范数也许更合适。</p>
<p><strong>过拟合</strong></p>
<p>训练过程中的损失减小，准确度提升，但是在测试的时候loss会增大，准确度减小。</p>
<p>模型太过于复杂造成的，解决方法包括：</p>
<p>数据方面：数据增广、减少数据的维度</p>
<p>模型方面：用较简单的模型、使用BN、Dropout</p>
<p>损失方面：添加增则项、加大增则项的权重、换一个损失</p>
<p>训练方面：提前终止</p>
<p><strong>Yolo ssd fast系列区别</strong></p>
<p><strong>包括yolo 1-3（对于yolo的细节提问）</strong></p>
<p><strong>ssd 各种变体</strong></p>
<p><strong>判断链表有环</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exisitCircle</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    slow, fast = head, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>二叉树中序遍历</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">    l = []</span><br><span class="line">    cur = root</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">while</span> l <span class="keyword">or</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            l.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = l.pop()</span><br><span class="line">            ans.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/article/%E9%9D%A2%E7%AD%8B/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item"></span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/article/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">背包问题总结</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">z</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E9%9D%A2-%E8%A7%86%E9%A2%91%E9%9D%A260min2019717"><span class="nav-text">二面 视频面（60min）2019&#x2F;7&#x2F;17</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E9%9D%A2-%E4%B8%BB%E7%AE%A1%E9%9D%A2-%E8%A7%86%E9%A2%91%E9%9D%A2-30min2019723"><span class="nav-text">三面 主管面 视频面 （30min）2019&#x2F;7&#x2F;23</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hr%E9%9D%A2-521"><span class="nav-text">HR面  5.21</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3"><span class="nav-text">深度学习相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%8F%91%E6%95%A3%E6%80%A7%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="nav-text">一些发散性的题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-text">算法：</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
